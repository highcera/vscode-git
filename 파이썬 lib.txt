tablewidget 중앙 정렬
https://curioso365.tistory.com/90
https://spec.tistory.com/442
self.tablewidget.item(x, y).setTextAlignment(Qt.AlignRight)
AlignHCenter 0x0004 / AlignVCenter 0x0080


예외처리 : try exception
https://dojang.io/mod/page/view.php?id=2398


특정 웹 사이트에서 매일 스크래핑하는 데이터를 엑셀 파일 하나에 일자별로 저장하고 싶다면 어떻게 할 수 있을까요? 판다스에서는 pd.ExcelWriter()를 사용해서 기존 파일에 새 시트만 추가하여 저장하는 방법이 있습니다.

 

pd.ExcelWriter()를 사용해서 기존 파일에 새 시트 추가하여 저장하기
import pandas as pd
# 특정 파일이 해당 경로에 존재하는지 알아보기 위하여
# os.path.exists() 메서드를 사용하겠습니다.
import os

■ DataFrame 데이터 엑셀파일 저장
 
▶ https://ponyozzang.tistory.com/619

파이썬에서 DataFrame으로 작성한 데이터를 엑셀파일(xlsx, xls)로 저장하는 방법을 알아보겠습니다.
엑셀 파일로 데이터를 저장하기 위해서는 to_excel() 메서드를 사용합니다.

to_excel()사용 방법을 예제를 통해 알아보겠습니다.

xlwt, openpyxl 설치
to_excel()를 사용하면 내부에서는 xlwt, openpyxl 라이브러리를 사용합니다.

만약 라이브러리 설치가 되지 않았다면 엑셀 파일을 저장할 때 에러가 발생합니다.

import openpyxl
ModuleNotFoundError: No module named 'openpyxl'

커맨드로 인스톨하는 경우에는 pip를 사용합니다.

$ pip install xlwt
$ pip install openpyxl
환경에 따라 pip3를 사용해야 하는 경우도 있습니다.

엑셀 파일 쓰기
DataFrame에 데이터를 작성해 엑셀 파일로 출력하는 예제를 살펴보겠습니다.

import pandas as pd
import openpyxl

df = pd.DataFrame([[11, 21, 31], [12, 22, 32], [31, 32, 33]],
                  index=['one', 'two', 'three'], columns=['a', 'b', 'c'])

print(df)
#         a   b   c
# one    11  21  31
# two    12  22  32
# three  31  32  33

# 엑셀 파일 출력
df.to_excel('C:/Users/Administrator/Desktop/python/excel/export_sample.xlsx', sheet_name='new_name')

DataFrame에 작성한 데이터가 엑셀 파일로 출력되었습니다.

to_excel() 메서드 첫 번째 인수에는 엑셀 파일을 생성할 경로와 파일 이름을 지정합니다.
지정한 경로에 파일이 없는 경우에는 파일을 새로 만듭니다.
파일이 존재하는 경우에는 덮어쓰기를 합니다.
덮어쓰기를 하는 경우에는 기존 데이터는 삭제됩니다.
두 번째 인수에는 sheet_name에 시트 이름을 지정합니다.
생략하는 경우에는 Sheet1이라는 이름으로 시트가 생성됩니다.

index, columns
엑셀 파일을 생성할 때 index(행 이름)와 colunms(컬럼 이름)이 필요 없는 경우에는 index와 colunms를 False로 설정합니다.

import pandas as pd
import openpyxl

df = pd.DataFrame([[11, 21, 31], [12, 22, 32], [31, 32, 33]],
                  index=['one', 'two', 'three'], columns=['a', 'b', 'c'])

print(df)
#         a   b   c
# one    11  21  31
# two    12  22  32
# three  31  32  33

# 엑셀 파일 출력
df.to_excel('C:/Users/Administrator/Desktop/python/excel/export_sample.xlsx', sheet_name='new_name', index=False, header=False)

인덱스와 컬럼은 출력되지 않았습니다.
 
여러개 시트 만들기
엑셀 파일에 데이터를 저장할 때 여러개 시트를 만들 수 있습니다.

DataFrame이 여러개 이거나 또는 같은 내용을 여러 시트에 작성하고 싶은 경우 ExcelWriter를 사용합니다.

예제로 DataFrame을 2개 준비해 엑셀 파일에도 2개 시트를 만들도록 하겠습니다.

import pandas as pd
import openpyxl

df = pd.DataFrame([[11, 21, 31], [12, 22, 32], [31, 32, 33]],
                  index=['one', 'two', 'three'], columns=['a', 'b', 'c'])

print(df)
#         a   b   c
# one    11  21  31
# two    12  22  32
# three  31  32  33

df2 = df[['a', 'c']]
print(df2)
#         a   c
# one    11  31
# two    12  32
# three  31  33

# 엑셀 파일 출력
# 여러개 시트 생성
with pd.ExcelWriter('C:/Users/Administrator/Desktop/python/excel/export_sample.xlsx') as writer:
    df.to_excel(writer, sheet_name='sheet1')
    df2.to_excel(writer, sheet_name='sheet2')

변수 df에 저장된 값은 sheet1 시트에, df2에 저장된 값은 sheet2 시트에 출력되었습니다.

ExcelWriter() 함수에는 파일 경로와 파일 이름을 지정해 ExcelWriter 오브젝트를 생성합니다.
생성한 오브젝트를 to_excel() 메서드 첫 번째 인수로 설정합니다.
with 블럭을 사용하면 writer.save()와 writer.close()를 호출하지 않아도 됩니다.

엑셀 파일 덮어 쓰기
ExcelWriter 오브젝트의 book 속성에 poenpyxl을 사용해 읽어들인 Workbook 오브젝트를 지정하면, 기존 Excel 파일을 새로운 시트로써 DataFrame을 추가할 수 있습니다.
단, openpyxl를 사용해서 처리하기 때문에 xlsx 파일만 가능합니다. 

import pandas as pd
import openpyxl

df = pd.DataFrame([[11, 21, 31], [12, 22, 32], [31, 32, 33]],
                  index=['newone', 'newtwo', 'newthree'], columns=['newa', 'newb', 'newc'])

print(df)
#           newa  newb  newc
# newone      11    21    31
# newtwo      12    22    32
# newthree    31    32    33

df2 = df[['newa', 'newc']]
print(df2)
#           newa  newc
# newone      11    31
# newtwo      12    32
# newthree    31    33

# 엑셀 파일  덮어 쓰기
path = 'C:/Users/Administrator/Desktop/python/excel/export_sample.xlsx'

with pd.ExcelWriter(path) as writer:
    writer.book = openpyxl.load_workbook(path)
    df.to_excel(writer, sheet_name='new_sheet1')
    df2.to_excel(writer, sheet_name='new_sheet2')
 
기존에 작성했던 sheet1과 sheet2 시트가 삭제되지 않고 남아있습니다.
새로 지정한 new_sheet1과 new_sheet2 시트가 추가되었습니다. 

to_excel()를 사용해 실행하면 sheet1과 sheet2 시트는 삭제됩니다.

 
newfile = 'P:.\\..\\{}.xlsx'.format(new_file)
writer = pd.ExcelWriter(newfile)
if self.filtered_thr['DC-Bias 측정'][0] == '저주파':
    self.low.to_excel(writer, index=False, engine = 'openpyxl')
elif self.filtered_thr['DC-Bias 측정'][0] == '고주파':
    self.high.to_excel(writer, index=False, engine = 'openpyxl')
writer.save()

▶ https://hogni.tistory.com/23

아래의 데이터프레임은 1일부터 3일까지의 인터넷 쇼핑몰의 과자 가격을 스크래핑한 가상의 데이터입니다.

# 샘플 데이터 생성
day1 = {'날짜': ['2020-01-01', '2020-01-01'], '상품명': ['홈런볼', '초코파이'], '가격': [1500, 3500]}
day2 = {'날짜': ['2020-01-02', '2020-01-02'], '상품명': ['홈런볼', '초코파이'], '가격': [1600, 3200]}
day3 = {'날짜': ['2020-01-03', '2020-01-03'], '상품명': ['홈런볼', '초코파이'], '가격': [1800, 3700]}

df1 = pd.DataFrame(day1)
df2 = pd.DataFrame(day2)
df3 = pd.DataFrame(day3)
 

다음은 새 시트를 추가하여 저장하는 코드입니다.

# 최초 생성 이후 mode는 append; 새로운 시트를 추가합니다.
if not os.path.exists('output.xlsx'):
    with pd.ExcelWriter('output.xlsx', mode='w', engine='openpyxl') as writer:
        df.to_excel(writer, index=False)
else:
    with pd.ExcelWriter('output.xlsx', mode='a', engine='openpyxl') as writer:
        df.to_excel(writer, index=False)
 

위 코드에서 df를 각 일자의 데이터프레임 이름에 맞게 df1, df2, df3으로 바꿔서 실행시켜보면, 결과값이 각각의 시트에 저장된 것을 볼 수 있습니다.



Spyder 
주석 일괄 반영 Ctrl + 1


□ OS 모듈 사용 (https://ddolcat.tistory.com/654)
import os

#Get Current Directory
os.getcwd()

os.chdir("../") ''' 1 level move '''
os.chdir("P:\개인자료")  ''' Direct move '''

os.listdir()

os.path.dirname("C:/Users/Administrator/Untitled.ipynb")

os.path.isfile("C:/Users/Administrator/Untitled.ipynb") → T
os.path.isfile("C:/Users/Administrator/") → F

os.path.isdir("C:/Users/Administrator/Untitled.ipynb") → F
os.path.isdir("C:/Users/Administrator/") → T

dir, file = os.path.split("C:/Users/Administrator/Untitled.ipynb")
os.path.exists("C:/Users/Administrator/Untitled.ipynb") 존재 : T, 존재 X : F

os.path.getsize("C:/Users/Administrator/Untitled.ipynb")

os.path.join("C:/Users/Administrator", "Untitled.ipynb")
name, ext = os.path.splitext("Untitled.ipynb")

os.rename("File name 1","File name 2 ")

■ [Python 완전정복 시리즈] 2편 : Padas Data Frame 
https://wikidocs.net/book/7188

■ Python GUI - Pandas data frame
https://firstcheck.tistory.com/67

https://stackoverflow.com/questions/44603119/how-to-display-a-pandas-data-frame-with-pyqt5-pyside2

■ 데이터 가져오기 (https://wikidocs.net/150903)
▶ 엑셀 데이터 가져오기
import pandas as pd

file = 'c:\\폴더명\\파일명.xlsx'

# 시트 지정 안하면 첫 번째 시트를 가져옴.
df = pd.read_excel(file)

# 시트 이름 지정하여 가져오기
df = pd.read_excel(file, sheet_name = 'Sheet1')

# 시트 순서로 가져오기
df = pd.read_excel(file, sheet_name = 0)

# 행 인덱스를 지정하며 가져오기
df = pd.read_excel(file, sheet_name = 0, index_col = 0)

# 열 인덱스를 지정하며 가져오기
df = pd.read_excel(file, sheet_name = 0, header = 0)     # 기본적으로 첫 번째 행을 열 인덱스로 사용함.

# 원하는 컬럼만 가져오기
df = pd.read_excel(file, sheet_name = 0, usecols = 'A')
df = pd.read_excel(file, sheet_name = 0, usecols = ['A','C'])

# 처음 몇 줄 제외하고 가져오기
df = pd.read_excel(file, sheet_name = 0, skiprows = 4)

# 원하는 여러 컬럼 가져오기
df = pd.read_excel(file, sheet_name = 0, usecols = [0,2])

# 다양한 옵션
df = pd.read_excel(file,
                    sheet_name = '시트이름' or 시트번호 (기본 0),
                    index_col = '열이름' or 열번호,
                    header = 숫자 (기본 0) or None,
                    names = ['열이름1','열이름2','열이름3']
                    )


▶ csv 데이터 가져오기
import pandas as pd

file = 'c:\\폴더명\\파일명.csv'

# CSV 파일 가져오기
df = pd.read_csv(file)        # 기본 구분자는 쉼표

# 구분기호 지정하여 가져오기
df = pd.read_csv(file, " ")   # 탭은 \t 로 표현

# 가져오는 행 수 지정하기
df = pd.read_csv(file, " ", nrows = 2)    # 컬럼명 제외하고 2줄

# 인코딩 형식 지정하기 (주로 UTF-8과 euc-kr, cp949. 기본은 UTF-8)
df = pd.read_csv(file, " ", nrows = 2, encoding = "utf-8")
df = pd.read_csv(file, " ", nrows = 2, encoding = "euc-kr")

# 파일 경로 한글 있을 때 오류가 발생한다면 
(read_csv 메소드의 기본 파싱 언어가 C언어이기 때문. 파일형식 UTF-8일때 인코딩 형식은 utf-8-sig임.)
df = pd.read_csv(file, " ", engine = "python", nrows = 2, encoding = "utf-8-sig")

# 다양한 옵션
df = pd.read.csv(file,
                    encoding = 'cp949',
                    index_col = '열 이름 또는 숫자',
                    header = 숫자 또는 None (기본은 0),
                    sep = 구분자 (기본은 콤마),
                    names = 열 이름 리스트
                    )
# names로 열 이름 지정시 기존 열 이름 행이 있다면 header를 해당 행으로 지정하면 되고
# 기존에 열 이름이 없이 값 내용만 들어있다면 header를 None으로 하면 됨.

# CSV 파일은 엑셀과 동일한 방법으로 행과 열 인덱스를 설정하여 가져오는 열 지정 가능.


▶ SQL SERVER(mssql) 데이터 가져오기
import pandas as pd
import pyodbc

conn = pyodbc.connect(
        DRIVER='{odbc driver 11 for sql server}',
        server = 'localhost',
        database = 'db_name',
        uid = 'user_id',
        pwd = 'user_pw'
        )
query = open('c:\\폴더명\\파일명.sql').read()
df = pd.read_sql_query(query,conn)
conn.close()


▶ html로 저장된 xls 데이터 가져오기
import pandas as pd

file = 'c:\\폴더명\\파일명.xls'

# CSV 파일 가져오기
df = pd.read_html(file)[0]


▶ 대량 데이터는 pyarrow 통해 csv 파일로 빠르게 읽어오기
# 판다스로 엑셀 읽는 것 보다 pyarrow로 csv 읽는 것이 훨씬 빠름
# 한글 있는 CSV는 UTF-8로 저장 필요
import pandas as pd
from pyarrow import csv

file = 'c:\\폴더명\\파일명.xls'

# CSV 파일 가져오기
pyarrow_table = csv.read_csv(file)
df = pyarrow_table.to_pandas()


■ 데이터 핸들링
from pykrx import stock
import numpy as np 
import pandas as pd
from pandas import Series
 
def 장기_단기_이평선_수익률(df, Ns, Nl):
    df = df[  [ '종가' ] ].copy()
    df['ma_s'] = df['종가'].rolling( Ns ).mean( ).shift ( 1 )
    df['ma_l'] = df['종가'].rolling( Nl ).mean( ).shift ( 1 )
    cond = (df['ma_s'] > df['ma_l'])  & (df['ma_l'].pct_change() > 0)
    df['status'] = np.where(cond, 1, 0)
    df.iloc[-1, -1] = 0
    
    # 매수/매도 조건 
    매수조건 = (df['status'] == 1) & (df['status'].shift(1) != 1)
    매도조건 = (df['status'] == 0) & (df['status'].shift(1) == 1)
    
    # 수익률 계산
    수익률 = df.loc[매도조건, '종가'].reset_index(drop=True) / df.loc[매수조건, '종가'].reset_index(drop=True)
    수익률 = 수익률 - 0.002
    return 수익률.cumprod().iloc[-1]
 
df = stock.get_index_ohlcv_by_date("20220101", "20220630", "1001")
df = df[  [ '종가' ] ]
print(df)

result = [ ]
for i in range(2, 17):
    for j in range(30, 45):
        result.append(장기_단기_이평선_수익률(df, i, j))

index = pd.MultiIndex.from_product([ range(2, 17), range(30, 45)  ])
s = Series(result, index)
 
print(s.idxmax())
print(s.max())


■ Python 파이썬 PyQt5 기본함수 사용
https://nsing.tistory.com/25


■ Exel xlwings의 Book, Sheet, Range 객체 다루기 
https://maeng-gun.github.io/excel/excel3/

엑셀파일을 열고 시트와 셀을 지정해보자
이제 파이썬의 xlwings 라이브러리를 통해 엑셀 객체 구조에 접근해보자. 
앞서 보았던 xlwings 맛보기(링크)에서 처럼 라이브러리 약칭은 xw로 한다.

In [1]: 
import xlwings as xw

▷ 통합문서(Book) 객체 생성하기
실습을 위한 엑셀파일을 작업 중인 폴더에 내려받도록 하자(다운로드). 파일을 열어보면 아래와 같이 2개의 시트로 구성돼있다. 
두번째 시트(Sheet2)는 내용이 없는 시트이다.

xlwings_excel2
주식_종목_리스트.xlsx
xw.Book 함수에 엑셀파일의 경로를 인수로 입력하면 해당 통합문서(Book) 객체에 대응하는 파이썬 객체가 생성된다. 
파이썬에서 생성한 Book 객체를 통해 실제 엑셀의 Book 객체에 데이터(속성)나 기능(메서드)을 요청할 수 있게 된다. 
Book 객체의 name 속성은 해당 파일명을 문자열로 반환한다.

In [2]:
bk = xw.Book('주식_종목_리스트.xlsx')
bk.name
Out [2]:
'주식_종목_리스트.xlsx'

파이썬에서 Book 객체를 생성할 때, 실제 엑셀 프로그램에서도 파일이 열리는 것을 확인할 수 있다.
엑셀 프로그램이 닫혀 있었다면 프로그램이 먼저 실행된다.

Book 객체의 sheets 속성은 해당 파일에 담긴 모든 시트들의 모음인 Sheets 객체를 반환한다.
 Sheets 객체의 count 속성은 전체 시트의 개수를 반환한다.

In [3]:
bk.sheets.count
Out [3]:
2

▷ 시트(Sheet) 객체 생성하기
개별 엑셀시트(Sheet) 객체를 생성하는 방법은 2가지가 있다. 
앞에서 설명한 시트 모음(Sheets) 객체에서 시트의 순번이나 이름을 인수로 입력하면 Sheet 객체가 생성된다.
Sheet 객체의 name 속성은 해당 시트명을 문자열로 반환한다.

In [4]:
sh1 = bk.sheets(1)         # 또는 bk.sheets('Sheet1')
sh2 = bk.sheets('Sheet2')  # 또는 bk.sheets(2) 
sh1.name
Out [4]:
'종목리스트'

특정 시트를 지우려면 해당 Sheet 객체의 delete 메서드를 사용하면 된다.
아래의 코드를 실행하면 실제 엑셀 화면에서 두번째 시트가 삭제되는 것을 확인할 수 있다.

In [5]:
sh2.delete()

▷ Range 객체
엑셀시트 내에 값과 서식이 저장되는 공간을 셀(Cell)이라 하고, 여러개의 셀을 모든 것을 범위(Range)라고 한다. 셀 또는 범위는 알파벳(열)과 숫자(행)로 이뤄진 주소를 갖는다. 예를 들어 A열 1행에서 C열 5행까지의 범위에 해당하는 주소는 ‘A1:C5’가 된다.

앞에서 생성한 Sheet 객체를 특정 주소값으로 인덱싱하면, 해당 범위에 대한 Range 객체가 생성된다. Range 객체의 ‘value’ 속성은 해당 셀 또는 범위에 담겨있는 값들을 반환한다.

In [6]:
a=sh1['A1'].value
b=sh1['C2'].value
c=sh1['A1:A4'].value
d=sh1['A1:B2'].value

print(a, type(a))
print(b, type(b))
print(c)
print(d)
Out [6]:
종목코드 <class 'str'>
82600.0 <class 'float'>
['종목코드', 'A005930', 'A051910', 'A035420']
[['종목코드', '종목명'], ['A005930', '삼성전자']]
개별 셀의 값을 호출하면 문자열(str)이나 실수(float) 자료형이 반환된다. 2개 이상 셀로 이뤄진 범위의 값을 호출하면 리스트 또는 ‘리스트 of 리스트’ 형태로 반환된다.

다음 포스팅에서는 Range 객체를 활용해 엑셀파일에 담긴 자료를 판다스 데이터프레임(DataFrame)으로 변환하는 방법을 살펴보도록 하겠다.



UI 파일을 파이썬 코드로 변환하기


https://dojang.io/mod/page/view.php?id=2387
https://jimmy-ai.tistory.com/79
https://rednooby.tistory.com/56
https://dojang.io/mod/page/view.php?id=2386
메서드 오버라이딩

Qtableview

[Python] 파이썬 파일(디렉토리)처리 총정리 : 경로 확인, 경로 변경, 파일이름 변경

https://zbaekhk.blogspot.com/2021/02/pyqt5-qtableview-frozen-columns.html
[PyQt5] QTable View 틀 고정

https://wikidocs.net/4237
파이썬으로 배우는 알고리듬 트레~
PyQt 기초 - 위젯과 윈도우 / 이벤트 처리

Python 완전정복 시리즈
https://wikidocs.net/21940
ComboBox

https://bigdaheta.tistory.com/42
Pandas loc, iloc

https://wikidocs.net/154050
drop
DataFrame.drop(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise')

https://workingwithpython.com/howtohandlemissingvaluewithpython/
https://cosmosproject.tistory.com/308
Pandas 결측치 다루기


class Form(QMainWindow, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)

        self.actionOpen_2.triggered.connect(self.open_file)
          ......

        self.df = pd.DataFrame()
          ......   


   def open_file(self):
         ......

   def make_tableLib(self, df):
        ......

   def filter_fir(self, txt):
        ......

   def filter_sec(self, txt):
        ......
   def filter_thr(self, txt):
        ......
   def apply_lib(self):
        ......
   def draw_graph(self):  sub
        ......
   def make_excel(self):  sub
        ......
   def my_exception_hook(exctype, value, traceback, self=None):  
 
   # Back up the reference to the exceptionhook
   sys._excepthook = sys.excepthook

   # Set the exception hook to our wrapping function
   sys.excepthook = my_exception_hook

if __name__ == '__main__':
    app = QApplication(sys.argv)
    w = Form()
    w.show()
    sys.exit(app.exec_())

■ def open_file(self):

import os
os.chdir("P:\개인자료")
os.listdir()

import pandas as pd


import pandas as pd
book = pd.read_excel('주식 종목 리스트.xlsx')


★ ▶ 파이썬을 활용한 업무 자동화
3. Pandas로 데이터 다루기 https://wikidocs.net/150892
4. 엑셀파일 다루기 https://wikidocs.net/151077


★ 사무직을 위한 파이썬 - 문과 출신 최과장의 직장인 코딩 노하우

▶ 판다스(Pandas) - 엑셀(Excel)
https://maeng-gun.github.io/excel/excel1/

1. 판다스 시작하기 https://maeng-gun.github.io/pandas
1) 엑셀 보다 파이썬! 판다스를 배워보자Permalink
2) 판다스의 자료 구조(1) - 데이터의 유형Permalink
3) 판다스의 자료 구조(2) - 시리즈(Series)Permalink
4) 판다스의 자료 구조(3) - 데이터프레임(DataFrame)Permalink

2. 엑셀 자동화 https://maeng-gun.github.io/excel
1. 엑셀 자동화 시작하기
1) 사내망 엑셀파일에 걸린 자물쇠를 뚫고 코딩하기
2) 자동화를 위한 엑셀 객체 구조 파악하기
3) xlwings의 Book, Sheet, Range 객체 다루기
4) DRM 걸린 엑셀 파일을 판다스 데이터프레임으로 불러오기


■ WorkingWithPython https://workingwithpython.com/
1. pandas로 결측치 다루기 https://workingwithpython.com/howtohandlemissingvaluewithpython/
2. 파이썬(python) 시각화 Matplotlib 기초 (1)  https://workingwithpython.com/matplotlibbasics/
2. 파이썬(python) 시각화 Matplotlib 기초 (2)  https://workingwithpython.com/matplotlibbasics2/
엑셀로 수행하는 데이터가공, 연산, 분석 등 대부분의 업무들은 판다스 라이브러리로 작업이 가능하다. 하지만 최종 결과물은 결국 회사에서 통용되는 엑셀 보고서 양식으로 만들어내야 한다. 고정된 양식에 주기적으로 반복되는 작업이라면 xlwings 라이브러리 활용도가 높아진다. 엑셀파일을 열어서 기초자료들을 데이터프레임 형태로 불러오고, 판다스로 작업한 결과들을 다시 정해진 엑셀 양식에 붙여넣는 작업을 자동화 할 수 있다. 작업 결과에 따라 보고서의 양식이 매번 바뀌어야 하는 경우에도, 일정한 규칙이 있다면 적절한 코딩을 통해 수작업을 최소화 할 수 있다.

xlwings 맛보기Permalink
위에서 언급한 엑셀 자동화의 사례들을 맛보기로 미리 살펴보도록 하자. xlwings 라이브러리 역시 판다스와 마찬가지로 아나콘다(Anaconda)에 기본으로 포함돼있다. 임포트 할때는 보통 xw라는 별칭을 쓴다.

1) 엑셀파일 열기Permalink
서두에서 사용했던 ‘주식 종목 리스트’ 엑셀파일을 열어보자. 주피터 노트북에서 아래의 코드를 실행하면, 갑자기 엑셀프로그램이 알아서 켜지면서 해당 파일이 화면에 나타난다!

In [3]:
import xlwings as xw
book = xw.Book('주식 종목 리스트.xlsx')
엑셀파일 열기
윈도우 바탕화면 상에 엑셀 프로그램이 자동으로 켜진 모습
2) 데이터프레임으로 읽어오기Permalink
엑셀파일 내의 표를 판다스 데이터프레임 형식으로 불러오자. 판다스의 read_excel 함수를 쓸 때와는 달리 전혀 오류가 나지 않는다!
(물론 DRM이 안걸린 보통의 엑셀파일은 판다스로도 잘 열린다)

In [4]:
import pandas as pd

df = book.sheets(1).used_range.options(pd.DataFrame).value
df
Out [4]:
이름	주가(원)	시가총액(백만원)	섹터
종목코드				
A005930	삼성전자	82600.0	493104039.0	전기전자
A051910	LG화학	941000.0	66427395.0	화학
A035420	NAVER	398000.0	65376831.0	IT
A005380	현대차	242000.0	51707701.0	자동차
A035720	카카오	504000.0	44689512.0	IT
A068270	셀트리온	318500.0	43858542.0	바이오
3) 가공된 자료를 엑셀파일에 붙여넣기Permalink
판다스 명령어를 활용해 시가총액의 단위를 백만원에서 억원으로 바꾼 후, 엑셀파일에 그대로 붙여넣어보자. 실행되고 있는 엑셀프로그램 상의 표가 바뀐 것을 확인할 수 있다

In [5]:
df['시가총액(억원)'] = df['시가총액(백만원)'] /100
df = df.drop('시가총액(백만원)',axis=1)
df
Out [5]:
이름	주가(원)	섹터	시가총액(억원)
종목코드				
A005930	삼성전자	82600.0	전기전자	4931040.39
A051910	LG화학	941000.0	화학	664273.95
A035420	NAVER	398000.0	IT	653768.31
A005380	현대차	242000.0	자동차	517077.01
A035720	카카오	504000.0	IT	446895.12
A068270	셀트리온	318500.0	바이오	438585.42
In [6]:
book.sheets(1)['A1'].value = df
엑셀파일 열기
활성화되어 있는 엑셀 파일이 자동으로 바뀌었다


ValueError: File is not a recognized excel file
사내망에서 생산된 파일에 문서보안(DRM)을 적용
보안이 걸린 파일을 탐색기에서 찾아보면 위와 같이 자물쇠가 달려있다. 
사내 PC에 깔린 엑셀프로그램을 통해서만 해당 파일을 열 수 있도록 되어 있어, 파이썬의 접근이 막혀버린 것이다.
판다스나 openpyxl에서는 엑셀파일에 기록된 내용을 직접 긁어오는 방식을 쓰기 때문에 무조건 문서보안에 막힌다.
→
xlwings 라는 파이썬 라이브러리는 액셀파일이 아니라 엑셀프로그램 자체를 직접 제어
 xlwings 라이브러리 역시 판다스와 마찬가지로 아나콘다(Anaconda)에 기본으로 포함돼있다. 임포트 할때는 보통 xw라는 별칭을 쓴다.


import openpyxl as opx
book = opx.load_workbook('주식 종목 리스트.xlsx')
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bk2 = xw.Book('Dc-bias_library_V2.xlsx')

df = book.sheets(1).used_range.options(pd.DataFrame).value
df = pd.DataFrame(df.iloc[1:, :21].dropna(axis = 0, how = 'all').values, columns = df.iloc[0, :21].values)

vol_lev = [x[7] for x in df2["기종"]]
df2.insert(len(df2.columns), 'vol_lev', vol_lev)
df2.insert(len(df2.columns), '전압 (Vdc)', 0)

mat = list(set(df2["조성"]))
mat = [x for x in mat if pd.isnull(x) == False]
mat.sort()
(self.cboPow.addItems(mat))

lib = pd.DataFrame(df2, columns = ["조성","유전율", "vol_lev", "DC-Bias 측정", '전압 (Vdc)', 'sheet 두께', 'DF', '주파수(kHz)', 'AC(V)', '전압유지시간', 'Aging 시간'])
lib["유전율"] = [int(x) if x != '사이즈 없음' else x for x in lib['유전율']]

show = lib.drop(['vol_lev', '전압 (Vdc)', 'DF','주파수(kHz)', 'AC(V)', '전압유지시간', 'Aging 시간'], axis=1)

self.make_tableLib(show)

▶   def make_tableLib(self, df):

        model = pandasModel(df)
        self.tableLib.setModel(model)
        self.tableLib.resizeColumnsToContents()
        self.tableLib.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableLib.verticalHeader().setSectionResizeMode(QHeaderView.Stretch)




dropna function은 DataFrame에서 NaN value가 존재하는 행(row) 또는 열(column)을 제거해줍니다.
dropna의 syntax는 다음과 같습니다.
DataFrame.dropna(axis=0/1, how='any'/'all', subset=[col1, col2, ...], inplace=True/False)
dropna에 들어갈 수 있는 parameter들은 더 많지만 일단 대표적인 것들만 보겠습니다.

axis = 0/1 or 'index'/'columns'
0 or 'index' -> NaN 값이 포함된 row를 drop (default 값입니다.)
1 or 'columns' -> NaN 값이 포함된 column을 drop

how = 'any'/'all'
any -> row 또는 column에 NaN값이 1개만 있어도 drop (default 값입니다.)
all -> row 또는 column에 있는 모든 값이 NaN이어야 drop

inplace = True/False
True -> dropna가 적용된 DataFrame 자체에 dropna를 적용
False -> dropna가 적용된 DataFrame는 그대로 두고 dropna를 적용한 DataFrame을 return

subset = [col1, col2, ...]
subset을 명시하지 않으면 DataFrame 전체(모든 column & 모든 row)에 대해 dropna를 진행
subset을 명시하면 subset에 적힌 column값에 대해서만 dropna를 진행

먼저 test용 DataFrame을 만듭시다.

 

import pandas as pd
import numpy as np

dict_test = {
    'col1': [1, 2, 3, 4, 5],
    'col2': ['a', 'b', np.nan, 'd', 'e'],
    'col3': [np.nan, 1, 2, 3, 4]
}

df_test = pd.DataFrame(dict_test)
print(df_test)

-- Result
   col1 col2  col3
0     1    a   NaN
1     2    b   1.0
2     3  NaN   2.0
3     4    d   3.0
4     5    e   4.0
 
import pandas as pd
import numpy as np

dict_test = {
    'col1': [1, 2, 3, 4, 5],
    'col2': ['a', 'b', np.nan, 'd', 'e'],
    'col3': [np.nan, 1, 2, 3, 4]
}

df_test = pd.DataFrame(dict_test)
print(df_test)

df_result = df_test.dropna(axis=0, inplace=False)
print(df_result)

df_result = df_test.dropna(axis='index', inplace=False)
print(df_result)


-- Result
   col1 col2  col3
0     1    a   NaN
1     2    b   1.0
2     3  NaN   2.0
3     4    d   3.0
4     5    e   4.0

   col1 col2  col3
1     2    b   1.0
3     4    d   3.0
4     5    e   4.0

   col1 col2  col3
1     2    b   1.0
3     4    d   3.0
4     5    e   4.0
 
위 예시는 axis = 0 or 'index'로 설정된 경우의 예시입니다.
DataFrame의 index = 0, index = 2인 row에 NaN값이 1개씩 포함되어있죠.
따라서 index = 0, index = 2인 row가 삭제되고 그 외의 row들만 return되었습니다.

import pandas as pd
import numpy as np

dict_test = {
    'col1': [1, 2, 3, 4, 5],
    'col2': ['a', 'b', np.nan, 'd', 'e'],
    'col3': [np.nan, 1, 2, 3, 4]
}

df_test = pd.DataFrame(dict_test)
print(df_test)

df_result = df_test.dropna(axis=1, inplace=False)
print(df_result)

df_result = df_test.dropna(axis='columns', inplace=False)
print(df_result)


-- Result
   col1 col2  col3
0     1    a   NaN
1     2    b   1.0
2     3  NaN   2.0
3     4    d   3.0
4     5    e   4.0

   col1
0     1
1     2
2     3
3     4
4     5

   col1
0     1
1     2
2     3
3     4
4     5
 
위 예시는 axis = 1 or 'columns'로 설정된 경우의 예시입니다.
col2, col3에 NaN값이 1개씩 포함되어있으니 col2, col3가 모두 drop되고 결과에는 col1만 남아있죠.

import pandas as pd
import numpy as np

dict_test = {
    'col1': [1, np.nan, 3, 4, 5],
    'col2': [np.nan, np.nan, np.nan, np.nan,np.nan],
    'col3': [0, np.nan, 2, 3, 4]
}

df_test = pd.DataFrame(dict_test)
print(df_test)

df_result = df_test.dropna(axis=0, how='all', inplace=False)
print(df_result)

-- Result
   col1  col2  col3
0   1.0   NaN   0.0
1   NaN   NaN   NaN
2   3.0   NaN   2.0
3   4.0   NaN   3.0
4   5.0   NaN   4.0

   col1  col2  col3
0   1.0   NaN   0.0
2   3.0   NaN   2.0
3   4.0   NaN   3.0
4   5.0   NaN   4.0
 

위 예시의 dropna를 해석해보면 다음과 같습니다.
axis = 0 -> NaN값이 있는 row를 drop함
how = 'all' -> row 전체가 NaN값이어야만 drop함.

따라서 모든 값이 NaN인 index = 1인 row만 drop되고
나머지 row는 그대로 return되었습니다.

import pandas as pd
import numpy as np

dict_test = {
    'col1': [1, np.nan, 3, 4, 5],
    'col2': [np.nan, np.nan, np.nan, np.nan,np.nan],
    'col3': [0, np.nan, 2, 3, 4]
}

df_test = pd.DataFrame(dict_test)
print(df_test)

df_result = df_test.dropna(axis=1, how='all', inplace=False)
print(df_result)

-- Result
   col1  col2  col3
0   1.0   NaN   0.0
1   NaN   NaN   NaN
2   3.0   NaN   2.0
3   4.0   NaN   3.0
4   5.0   NaN   4.0

   col1  col3
0   1.0   0.0
1   NaN   NaN
2   3.0   2.0
3   4.0   3.0
4   5.0   4.0
 
위 예시의 dropna를 해석해보면 다음과 같습니다.
axis = 1 -> NaN값이 있는 column을 drop함
how = 'all' -> column 전체가 NaN값이어야만 drop함.

따라서 모든 값이 NaN인 col2만 drop되고
나머지 column은 그대로 return되었습니다.

import pandas as pd
import numpy as np

dict_test = {
    'col1': [1, 2, 3, 4, 5],
    'col2': ['a', 'b', np.nan, 'd', 'e'],
    'col3': [np.nan, 1, 2, 3, 4]
}

df_test = pd.DataFrame(dict_test)
print(df_test)

df_result = df_test.dropna(axis=0, subset=['col1', 'col2'], inplace=False)
print(df_result)

-- Result
   col1 col2  col3
0     1    a   NaN
1     2    b   1.0
2     3  NaN   2.0
3     4    d   3.0
4     5    e   4.0

   col1 col2  col3
0     1    a   NaN
1     2    b   1.0
3     4    d   3.0
4     5    e   4.0

위 예시는 subset에 col1, col2를 명시하였고,
따라서 col1, col2에서만 dropna를 진행합니다.
(col3의 index = 0에 NaN값이 있는데 index=0인 row는 drop되지 않았습니다.)

▶ 판다스 - 피벗테이블
https://continuous-development.tistory.com/142


DRM 걸린 엑셀 파일을 판다스 데이터프레임으로 불러오기

 On This Page
엑셀의 표를 Series / DataFrame 객체로 변환하기
Range 객체의 형태변환 : options 메서드
Range 확장하기 : expand 매개변수

엑셀의 표를 Series / DataFrame 객체로 변환하기
지난 포스팅에서 xlwings로 생성한 Range 객체의 value 속성을 통해서 엑셀 파일에 담긴 자료들을 파이썬으로 가져오는 과정을 살펴봤다. 
이 경우 자료값들은 파이썬의 ‘리스트’ 또는 ‘리스트 of 리스트’ 형태를 취하게 된다. 
이를 판다스의 시리즈나 데이터프레임 객체로 변환하려면, 인덱스와 컬럼명을 별도로 지정해줘야 하는 불편함이 있다.
다행히 xlwings에서는 Range 객체를 곧바로 시리즈/데이터프레임으로 변환하는 기능이 존재한다.

Range 객체의 형태변환 : options 메서드
이전 포스팅에서의 실습을 이어나가보자. 먼저, 첫번째 시트(sh1)에 종목코드와 종목명이 있는 범위(A1:B7)를 다음과 같은 방법을 통해 딕셔너리 자료형으로 변환할 수 있다.

In [7]:
dtn = sh1['A2:B7'].options(dict).value
dtn
Out [7]:
{'A005930': '삼성전자',
 'A051910': 'LG화학',
 'A035420': 'NAVER',
 'A005380': '현대차',
 'A035720': '카카오',
 'A068270': '셀트리온'}

위와 같이 엑셀의 특정 범위를 Range 객체로 만든 다음, .options(자료형이름).value를 붙여주면 지정한 자료형에 따라 값을 반환한다. 
자료형 이름으로 dict를 입력하면 해당 범위의 첫번째 열을 키(key), 나머지 열을 값(value)으로 갖는 딕셔너리를 반환한다. (이미 확인했듯이 options 메서드를 거치지 않고 바로 .value를 붙이면 리스트 자료형으로 반환된다.)

판다스의 시리즈/데이터프레임 객체로 변환하는 것도 같은 방법으로 가능하다. 먼저 판다스 라이브러리를 import 하고(약칭 pd), 자료형 이름에 pd.Series(1차원 자료) 또는 pd.DataFrame(2차원 자료)을 입력하면 된다.

In [8]:
import pandas as pd
sr = sh1['A1:B7'].options(pd.Series).value
sr
Out [8]:
종목코드
A005930     삼성전자
A051910     LG화학
A035420    NAVER
A005380      현대차
A035720      카카오
A068270     셀트리온
Name: 종목명, dtype: object
In [9]:
df = sh1['A1:E7'].options(pd.DataFrame).value
df
Out [9]:
종목명	주가(원)	시가총액(백만원)	섹터
종목코드				
A005930	삼성전자	82600.0	493104039.0	전기전자
A051910	LG화학	941000.0	66427395.0	화학
A035420	NAVER	398000.0	65376831.0	IT
A005380	현대차	242000.0	51707701.0	자동차
A035720	카카오	504000.0	44689512.0	IT
A068270	셀트리온	318500.0	43858542.0	바이오
엑셀 범위에서 기본적으로 첫번째 열이 인덱스(index), 첫번째 행이 컬럼명(columns)으로 지정된다.

Range 확장하기 : expand 매개변수Permalink
다음과 같은 상황을 가정해보자. 당신은 매일 사내 업무시스템의 특정 화면에서 자료를 내려받아서 일일 보고를 위한 데이터 산출 작업을 하고 있다. 지금까지 실습했던 주식_종목_리스트.xlsx 파일과 컬럼명은 동일하지만, 아래 그림과 같이 매일 종목의 종류와 수만 바뀐다고 하자.

xlwings_expand1	xlwings_expand2
1일차 자료(다운로드)	2일차 자료(다운로드)
xlwings_expand3	xlwings_expand4
3일차 자료(다운로드)	4일차 자료(다운로드)
위에서 실습했던 내용을 아래와 같이 함수로 만들어 호출해보자.

In [10]:
def automate_excel(file_name):
    bk = xw.Book(file_name)
    sh = bk.sheets(1)
    df = sh['A1:E7'].options(pd.DataFrame).value
    return df

df_auto = automate_excel('주식_종목_리스트2.xlsx')
df_auto
Out [10]:
종목명	주가(원)	시가총액(백만원)	섹터
종목코드				
A000270	기아	85500.0	34658566.0	경기소비재
A036570	엔씨소프트	885000.0	19429309.0	IT
A032830	삼성생명	78000.0	15600000.0	금융
NaN	None	NaN	NaN	None
NaN	None	NaN	NaN	None
NaN	None	NaN	NaN	None
엑셀파일명을 인수로 입력하면 A1:E7 범위 내의 표를 데이터프레임 객체로 변환해주는 함수다. 문제는 2일차부터는 표의 범위가 계속 달라지기 때문에 저대로는 함수를 사용할 수가 없다는 것이다.

여기서 options 메서드의 expand 매개변수를 활용하면 매일 변동하는 표의 범위를 자동으로 인식할 수 있다. expand의 인수로는 ‘down’, ‘right’, ‘table’이 들어갈 수 있다. 이는 미리 설정된 Range 객체의 범위를 아래쪽(‘down’) 또는 오른쪽(‘right’), 혹은 양쪽 모두(‘table’)로 확장하는 기능이다. 아래의 예시 코드에서 df1 ~ df4 는 모두 같은 표를 가리킨다.

In [11]:
df1 = sh1['A1:E7'].options(pd.DataFrame).value
df2 = sh1['A1:E1'].options(pd.DataFrame, expand='down')
df3 = sh1['A1:A7'].options(pd.DataFrame, expand='right')
df4 = sh1['A1'].options(pd.DataFrame, expand='table')
두번째 줄의 코드를 해석해보면, 1) 엑셀 상에서 A1:E1에 해당하는 범위를 선택하고 2) Ctrl + Shift + 방향키 ↓를 눌러서 선택 범위를 확장한 다음 3) 확장된 범위 내의 자료값을 데이터프레임으로 불러온다는 의미다. 세번째 줄은 방향키 →, 네번째 줄은 방향키 ↓ 과 방향키 →를 연속으로 누른 경우라고 보면 된다.

앞에서 매일 컬럼명은 동일하나 종목의 종류와 수만 바뀐다고 가정했으므로, 자동화 함수를 다음과 같이 수정하면 어떤 날짜에도 사용가능하게 된다.

In [12]:
def automate_excel(file_name):
    bk = xw.Book(file_name)
    sh = bk.sheets(1)
    df = sh['A1'].options(pd.DataFrame, expand='table').value
    # 또는 sh['A1:E1'].options(pd.DataFrame, expand='down').value
    return df

df_auto = automate_excel('주식_종목_리스트.xlsx')
df_auto2 = automate_excel('주식_종목_리스트2.xlsx')
df_auto3 = automate_excel('주식_종목_리스트3.xlsx')
df_auto4 = automate_excel('주식_종목_리스트4.xlsx')
다음편 : DRM 걸린 엑셀파일에 새로운 내용을 자동으로 입력하기

엑셀자동화 카테고리 목록 바로가기



=================================================================
2) PyQt 복습하기
이번 절에서는 12.2절에서 설명한 PyQt 기초를 복습하겠습니다. PyQt가 잘 기억나지 않는다면 잠깐 12.2절을 먼저 읽어보기 바랍니다.

PyQt는 따로 한 권 분량의 책이 있을 만큼 복잡하고 규모가 큰 라이브러리입니다. 따라서 이 책에서 PyQt를 모두 다룰 수는 없습니다. 대신 알고리즘 트레이딩 프로그램 UI를 만들 수 있을 만큼만 공부하겠습니다.

PyQt는 분명히 복잡한 라이브러리이긴 하지만 PyQt 기반의 GUI 프로그램의 핵심 구성 요소는 그림 16.4와 같이 정리할 수 있습니다. 먼저 화면에 출력되는 UI 부분이 있습니다. 이는 PyQt가 기본적으로 제공하는 위젯(Widget) 클래스의 객체를 생성해서 만들 수 있습니다. 수많은 위젯 중에서 여러분이 사용할 위젯을 선택하고 각 위젯 클래스의 사용법을 익혀야 합니다.

두 번째는 이벤트 루프입니다. PyQt에서는 QApplication 객체에서 exec_ 메서드를 호출해 이벤트 루프를 생성합니다. 여러분은 이벤트 루프를 생성만 할 뿐 실제로 이벤트 루프에서 여러분이 관여하는 일은 많지 않습니다.

세 번째는 이벤트를 처리할 함수 또는 메서드를 구현하는 부분입니다. 버튼과 같은 위젯을 클릭하면 해당 위젯은 'clicked'라는 시그널(signal)을 발생시킵니다. 여러분은 'clicked'라는 시그널이 발생했을 때 호출되는 함수 또는 메서드를 구현해야 합니다. PyQt에서는 특정 시그널이 발생했을 때 호출되는 함수 또는 메서드를 슬롯(slot)이라고 합니다. 참고로 다른 프로그래밍 언어에서는 콜백 함수(callback function)라고 부르기도 합니다.

PyQt에서는 위젯에서 발생하는 시그널에 대해 어떤 슬롯으로 처리할지에 대해 미리 등록함으로써 특정 위젯에서 시그널이 발생했을 때 이벤트 루프가 미리 연결된 슬롯을 자동으로 호출하게 돼 있습니다.

GUI 프로그램의 전반적인 실행 흐름에 대해 정리해 보겠습니다. 그림 16.4에서 사용자가 버튼 위젯을 클릭하면 'clicked'라는 시그널이 발생합니다. GUI 프로그램의 시작과 함께 생성돼 있던 이벤트 루프는 해당 시그널에 등록된 슬롯을 호출함으로써 사용자가 발생시킨 이벤트를 처리합니다. 이벤트 루프는 사용자가 프로그램을 종료한다는 시그널을 보내기 전까지는 계속해서 이와 같은 방식으로 시그널과 연결된 슬롯을 호출함으로써 이벤트를 처리하는 역할을 합니다.



그림 16.4 PyQt의 UI-시그널-슬롯-이벤트 루프의 관계

PyQt의 전반적인 동작 방식을 복습했으니, 이번에는 간단한 코드를 통해 이벤트 루프를 생성하는 QApplication 객체를 살펴보겠습니다. 앞서 설명한 것처럼 그림 16.4의 이벤트 루프는 QApplication 클래스의 객체를 생성한 후 exec_ 메서드를 호출하는 순간 생성됩니다.

한번 생성된 이벤트 루프는 사용자가 윈도우를 닫을 때까지 실행되면서 위젯에서 발생한 시그널을 처리하는 슬롯을 호출하는 역할을 합니다. 이벤트 루프의 생성과 종료 시점을 확인해보기 위해 다음과 같이 코드를 작성해 보겠습니다.

import sys
from PyQt5.QtWidgets import *

app = QApplication(sys.argv)
label = QLabel("Hello, PyQt")
label.show()

print("Before event loop")
app.exec_()
print("After event loop")
작성된 코드에서는 이벤트 루프를 생성하는 코드의 앞쪽과 뒤쪽에 문자열이 출력되게 했습니다. 코드를 실행하면 그림 16.5와 같이 QLabel 위젯이 나타나고 콘솔 창에는 'Before event loop'라는 문자열이 출력됩니다.

여기서 한 가지 중요한 점은 파이썬 코드는 파일의 위에서부터 아래쪽으로 순차적으로 실행되는데 app.exec_ 앞쪽의 코드는 실행됐지만 그다음 줄의 코드는 아직 실행되지 않았다는 점입니다. 이는 exec_ 메서드가 호출되면서 이벤트 루프가 생성됐고 이 때문에 프로그램이 계속해서 이벤트 루프 안에서 실행되고 있기 때문입니다.



그림 16.5 이벤트 루프 생성(소스 코드: book/ch16/01.py)

이제 화면에 출력된 QLabel 위젯을 닫아 보겠습니다. 윈도우의 'X' 부분을 눌러 QLabel 위젯을 종료하면 exec_ 메서드 호출 시점에 생성됐던 이벤트 루프가 종료되면서 그다음 줄의 코드가 실행됩니다. 따라서 그림 16.6과 같이 콘솔 창에 'After event loop'라는 문자열이 출력됨을 확인할 수 있습니다.



그림 16.6 이벤트 루프 종료



이번에는 시그널과 슬롯을 연결하는 부분에 대한 코드를 작성해 보겠습니다. PyQt는 위젯의 종류에 따라 발생 가능한 기본 시그널이 정의돼 있습니다. 예를 들어, QPushButton 위젯은 마우스 클릭을 했을 때 'clicked'라는 시그널이 발생합니다.

시그널이 발생했을 때 호출되는 함수 또는 메서드를 슬롯이라 부른다고 했습니다. 슬롯을 구현했다면 시그널과 슬롯을 연결만 해주면 됩니다. 시그널이 발생했을 때 연결된 슬롯을 호출하는 역할은 앞서 살펴본 이벤트 루프가 알아서 처리해줍니다.

다음 코드에서는 QPushButton 위젯을 생성하고 해당 위젯에서 'clicked' 시그널이 발생하면 호출되는 슬롯인 clicked_slot 함수를 구현했고 시그널과 슬롯을 이벤트 루프를 생성하기 전에 미리 연결했습니다.

import sys
from PyQt5.QtWidgets import *

def clicked_slot():
    print('clicked')

app = QApplication(sys.argv)

btn = QPushButton("Hello, PyQt")
btn.clicked.connect(clicked_slot)
btn.show()

app.exec_()
위 코드를 실행해 보면 그림 16.7과 같이 QPushButton 객체가 화면에 출력됩니다. 버튼을 클릭하면 콘솔 창에 'clicked'라는 문자열이 출력됨을 확인할 수 있습니다. 이는 QPushButton 위젯에서 'clicked' 이벤트가 발생하면 'clicked_slot'이라는 이름의 함수가 호출되도록 미리 연결해 뒀기 때문입니다.

여기서 한 가지 주의할 점은 슬롯의 구현과 시그널-슬롯의 연결이 모두 이벤트 루프를 생성하는 app.exec_ 메서드 호출보다 먼저 수행돼야 한다는 점입니다.



그림 16.7 간단한 시그널-슬롯 연결의 예

지금까지 이벤트 루프 생성과 시그널-슬롯의 연결에 대해 복습했습니다. 이번에는 위젯을 이용해 UI를 구성하는 부분에 대해 복습하겠습니다. 이번에 구현할 프로그램은 그림 16.8과 같습니다.



그림 16.8 윈도우 및 이벤트 처리

PyQt에서 위젯은 UI를 구성하는 핵심 요소입니다. PyQt에서는 모든 위젯이 최상위 위젯을 의미하는 윈도우가 될 수 있습니다. 그러나 대부분의 프로그램에서는 QMainWindow나 QDialog 클래스를 사용해 윈도우를 생성합니다.

import sys
from PyQt5.QtWidgets import *

class MyWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setupUI()

    def setupUI(self):
        self.setWindowTitle("Review")

        btn1 = QPushButton("Click me", self)
        btn1.move(20, 20)
        btn1.clicked.connect(self.btn1_clicked)

    def btn1_clicked(self):
        QMessageBox.about(self, "message", "clicked")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    mywindow = MyWindow()
    mywindow.show()
    app.exec_()
예제 16.1 QMainWindow를 이용한 윈도우 구성(소스코드: book/ch16/03.py)

그림 16.8 프로그램의 전체 코드는 예제 16.1과 같습니다. 코드가 기존 코드에 비해 복잡해 보이지만 각 부분을 나눠서 이해하면 쉽게 파악할 수 있습니다. 가장 먼저 살펴볼 부분은 QApplication 객체를 생성하고 이벤트 루프를 만드는 부분입니다.

먼저 QApplication 객체인 app을 생성하고 exec_ 메서드를 호출해서 이벤트 루프를 생성합니다. 그리고 이벤트 루프를 생성하기 전에 MyWindow라는 클래스의 객체를 생성하는 것을 확인할 수 있습니다.

if __name__ == "__main__":
    app = QApplication(sys.argv)
    mywindow = MyWindow()
    mywindow.show()
    app.exec_()
앞서 배운 내용을 상기해보면 이벤트 루프를 생성하기 전에는 UI를 구성해야 하고 UI를 구성하는 기본 단위인 위젯에 대해 시그널과 슬롯을 연결해야 했습니다.

UI가 간단하다면 몇 줄의 코드만으로도 구현할 수 있겠지만 UI가 복잡한 경우에는 클래스를 사용하는 것이 좋습니다. 특히 클래스를 사용하면 기존 위젯 클래스를 상속함으로써 여러분만의 클래스를 새롭게 정의할 수 있습니다.

MyWindow 클래스의 객체는 이벤트 루프가 실행되기 전에 생성되며 이때 자동으로 생성자가 호출됩니다. 따라서 코드를 분석할 때는 먼저 생성자 부분부터 살펴보는 것이 좋습니다. 다음 코드를 살펴보면 MyWindow 클래스는 QMainWindow 클래스를 상속받고 있습니다.

자식 클래스인 MyWindow가 부모 클래스인 QMainWindow를 상속받으면 QMainWindow 클래스에 정의된 모든 메서드나 프로퍼티를 사용할 수 있습니다. 클래스의 상속은 우리 생활에서 보면 부모님을 잘 만나서 태어날 때부터 ‘금수저’를 물고 태어나는 것과 비슷합니다.

class MyWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setupUI()
MyWindow 클래스는 단순히 부모 클래스를 상속할 뿐만 아니라 자기 자신의 UI를 변경하는 메서드인 setupUI를 호출합니다. 물론 QPushButton과 같은 객체 생성 코드를 모두 MyWindow 클래스의 생성자에 넣을 수도 있지만, 따로 메서드로 구성해서 코드의 가독성을 좋게 합니다. 여기서 중요한 코드는 'clicked'라는 시그널과 이를 처리하는 슬롯인 self.btn1_clicked를 연결하는 코드입니다.

def setupUI(self):
    self.setWindowTitle("Review")

    btn1 = QPushButton("Click me", self)
    btn1.move(20, 20)
    btn1.clicked.connect(self.btn1_clicked)
QPushButton에서 'clicked' 시그널이 발생할 때 자동으로 호출되는 슬롯인 self.btn1_clicked는 다음과 같이 MyWindow 클래스의 메서드로 구현합니다.

def btn1_clicked(self):
    QMessageBox.about(self, "message", "clicked")




QcomboBox메소드
https://doc.qt.io/qtforpython-5/PySide2/QtWidgets/QComboBox.html
출처: https://nan-sso-gong.tistory.com/26 [스물, 그리고 스물다섯:티스토리]

아나콘다에서 PyQt 설치 및 업데이트
https://wikidocs.net/5220

초보자를 위한 Python GUI 프로그래밍 - PyQt5

Python 3.8.8 64-bit | Qt 5.9.7 | PyQt5 5.9.2 | Windows 10 

Package                            Version
---------------------------------- -------------------
alabaster                          0.7.12
anaconda-client                    1.7.2
anaconda-navigator                 2.0.3
anaconda-project                   0.9.1
anyio                              2.2.0
appdirs                            1.4.4
argh                               0.26.2
argon2-cffi                        20.1.0
asn1crypto                         1.4.0
astroid                            2.5
astropy                            4.2.1
async-generator                    1.10
atomicwrites                       1.4.0
attrs                              20.3.0
autopep8                           1.5.6
Babel                              2.9.0
backcall                           0.2.0
backports.functools-lru-cache      1.6.4
backports.shutil-get-terminal-size 1.0.0
backports.tempfile                 1.0
backports.weakref                  1.0.post1
bcrypt                             3.2.0
beautifulsoup4                     4.9.3
bitarray                           1.9.2
bkcharts                           0.2
black                              19.10b0
bleach                             3.3.0
bokeh                              2.3.2
boto                               2.49.0
Bottleneck                         1.3.2
brotlipy                           0.7.0
certifi                            2020.12.5
cffi                               1.14.5
chardet                            4.0.0
click                              7.1.2
cloudpickle                        1.6.0
clyent                             1.2.2
colorama                           0.4.4
comtypes                           1.1.9
conda                              4.10.3
conda-build                        3.21.4
conda-content-trust                0+unknown
conda-package-handling             1.7.3
conda-repo-cli                     1.0.4
conda-token                        0.3.0
conda-verify                       3.4.2
contextlib2                        0.6.0.post1
cryptography                       3.4.7
cycler                             0.10.0
Cython                             0.29.23
cytoolz                            0.11.0
dask                               2021.4.0
decorator                          5.0.6
defusedxml                         0.7.1
diff-match-patch                   20200713
distributed                        2021.4.0
docutils                           0.17
entrypoints                        0.3
et-xmlfile                         1.0.1
fastcache                          1.1.0
filelock                           3.0.12
flake8                             3.9.0
Flask                              1.1.2
fsspec                             0.9.0
future                             0.18.2
gevent                             21.1.2
glob2                              0.7
greenlet                           1.0.0
h5py                               2.10.0
HeapDict                           1.0.1
html5lib                           1.1
idna                               2.10
imagecodecs                        2021.3.31
imageio                            2.9.0
imagesize                          1.2.0
importlib-metadata                 3.10.0
iniconfig                          1.1.1
intervaltree                       3.1.0
ipykernel                          5.3.4
ipython                            7.22.0
ipython-genutils                   0.2.0
ipywidgets                         7.6.3
isort                              5.8.0
itsdangerous                       1.1.0
jdcal                              1.4.1
jedi                               0.17.2
Jinja2                             2.11.3
joblib                             1.0.1
json5                              0.9.5
jsonschema                         3.2.0
jupyter                            1.0.0
jupyter-client                     6.1.12
jupyter-console                    6.4.0
jupyter-core                       4.7.1
jupyter-packaging                  0.7.12
jupyter-server                     1.4.1
jupyterlab                         3.0.14
jupyterlab-pygments                0.1.2
jupyterlab-server                  2.4.0
jupyterlab-widgets                 1.0.0
keyring                            22.3.0
kiwisolver                         1.3.1
lazy-object-proxy                  1.6.0
libarchive-c                       2.9
llvmlite                           0.36.0
locket                             0.2.1
lxml                               4.6.3
MarkupSafe                         1.1.1
matplotlib                         3.3.4
mccabe                             0.6.1
menuinst                           1.4.16
mistune                            0.8.4
mkl-fft                            1.3.0
mkl-random                         1.2.1
mkl-service                        2.3.0
mock                               4.0.3
more-itertools                     8.7.0
mpmath                             1.2.1
msgpack                            1.0.2
multipledispatch                   0.6.0
mypy-extensions                    0.4.3
navigator-updater                  0.2.1
nbclassic                          0.2.6
nbclient                           0.5.3
nbconvert                          6.0.7
nbformat                           5.1.3
nest-asyncio                       1.5.1
networkx                           2.5
nltk                               3.6.1
nose                               1.3.7
notebook                           6.3.0
numba                              0.53.1
numexpr                            2.7.3
numpy                              1.20.1
numpydoc                           1.1.0
olefile                            0.46
opencv-contrib-python              4.5.3.56
openpyxl                           3.0.7
packaging                          20.9
pandas                             1.2.4
pandocfilters                      1.4.3
paramiko                           2.7.2
parso                              0.7.0
partd                              1.2.0
path                               15.1.2
pathlib2                           2.3.5
pathspec                           0.7.0
patsy                              0.5.1
pep8                               1.7.1
pexpect                            4.8.0
pickleshare                        0.7.5
Pillow                             8.2.0
pip                                21.0.1
pkginfo                            1.7.0
pluggy                             0.13.1
ply                                3.11
prometheus-client                  0.10.1
prompt-toolkit                     3.0.17
psutil                             5.8.0
ptyprocess                         0.7.0
py                                 1.10.0
pycodestyle                        2.6.0
pycosat                            0.6.3
pycparser                          2.20
pycurl                             7.43.0.6
pydocstyle                         6.0.0
pyerfa                             1.7.3
pyflakes                           2.2.0
Pygments                           2.8.1
pylint                             2.7.4
pyls-black                         0.4.6
pyls-spyder                        0.3.2
PyNaCl                             1.4.0
pyodbc                             4.0.0-unsupported
pyOpenSSL                          20.0.1
pyparsing                          2.4.7
pyreadline                         2.1
pyrsistent                         0.17.3
PySide2                            5.15.2.1
PySocks                            1.7.1
pytest                             6.2.3
python-dateutil                    2.8.1
python-jsonrpc-server              0.4.0
python-language-server             0.36.2
pytz                               2021.1
PyWavelets                         1.1.1
pywin32                            227
pywin32-ctypes                     0.2.0
pywinpty                           0.5.7
PyYAML                             5.4.1
pyzmq                              20.0.0
QDarkStyle                         2.8.1
QtAwesome                          1.0.2
qtconsole                          5.0.3
QtPy                               1.9.0
regex                              2021.4.4
requests                           2.25.1
rope                               0.18.0
Rtree                              0.9.7
ruamel-yaml-conda                  0.15.100
scikit-image                       0.18.1
scikit-learn                       0.24.1
scipy                              1.6.2
seaborn                            0.11.1
Send2Trash                         1.5.0
setuptools                         52.0.0.post20210125
shiboken2                          5.15.2.1
shiboken6                          6.3.0
simplegeneric                      0.8.1
singledispatch                     0.0.0
sip                                4.19.13
six                                1.15.0
sniffio                            1.2.0
snowballstemmer                    2.1.0
sortedcollections                  2.1.0
sortedcontainers                   2.3.0
soupsieve                          2.2.1
Sphinx                             4.0.1
sphinxcontrib-applehelp            1.0.2
sphinxcontrib-devhelp              1.0.2
sphinxcontrib-htmlhelp             1.0.3
sphinxcontrib-jsmath               1.0.1
sphinxcontrib-qthelp               1.0.3
sphinxcontrib-serializinghtml      1.1.4
sphinxcontrib-websupport           1.2.4
spyder                             4.2.5
spyder-kernels                     1.10.2
SQLAlchemy                         1.4.7
statsmodels                        0.12.2
sympy                              1.8
tables                             3.6.1
tblib                              1.7.0
terminado                          0.9.4
testpath                           0.4.4
textdistance                       4.2.1
threadpoolctl                      2.1.0
three-merge                        0.1.1
tifffile                           2021.4.8
toml                               0.10.2
toolz                              0.11.1
tornado                            6.1
tqdm                               4.59.0
traitlets                          5.0.5
typed-ast                          1.4.2
typing-extensions                  3.7.4.3
ujson                              4.0.2
unicodecsv                         0.14.1
urllib3                            1.26.4
watchdog                           1.0.2
wcwidth                            0.2.5
webencodings                       0.5.1
Werkzeug                           1.0.1
wheel                              0.36.2
widgetsnbextension                 3.5.1
win-inet-pton                      1.1.0
win-unicode-console                0.5
wincertstore                       0.2
wordcloud                          1.8.1
wrapt                              1.12.1
xlrd                               2.0.1
XlsxWriter                         1.3.8
xlwings                            0.23.0
xlwt                               1.3.0
xmltodict                          0.12.0
yapf                               0.31.0
zict                               2.0.0
zipp                               3.4.1
zope.event                         4.5.0
zope.interface                     5.3.0


python                         3.8.8      hdbf39b2_4  pkgs/main
python                         3.8.8      hdbf39b2_5  pkgs/main
python                        3.8.10      hdbf39b2_7  pkgs/main
python                        3.8.11      h6244533_1  pkgs/main
python                        3.8.12      h6244533_0  pkgs/main
python                        3.8.13      h6244533_0  pkgs/main
python                         3.9.0      h6244533_2  pkgs/main
python                         3.9.0      h8aef87e_1  pkgs/main
python                         3.9.1      h6244533_2  pkgs/main
python                         3.9.2      h6244533_0  pkgs/main
python                         3.9.4      h6244533_0  pkgs/main
python                         3.9.5      h6244533_3  pkgs/main
python                         3.9.6      h6244533_0  pkgs/main
python                         3.9.6      h6244533_1  pkgs/main
python                         3.9.7      h6244533_1  pkgs/main
python                        3.9.11      h6244533_1  pkgs/main
python                        3.9.11      h6244533_2  pkgs/main
python                        3.9.12      h6244533_0  pkgs/main
python                        3.10.0      h96c0403_3  pkgs/main
python                        3.10.0      hbb2ffb3_0  pkgs/main
python                        3.10.0      hbb2ffb3_1  pkgs/main
python                        3.10.0      hbb2ffb3_2  pkgs/main
python                        3.10.3      hbb2ffb3_5  pkgs/main
python                        3.10.4      hbb2ffb3_0  pkgs/main

=============================================================================
간단 요약
- tkinter는 정말 간단한 프로그램 만들 때 사용
- PyQt5는 예쁜 GUI를 만들고 싶을 때, GUI 디자인을 자주 바꿀 거 같을 때 사용

[Xls 화일 다루기]
[Database 활용]
[pyqt5 UI 활용]
- windows UI 구성, Input / Output 활용


프로그래밍 세계에서는 변수처럼 값을 자유롭게 변경할 수 있는 것도 중요하지만, 반대로 "값을 변경할 수 없다"는 것도 중요하다. 어디선가 마음대로 값이 갱신 된다면 문제가 발생하게 된다 ...... 
그런 중요한 값을 배열처럼 많이 이용하려면 목록으로는 곤란한다. 튜플은 값이 변하지 않는 것이 보증된 목록이다. 그렇게 생각하면, 이 튜플을 사용하는 경우가 없지 않나? 라고 생각 할 수 있을 것이다.
이런 "변경 불가능한 컨테이너"는 튜플 외에도 있다. 앞장에서 잠깐 나온 레인지(range) 등이 있다. 
이러한 변경 불가 것을 "불변 객체(immutable)"라고 한다.이에 대해 변경이 가능한 것은 "가변 객체(mutable)"라고 한다. 목록는 mutable 컨테이너의 대표라고 할 수 있다.
그럼 "튜플로 제공한 값을 나중에 목록으로 사용하고 싶다"라고 하는 경우는 어떻게 해야 하나? 이러한 경우에는 변환을 해주는 함수를 사용하면 된다. 튜플을 목록으로 변환변수 = list(튜플)
목록을 튜플로 변환변수 = tuple(목록)

그럼 아래 튜플과 리스트의 사용 예제를 보도록 하자.
tp = (0,1,2,3,4)
ls = list(tp)
for n in range(0,5):
    ls[n] = ls[n] * 2
for n in tp:
    print(ls[n])

튜플 tp를 준비해서 거기에서 목록 ls를 만들고, 목록의 값을 변경한다. 출력 결과를 보면서 ls값과 tp값이 어떻게 사용되고 있는지 생각해 보자. 
수열을 다루는 레인지시퀀스 동료의 마지막은 "레인지(range)"이다. 이것은 이전에 등장 했었다. for 등에서 숫자의 범위를 지정하는데, for n in range(10)
이런 식으로 쓰기도 했다. 이 range(10)라는 것이 레인지이다. 레인지는 다음과 같이 만든다. 알기 쉽게 예로서, 생성된 레인지에 포함되는 수열을 리스트로 표시해 두었다.
0부터 지정한 값의 직전까지의 범위변수 = range(종료 값)
예) range (10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

지정된 값부터 지정한 값의 직전까지의 범위변수 = range (시작 값, 종료 값)
예)range(10, 20)
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

지정된 값부터 지정된 값의 앞까지 일정한 간격으로 값을 얻는 범위변수 = range(시작 값, 종료 값 간격)
예)range(10, 50, 5)
[10, 15, 20, 25, 30, 35, 40, 45]

레인지는 차례를 잘 늘어놓은 수열을 만들기 위한 것이다. 이것은 물론 일반적인 용도로도 사용할 수 있지만, 가장 많이 사용하는 것은 for일 것이다. 
for문으로 반복 처리할 때, 반복 범위 지정을 위해 레인지를 사용하는 경우가 가장 많은 것이다. 그럼 아래의 목록 란에 간단한 사용 예제를 보도록 하자.

for n in range(10): 
    print(n)

range 값을 for으로 순서대로 출력하고 있다. 시퀀스 기능목록 등의 "여러 값을 한꺼번에 처리한다"라는 것은 매우 유용하지만, 그러나 처음부터 고정된 수의 요소 밖에 사용할 수 없다면 조금 융통성이 없어 보인다.하지만 염려하지 말자. 목록에는 요소를 추가하거나 제거하는 기능이 제대로 마련되어 있다.그 대부분은 "순서"에 포함되어 있는 기능이다. 즉, 리스트, 튜플, 범위 중에서도 사용할 수 있는 기능이라는 것이다. 그럼 시퀀스의 기본적인 기능에 대해 정리해 보자.새로운 요소를 추가목록.append(값)
목록의 가장 마지막에 값을 추가한다.지정된 인덱스 위치에 값을 삽입목록.insert(인덱스, 값)
목록의 지정된 인덱스 번호의 위치에 값을 삽입한다.지정된 값을 제거목록.remove(값)
지정된 값을 목록에서 제거한다.지정된 인덱스 번호의 요소 제거del 목록 [번호]
목록 정해진 번호의 값을 제거하는 것이다. 이것은 del 후에 목록 삭제하는 인덱스 번호를 지정하여 작성한다. del 다음에, () 필요 없다.여기까지 "추가", "삽입", "삭제"라는 것은 시컨스라고 해도 목록 밖에 대응되지 않는다. 왜냐하면, 이것은 목록 수정하는 작업이기 때문이다. 튜플과 레인지는 불변 객체 (변경 불가)이므로 이러한 작업은 할 수 없다.이후에는 3개의 컨테이너에 공통되는 것이다. "시퀀스 전반에서 사용할 수 있는 기능"이다.컨테이너의 덧셈변수 = 컨테이너 + 컨테이너
목록과 튜플은 "+"로 덧셈을 할 수 있다. 2개의 컨테이너를 1개에 연결한 것을 만들 수 있다. 레인지는 수열이라는 이유로 해당하지 않는다.컨테이너의 곱셈변수 = 컨테이너 * 정수
컨테이너의 값을 지정한 수 만큼 연결 한 것을 만든다. 예를 들어, 아래와 같다.[1, 2, 3] * 3
↓
[1, 2, 3, 1, 2, 3, 1, 2, 3]
인덱스의 범위를 반환변수 = 컨테이너[시작 값:종료 값]
인덱스 번호로 지정된 범위의 값을 꺼내기 위한 것이다. 예를 들어, [2:5]라고 하면 2~5의 인덱스 번호의 요소를 컨테이너에서 반환한다.값이 포함되어 있는지?값 in 컨테이너
값 not in 컨테이너
이것은 값이 컨테이너에 포함되어 있는지 여부를 확인한다. 결과는 부울이다. in은 값이 포함되어 있으면 True, 없으면 False이다. not in 반대로 포함되어 있으면 False, 없으면 True이다.요소의 개수 얻기변수 = len(컨테이너)
그 컨테이너에 몇개의 값이 저장되어 있는지를 정수로 반환한다.최대 값, 최소값 얻기변수 = max(컨테이너)
변수 = min(컨테이너)
컨테이너에 저장되어 있는 값 중에서 가장 큰 것, 가장 작은 것을 찾아서 반환한다.대충 이것들을 사용해 리스트 내의 요소를 사용할 수 있게 되면 매우 편리하다.아래에 간단한 사용 예를 들어 둡니다.arr = ['hello','bye'] 
arr.append('finish!') 
arr.insert(1, 'welcome') 
arr.remove('bye') 
for n in arr: 
    print(n)
목록 arr에 새로운 값을 추가하거나 삭제한 결과를 출력한다. 최초의 입력한 목록과는 대부분 저장된 값이 변화하고 있는 것을 알 수 있을 거다.집합을 다루는 세트여기까지의 리스트, 튜플, 범위는 모든 시퀀스라는 것이었다. 바꿔 말하면, 인덱스 번호를 사용하여 값에 일련 번호를 할당하고 순차적으로 정리하는 컨테이너였다.하지만, Python에는 "값이 순차적이지 않는 컨테이너"도 있다. 그 중 하나가 "세트(set)"이다.세트는 집합의 컨테이너이다. 세트는 값을 순서대로 정리하지 않는다. 세트 안에는 동일한 값을 여러개로 가질 수 없다. 저장되어 있는 값과 같은 값은 세트에 존재하지 않는 것이다.이 세트는 {} 기호를 붙여 작성한다.변수 = {값1, 값2, ...}
또는 set 함수를 사용하여 만들 수 있다. 인수에는 목록 등의 컨테이너를 제공한다.변수 = set(값1, 값2, ...)
이제 세트를 만들 수 있다. 그러나! 인덱스가 없기 때문에, 여기에서 필요한 값을 뺄 수 없다. 그럼, 무엇을 위해 있는지?라고 생각할 수도 있다. 세트는 집합이다. 따라서 어떤 값이 이 집합에 포함되어 있는지에 대한 여부를 확인할때 사용을 한다.세트 조작세트에서도 세트를 조작하는 기능이 여러가지 준비되어 있다. 그러나 주의하지 않으면 안되는 것은, "세트는 값의 순서가 없다"는 점이다. 이것을 잊지 말고 가보도록 하자.값 추가세트.add(값)
값 추가는 "add"라는 것을 사용한다. 이것으로 ()안에 값이 세트에 추가된다. 그러나 이미 세트에 동일한 값이 있는 경우는 아무런 변화가 없다.값을 삭제세트.remove(값)
값 삭제는 remove를 사용한다. 이것은 시컨스와 같다. 이것으로 ()안의 값이 세트에서 삭제된다.요소의 개수 얻기변수 = len(세트)
그 세트에 몇개의 값이 저장되어 있는지를 정수를 반환다. 이것은 이미 나왔던 거다.최대 값, 최소값 얻기변수 = max(세트)
변수 = min(세트)
세트에 저장되어 있는 값 중에서 가장 큰 것, 작은 것을 찾아서 반환해 준다. 이것도 시컨스에서 사용했었다.세트의 뺄셈세트1 - 세트2
세트는 덧셈과 곱셈은 없지만, 뺄셈은 있다. 이것으로 "세트1"에서 "세트2" 요소를 제거한 나머지를 새로운 세트로 얻을 수 있다.세트의 비교 연산세트1 == 세트2 등
세트는 비교 연산이 가능하다. = <> 등의 기호 류를 사용한 비교 식을 사용하여 두 세트를 비교할 수 있다. 다만, <>는 "어느 쪽의 세트가 크거나 작다"는 의미는 아니다. 이것은 "어딘가가 어딘가에 포함되어 있는지"를 나타낸다. 예를 들어 A>B라고 하면, "A세트에 B세트가 포함되어 있는지"를 나타낸다.세트의 논리 연산 세트1 & 세트2
 세트1 | 세트2
 세트1 ^ 세트2
이 논리 연산은 집합인 세트 특유의 것이다. 이것들은 두개의 세트(집합)을 연산하여 새로운 세트를 만든다. 이것은 다음의 연산자를 사용해서 세트를 만들어 낸다.기호설명&2개의 세트에 공통되는 요소만을 가진 세트를 생성한다. (논리적)|2개의 세트에 있는 모든 요소를 가진 세트를 생성한다. (논리합)^두 세트의 어느 한쪽에만 있는 요소로 구성된 세트를 생성한다. (배타적 논리합) 마지막 논리 연산은 조금 이해하기 어려울지도 모른다. 실제 사용 예제를 참고하여 여러가지를 시도해 보자.a = {'a', 'b'} 
b = {'b', 'c'} 
c1 = a & b 
c2 = a | b 
c3 = a ^ b 
print(c1) 
print(c2) 
print(c3)키 값을 관리하는 사전목록도 튜플도 인덱스라는 번호를 사용하여 값을 관리한다는 점에서는 같았다. 이 숫자가 아닌 "이름"을 사용하여 값을 관리하는 것도 Python에는 제공이 되어 있다. 그것은 "사전(dictionary)"이 라는 것이다.사전은 '키워드'라는 이름을 붙여 값을 관리한다. 그리고 값을 제거하거나 변경하는 경우에는 그 값의 키를 지정한다. 사전은 다음과 같은 형태로 만든다.변수 = {키1:값1, 키2:값2, ...}
또는 dict라는 것을 사용하여 만들 수 있다. 다만, 이 경우는 작성 방식이 조금 다르기 때문에 주의해야 한다.변수 = dict (키1=값1, 키2=값2, ...)
사전에서 값을 꺼내는 경우는 시퀀스와 마찬가지로 []를 사용한다. 다만, 인덱스가 아닌 키워드를 []로 지정한다.변수 = 사전[키]
사전[키] = 값
사전을 이용했을 때, 초보자가 착각하기 쉬운 것은 "사전은 키를 사용해도 다른 것과 동일하게 값을 꺼낼 수 있다"라는 생각이다. 즉, 키로도 꺼낼수 있고, 번호로도 꺼낼 수 있다라고 생각할 수 있다. 하지만 사전은 "키"밖에 사용할 수 없다. 다시 말하면, 사전에 있는 값을 번호 순서대로 추출 할 수 없다.for in 주의!모든 요소를 처리하기 위한 "for ~ in"구문은 사전에서도 사용할 수 있지만, 그 동작이 미묘하게 다르므로 주의가 필요하다.리스트나 튜플에서 "for 변수 in 목록"이라고 하면, 리스트의 값이 변수로 꺼낸진다. 하지만 사전의 경우 꺼내지는 것은 각각의 "값"이 아니고 "키"이다. 즉, 변수에 추출된 키를 사용하여 값을 꺼내 사용하는 형태가 되는 거다.그럼, 아래에 간단한 사용 예를 보도록 하자.dic = {'taro':'taro@yamada.com', 
       'hanako':'hanako@flower', 
       'ichiro':'ichiro@baseball'} 
for n in dic: 
    print(n + ' (' + dic[n] + ')') 
여기에서는 각각의 이름을 키로하여 이메일 주소를 설정하고 있다. for를 사용하여 사전의 모든 데이터를 표시하고 있다. 사전을 사용하면, 이 처럼 작은 데이터베이스와 같은 사용이 가능해 진다.사전 조작사전도 다른 컨테이너와 같은 방법으로 조작 할 수 있는 기능이 여러가지가 제공되어 있다. 주요한 것에 대해 정리하겠다.· 값 추가사전[키] = 값
사전에 새로운 값을 추가하는 것은 간단한다. []으로 추가할 키워드를 지정하고 값을 대입하면 된다. 사전에서 해당 키워드가 아직 사용되지 않고 있다면, 새로운 키워드 항목이 추가된다. append와 add와 같은 기능의 함수가 필요없다.값 삭제del 사전[키]
값을 삭제하려면, remove는 사용할 수 없다. del을 사용하여 삭제한다.모든 키 얻기변수 = 사전.keys()
모든 값 얻기변수 = 사전.values()
모든 항목(키, 값) 얻기변수 = 사전.items ()
사전에 키워드와 값을 함께 얻는 기능이 있다. keys/values는 사전에 저장되어 있는 모든 키워드/값을 컨테이너로 모와서 꺼낸다. 또한, items는 키워드와 값을 튜플에 정리한 것을 얻는 거다.정리사전는 목록 등에 비해 '키워드 값을 꺼내기'라는 특성상 다소 특수한 용도로 사용된다. 데이터의 순서가 중요하지 않는 경우라면, 데이터 이름을 붙여 관리하는 것이 번호로 관리하는 것보다 압도적으로 편리하다. 프로그램 작성에 있어서 경우에 따라 "리스트로 하는 것이 좋을지, 사전을 사용하는 편이 편리할지"를 생각해서 이용하도록 하자.
출처: https://araikuma.tistory.com/357?category=782517 [프로그램 개발 지식 공유:티스토리]

인터넷에 있는 파이썬 코드를 보다 보면 if __name__ == '__main__':으로 시작하는 부분을 자주 만나게 됩니다.

if __name__ == '__main__':
    코드

도대체 이 코드는 왜 사용하는 것일까요? 이 코드는 현재 스크립트 파일이 실행되는 상태를 파악하기 위해 사용합니다.

먼저 __name__부터 알아보겠습니다. 다음 내용을 프로젝트 폴더(C:\project) 안에 hello.py 파일로 저장하세요.

hello.py
print('hello 모듈 시작')
print('hello.py __name__:', __name__)    # __name__ 변수 출력
print('hello 모듈 끝')

그리고 다음 내용을 프로젝트 폴더(C:\project) 안에 main.py 파일로 저장한 뒤 실행해보세요.

main.py
import hello    # hello 모듈을 가져옴
 
print('main.py __name__:', __name__)    # __name__ 변수 출력

실행 결과
hello 모듈 시작
hello.py __name__: hello
hello 모듈 끝
main.py __name__: __main__

실행을 해보면 hello.py 파일과 main.py 파일의 __name__ 변수 값이 출력됩니다.

파이썬에서 import로 모듈을 가져오면 해당 스크립트 파일이 한 번 실행됩니다. 따라서 hello 모듈을 가져오면 hello.py 안의 코드가 실행됩니다.
따라서 hello.py의 __name__ 변수에는 'hello'가 들어가고, main.py의 __name__ 변수에는 '__main__'이 들어갑니다.

즉, __name__은 모듈의 이름이 저장되는 변수이며 import로 모듈을 가져왔을 때 모듈의 이름이 들어갑니다. 
하지만 파이썬 인터프리터로 스크립트 파일을 직접 실행했을 때는 모듈의 이름이 아니라 '__main__'이 들어갑니다
(참고로 __name__과 __main__을 헷갈리지 마세요. 같은 네 글자에 알파벳 모양이 비슷해서 헷갈리기 쉽습니다).

좀 더 정확하게 알아보기 위해 콘솔(터미널, 명령 프롬프트)에서 python으로 main.py 파일을 실행해봅니다(리눅스, macOS에서는 python3 사용).
 
C:\project>python main.py
hello 모듈 시작
hello.py __name__: hello
hello 모듈 끝
main.py __name__: __main__

python main.py와 같이 파이썬으로 스크립트 파일을 직접 실행했습니다. 여기서도 hello.py 파일의 __name__ 변수에는 'hello' 그리고 main.py 파일의 __name__ 변수에는 '__main__'이 들어갑니다.

하지만 다음과 같이 python으로 hello.py 파일을 실행해보면 결과가 조금 달라집니다.

C:\project>python hello.py
hello 모듈 시작
hello.py __name__: __main__
hello 모듈 끝
 
hello.py 파일의 __name__ 변수에는 'hello'가 아니라 '__main__'이 들어갑니다. 즉, 어떤 스크립트 파일이든 파이썬 인터프리터가 최초로 실행한 스크립트 파일의 __name__에는 '__main__'이 들어갑니다. 
이는 프로그램의 시작점(entry point)이라는 뜻입니다.

파이썬은 최초로 시작하는 스크립트 파일과 모듈의 차이가 없습니다. 어떤 스크립트 파일이든 시작점도 될 수 있고, 모듈도 될 수 있습니다. 
그래서 __name__ 변수를 통해 현재 스크립트 파일이 시작점인지 모듈인지 판단합니다.

if __name__ == '__main__':처럼 __name__ 변수의 값이 '__main__'인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업입니다.
즉, 스크립트 파일이 메인 프로그램으로 사용될 때와 모듈로 사용될 때를 구분하기 위한 용도입니다.

45.2.1  스크립트 파일로 실행하거나 모듈로 사용하는 코드 만들기
그럼 스크립트 파일을 그대로 실행할 수도 있고, 모듈로도 사용할 수 있는 코드를 만들어보겠습니다. 다음 내용을 프로젝트 폴더(C:\project) 안에 calc.py 파일로 저장한 뒤 실행해보세요.

calc.py
def add(a, b):
    return a + b
 
def mul(a, b):
    return a * b
 
if __name__ == '__main__':    # 프로그램의 시작점일 때만 아래 코드 실행
    print(add(10, 20))
    print(mul(10, 20))
실행 결과
30
200

C:\project>python calc.py
30
200
IDLE에서 실행하거나 python calc.py와 같이 파이썬 인터프리터로 실행하면 10, 20의 합과 곱이 출력됩니다. 즉, 프로그램의 시작점일 때는 if __name__ == '__main__': 아래의 코드가 실행됩니다.

그럼 calc.py를 모듈로 사용하면 어떻게 될까요? 다음과 같이 import로 calc를 가져와봅니다.

>>> import calc
>>> 
모듈로 가져왔을 때는 아무것도 출력되지 않습니다. 왜냐하면 __name__ 변수의 값이 '__main__'일 때만 10, 20의 합과 곱을 출력하도록 만들었기 때문입니다. 
즉, 스크립트 파일을 모듈로 사용할 때는 calc.add, calc.mul처럼 함수만 사용하는 것이 목적이므로 10, 20의 합과 곱을 출력하는 코드는 필요가 없습니다.

이때는 다음과 같이 calc.add와 calc.mul 함수에 원하는 값을 넣어서 사용하면 됩니다.

>>> calc.add(50, 60)
110
>>> calc.mul(50, 60)
3000

참고 | 파이썬은 왜 프로그램의 시작점이 정해져 있지 않나요?
파이썬이 처음에 개발 될 당시에는 리눅스/유닉스에서 사용하는 스크립트 언어 기반이었기 때문에 프로그램의 시작점이 따로 정해져 있지 않았습니다. 
보통 리눅스/유닉스의 스크립트 파일은 파일 한 개로 이루어진 경우가 많은데, 이 스크립트 파일 자체가 하나의 프로그램이다 보니 시작점이 따로 필요하지 않습니다. 
하지만 C 언어나 자바같은 언어는 처음 만들어질 때부터 소스 파일을 여러 개 사용했기 때문에 여러 소스 파일의 함수들 중에서도 시작 함수(main)를 따로 정해 놓았습니다.

45.3 패키지 만들기

이번에는 패키지를 만들어보겠습니다. 모듈은 스크립트 파일이 한 개지만 패키지는 폴더(디렉터리)로 구성되어 있습니다.
지금부터 만들 패키지의 폴더 구성은 다음과 같습니다.

먼저 프로젝트 폴더(C:\project) 안에 calcpkg 폴더를 만듭니다. 그리고 다음 내용을 calcpkg 폴더 안에 __init__.py 파일로 저장하세요.

calcpkg/__init__.py
# __init__.py 파일은 내용을 비워 둘 수 있음
폴더(디렉터리) 안에 __init__.py 파일이 있으면 해당 폴더는 패키지로 인식됩니다. 그리고 기본적으로 __init__.py 파일의 내용은 비워 둘 수 있습니다
(파이썬 3.3 이상부터는 __init__.py 파일이 없어도 패키지로 인식됩니다. 하지만 하위 버전에도 호환되도록 __init__.py 파일을 작성하는 것을 권장합니다).

45.3.1  패키지에 모듈 만들기
이제 calcpkg 패키지에 모듈을 두 개를 만들겠습니다. 첫 번째 모듈은 덧셈, 곱셈 함수가 들어있는 operation 모듈이고, 
두 번째 모듈은 삼각형, 사각형의 넓이 계산 함수가 들어있는 geometry 모듈입니다.

먼저 다음 내용을 calcpkg 폴더 안에 operation.py 파일로 저장하세요.

calcpkg/operation.py
def add(a, b):
    return a + b
 
def mul(a, b):
    return a * b

그리고 다음 내용을 calcpkg 폴더 안에 geometry.py 파일로 저장하세요.

calcpkg/geometry.py
def triangle_area(base, height):
    return base * height / 2
 
def rectangle_area(width, height):
    return width * height

45.3.2  패키지 사용하기
이제 스크립트 파일에서 패키지의 모듈을 사용해보겠습니다. 다음 내용을 프로젝트 폴더(C:\project) 안에 main.py 파일로 저장한 뒤 실행해보세요
(main.py 파일을 calcpkg 패키지 폴더 안에 넣으면 안 됩니다).

import 패키지.모듈
패키지.모듈.변수
패키지.모듈.함수()
패키지.모듈.클래스()

main.py
import calcpkg.operation    # calcpkg 패키지의 operation 모듈을 가져옴
import calcpkg.geometry     # calcpkg 패키지의 geometry 모듈을 가져옴
 
print(calcpkg.operation.add(10, 20))    # operation 모듈의 add 함수 사용
print(calcpkg.operation.mul(10, 20))    # operation 모듈의 mul 함수 사용
 
print(calcpkg.geometry.triangle_area(30, 40))    # geometry 모듈의 triangle_area 함수 사용
print(calcpkg.geometry.rectangle_area(30, 40))   # geometry 모듈의 rectangle_area 함수 사용

실행 결과
30
200
600.0
1200

calcpkg 패키지의 operation 모듈과 geometry 모듈을 가져와서 안에 들어있는 함수를 호출했습니다.
이처럼 패키지의 모듈을 가져올 때는 import 패키지.모듈 형식으로 가져옵니다. 그리고 패키지.모듈.함수() 형식으로 모듈의 함수를 사용합니다(변수와 클래스도 같은 형식).

45.3.3  from import로 패키지의 모듈에서 변수, 함수, 클래스 가져오기
물론 패키지의 모듈에서 from import로 함수(변수, 클래스)를 가져온 뒤 패키지와 모듈 이름을 붙이지 않고 사용할 수도 있습니다.

from 패키지.모듈 import 변수
from 패키지.모듈 import 함수
from 패키지.모듈 import 클래스
다음은 calcpkg 패키지의 operation 모듈에서 add, mul 함수를 가져옵니다.

>>> from calcpkg.operation import add, mul
>>> add(10, 20)
30
>>> mul(10, 20)
200

 
지금까지 만든 main.py 스크립트 파일과 calcpkg 패키지의 계층을 그림으로 나타내면 다음과 같은 모양이 됩니다. main.py 파일이 있는 폴더에 calcpkg 패키지가 있고, calcpkg 패키지의 폴더 안에 __init__.py, operation.py, geometry.py 파일이 들어있습니다.

▼ 그림 45-6 calcpkg 패키지의 계층

참고 | 패키지의 모듈과 __name__
패키지의 모듈에서는 __name__ 변수에 패키지.모듈 형식으로 이름이 들어갑니다. 즉, calcpkg 패키지의 geometry.py에서 __name__의 값을 출력하도록 만들고, import로 가져오면 'calcpkg.geometry'가 나옵니다.

참고 | 모듈과 패키지를 찾는 경로
지금까지 모듈과 패키지는 현재 폴더(디렉터리)에 만들었습니다. 파이썬에서는 현재 폴더에 모듈, 패키지가 없으면 다음 경로에서 모듈, 패키지를 찾습니다.

>>> import sys
>>> sys.path
['C:\\project', 
'C:\\Users\\dojang\\AppData\\Local\\Programs\\Python\\Python36-32\\Lib\\idlelib',  'C:\\Users\\dojang\\AppData\\Local\\Programs\\Python\\Python36-32\\python36.zip',  'C:\\Users\\dojang\\AppData\\Local\\Programs\\Python\\Python36-32\\DLLs', 'C:\\Users\\dojang\\AppData\\Local\\Programs\\Python\\Python36-32\\lib', 'C:\\Users\\dojang\\AppData\\Local\\Programs\\Python\\Python36-32', 'C:\\Users\\dojang\\AppData\\Local\\Programs\\Python\\Python36-32\\lib\\site-packages']

 
sys 모듈의 path 변수에는 모듈, 패키지를 찾는 경로가 들어있습니다. 여기서 site-packages 폴더에는 pip로 설치한 패키지가 들어갑니다. 그리고 자기가 만든 모듈, 패키지도 site-packages 폴더에 넣으면 스크립트 파일이 어디에 있든 모듈, 패키지를 사용할 수 있습니다.

만약 가상 환경(virtual environment)를 만들어서 모듈과 패키지를 관리한다면 가상환경/Lib/site-packages 폴더에 모듈과 패키지가 들어갑니다. 자세한 내용은 '부록 47.11 가상환경 사용하기'를 참조하세요.

[Python] 클래스 사용
함수뿐만 아니라 다양한 변수를 포함한 큰 프로그램을 하나의 묶음으로 정의하는 것이 "클래스(class)"이다. 클래스의 기본적인 사용법부터 설명한다.
함수와 클래스
함수는 하나의 처리를 하나로 통합한 것이지만, 이런 함수가 많이 늘어나면, 점차적으로 어느 것이 무슨 역할를 하는지 의미를 알기 힘들어 진다. 
예를 들어, 수백개의 함수가 나열되어 있으면, 그것을 전부 이해해 나가는 것은 힘들 것이다.그래서 "비슷한 역할을 하는 것을 한곳에 모으자"라고 누구든지 생각된다.
예를 들어, 어떤 데이터 처리를 만드는 것을 생각해 보자. 데이터를 관리하는 함수, 데이터를 추가하는 함수, 데이터를 삭제하는 함수, 데이터를 출력하는 함수 ...... 
따위가 쭉 늘어서 있는 것은 그다지 사용하기가 쉽지 않다.그래서 "데이터를 처리하기 위해 필요한 것"을 모두 한 묶음으로 두자"라고 생각하게 된다. 
큰 "데이터 관계 묶음'이라는 것을 만들고, 그 안에 "데이터를 보관할 변수", "데이터를 파일에 읽고 쓰는 함수", "데이터를 추가하거나 삭제하는 함수",
 "데이터를 출력하는 함수" ......와 같이, 그 데이터 처리에 필요한 변수와 함수를 모두 하나로 모으자는 것이다.
그렇게 되면 데이터의 처리에 관해서는 우선 "이 묶음에 안에 반드시 있다"라는 것이 되기 때문에, 곳곳의 함수를 찾지 않아도 된다.
이것이 "클래스(class)"의 개념이다. 
클래스라는 것은 어떤 목적을 위해 필요한 '값'과 '처리'를 모두 한 묶음으로 한 것이다. 이 클래스는 아래와 같은 같은 형태로 만든다. 
"class 클래스 이름:"라는 것으로 시작하여 그 아래에 클래스가 제공하는 변수와 함수를 들여 쓰기하여 작성한다.

클래스의 정의
class 클래스 이름:
  변수1
  변수2
  ......필요한 만큼 변수를 제공......

  def 메소드1(인수):
     ......메소드의 처리......
   
  def 메소드2(인수):
     ......메소드의 처리......
   
  ......필요한만큼 메소드를 제공......

클래스에 필요한 값을 저장하는 변수를 "멤버 변수", 클래스에 제공하는 함수를 "메소드"라고 한다.

이러한 작성법은 기본적으로 일반 변수와 함수의 작성법 동일하다. 단지 "class OO:"라는 정의에 쓰면 멤버 변수와 메소드로 처리 할 수 있게 된다는 것 뿐이다. 특별한 작성법 등은 없다.

클래스 생성
이제 실제로 클래스를 만들어 사용해 보기로 하자. 이전에 "이름을 사용하여 메시지를 표시한다"는 것을 클래스에 해보기로 한다. 아래에 샘플을 예제를 보도록 하자. 
여기에서는 "Member"라는 클래스를 만들었다.

class Member: 
    name = "" 
   
    def showMsg(self): 
        print("Hello, " + self.name + ". How are you?")
멤버 변수는 이름을 저장하는 "name"이라는 변수를 선언하였다. 메소드는 메시지를 표시하는 "showMsg"를 선언하고 있다.

이 클래스의 소스 코드를 보면, 여태 보지 못한 것이 등장하고 있다. "self"라는 것인다. 이것은 showMsg 인수에 사용되고 있다. 
"뭐야, 단지 인수에 사용한 변수인가?"라고 생각하면 그렇지 않다는 것을 알 수 있다.메소드 안에는 'self.name'라는 식으로 왠지 잘 모르는 사용 법을 사용하고 있다.

사실은 이 "self"라는 것은 "자신"을 나타내는 특별한 값이다. 자신은 클래스가 아니다. 클래스에서 만들어진 "인스턴스"라는 거다.
인스턴스와 self 클래스라는 것은 함수 등과 같이 그대로 클래스에서 메소드를 호출하거나 해서 사용하지는 않는다. 클래스를 이용하기 위해서는 "인스턴스"라는 것을 만들어야 한다.
클래스라는 것은 말하자면 프로그램의 "청사진"이다. 이것 자체를 조작하는 것이 아니라, 이 클래스는 설계도를 바탕으로 실제로 사용할 수 있는 부품을 만들어 그것을 조작하는 거다. 
이 부품이 인스턴스이다.

만약 클래스를 그대로 사용하면, 그 클래스의 기능을 몇번이고 사용하고 싶다면 많은 클래스를 만들어야 한다. 
예를 들어, 샘플 Member 클래스를 사용하여 "Taro"며 "Hanako"의 데이터를 관리하려 했다고 생각해 보자. 
클래스를 그대로 사용하게 되면 그 name에 "Taro"로 설정하면, 또 "Hanako"는 보관할 수 없게되어 버린다.
그래서 클래스를 바탕으로 "인스턴스"라는 부품을 만들고, 그것에 Taro로 설정해 주어야 한다. 
Hanako가 필요하게 되면, 또한 클래스에서 새로운 인스턴스를 만들고, 거기에 Hanako라고 설정 해준다. 
이런 상태로 "Member 클래스를 사용할 필요가 있으면 새로 Member의 인스턴스를 만들고, 이름을 설정해 주어야"입니다. 
이렇게 하면 이 클래스를 바탕으로 얼마든지 데이터를 처리할 수 있게 된다. 그리고, 이 인스턴스 자신을 가리키는 데 준비하는 것이 "self"라는 것이다.
예를 들어, 어떤 메소드에서 "이 인스턴스에 저장되어 있는 멤버 변수의 값을 사용해야 한다"고 해보자. 이 예에서 말한다면, Member의 name 값을 showMsg에서 사용하는 경우이다.
이 때, 그냥 'name'변수 이름으로 사용할 수 없다. "이 인스턴스 안에 있는 name" 형태로 지정을 해주지 않으면 안된다.

그래서 Python 클래스에 제공되는 메소드는 반드시 첫 번째 인수에 인스턴스 자신을 나타내는 값을 전달하도록 해야 한다. 이것이 "self"의 정체는 것이다. 
이 self 안에있는 멤버 변수와 메소드는 self."변수"
따라서, self후에 점(.)으로 지정한다. 예를 들어, 여기에 "self.name"라고 하고 name 멤버 변수를 지정하고 이용하면 된다.

클래스 사용
이제 만든 Member 클래스를 사용해 보자. 아래에 사용할 소스 코드 예제가 있다.

class Member: 
    name = "" 
   
    def showMsg(self): 
        print("Hello," + self.name + ".How are you?") 
   
taro = Member() 
taro.name = "Taro"
taro.showMsg() 
   
hanako = Member() 
hanako.name = "Hanako"
hanako.showMsg()

여기에서는 Taro와 Hanako라는 2명의 데이터를 처리하기 위해 2개의 인스턴스를 만들어 사용하고 있다. 인스턴스의 생성은 "클래스 이름()"과 같이 이걸을 호출을 한다.
여기에서는 taro = Member() 이렇게 호출하고 있다. 이제 변수 taro에 Member 클래스의 인스턴스가 만들어 보관된다. 
또한 인스턴스의 멤버 변수와 메소드는 점(.)을 사용하여 변수 이름 뒤에 해당되는 변수와 메소드를 작성해서 호출한다. 예를 들어,taro.name = "Taro" taro.showMsg()
이것은 taro 인스턴스의 name 멤버 변수에 "Taro"라고 값을 설정 해주고, 그러고 나서 showMsg 메소드를 호출해 실행을 한다. 
이런 식으로 인스턴스를 만들어 변수에 할당 해두면 클래스 안에 있는 요소는 자유롭게 사용할 수 있다. 
또한, 이 name와 같이 각 인스턴스에 값을 저장하고 사용하는 멤버 변수를 "인스턴스 변수"라고도 한다.
self는 어디 갔지?
그런데 이 사용 예를 보고 무언가 의문을 생기지 않나요? 그것은 showMsg를 호출하는 부분이다. "taro.showMsg()"라고 되어 있다. 
어? showMsg는, 첫번째 인수에 "self"가 준비되어 있지 않은가? 그 self는 도대체 어떻게 된 것일까?

사실을 말하면, 메소드의 첫번째 인수로 전달되는 "인스턴스 자신"의 값은 Python의 시스템에 의해 자동으로 넘겨지게 된다. 즉, 첫번째 인수(self) 메서드를 호출할 때 불필요한 거다.
호출할 때, 두 번째 인수 이후만 작성한다. (여기에서는 첫번째 인수밖에 없기 때문에, 호출할 때 인수를 생략했다)이런 식으로 인스턴스를 만들고 그 안의 멤버 변수를 설정하고 메서드를 호출한다. 
이것이 클래스를 사용하는 기본이다. 이러한 기본 작업을 알면 클래스는 쉽게 사용할 수 있다.



생성자 사용
그렇게 하더라도,이 Member클래스 별로 유용하지 않는다. 인스턴스를 만들고, name을 설정하여 showMsg를 호출 ... 
결국 하나 하나 다하고 있는 것은 클래스를 사용하지 않는 경우와 별로 차이가 없다. 
게다가 인스턴스를 만든 후에 멤버 변수의 설정을 잊으면, 생각대로 움직이지 않게 되어 버린다. 
적어도 "필요한 값은 처음부터 제대로 설정 사용"하도록 하고 싶다.이럴 때에 유용한 것이 '생성자(constructor)'라는 것이 있다. 
생성자는 "인스턴스를 만들 때 자동으로 호출되는 인스턴스 초기화를 위한 특별한 방법"이다. 이것은 다음과 같이 만든다.

def __init __ (self 인수 ...):
    ...... 초기화 처리 ......

생성자는 "__init__"와 같은 이름으로 메소드를 작성한다. 만약 어떤 값을 인수로 전달 싶다면, 2번째 인수 이후에 지정한다 (첫번째 인수는 반드시 self이다).
이와 같이 생성자를 준비하면 인스턴스를 만들 때, 이 생성자를 사용하게 된다. 아래 예제를 보도록 하자.

class Member: 
   name = "" 
  
   def __init__(self, str): 
       self.name = str
  
   def showMsg(self): 
       print("Hello," + self.name + ".How are you?") 
  
taro = Member("Taro") 
taro.showMsg() 
  
hanako = Member("Hanako") 
hanako.showMsg()

여기에서는 다음과 같이 하여 str라는 인수를 전달하는 형태로 생성자를 제공하고 있다.
def __init__(self, str):
이제 인스턴스를 만들 때 name을 설정해야 한다. 실제로 인스턴스를 만들고 있는 곳을 보면,taro = Member("Taro")
이런 식으로 ()에 이름을 인수로 넣고 있는 것을 볼 수 있다. 이렇게 해서 인수를 지정하여 인스턴스를 만들 수 있게 하면 필요한 멤버 변수의 설정도 한꺼번에 할 수 있어 매우 편리하다.
상속 클래스클래스를 정의하는 가장 큰 장점은 "재사용이 가능하다"라는 것이다. 한번 만들면, 이후에는 그것을 그대로 복사하여 여기 저기에서 사용할 수 있다.
그러나 실제로 사용해 보면 "여기는 이렇게 하는 것이 더 좋다"라고 하는 것이 나올 거다. 하지만, 어느 정도의 규모의 프로그램가 되면, 곳곳에서 클래스를 사용하고 있으면 이런 수정은 제공되지 않는다.
이럴 때 정말 편리한 기능이 준비되어 있다. 그것은 "상속"이라는 것이다. 상속이라는 것은 이미 클래스를 그대로 이어 받아 새로운 클래스를 만드는 것이다. 
"이어 받는다"라는 것은 "클래스의 모든 기능을 그대로 이어 받는다"라는 것이다. 즉, 그 클래스에 있는 것을 통째로 그대로 받아 새로운 클래스를 만드는 거다.
이 상속을 사용하여 클래스를 정의하려면 다음과 같이 클래스를 만듭니다.

def 클래스 이름(상속하는 클래스):
    ...... 클래스의 내용 ......

상속에는, 상속하는 원래 클래스를 "기본 클래스", 새로 만든 클래스를 "파생 클래스"라고 한다. 실제 사용 예를 아래와 같다.

class Member: 
    name = "" 
   
    def __init__(self,str): 
        self.name = str
   
    def showMsg(self): 
        print("Hello," + self.name + ".How are you?") 
   
class PowerMember (Member): 
    mail = "" 
   
    def __init__(self,str1,str2): 
        self.name = str1 
        self.mail = str2 
   
    def showMsg(self): 
        print("Hello," + self.name + ".") 
        print("Your mail address is '" + self.mail + "'.") 
   
   
taro = Member("Taro") 
taro.showMsg() 
   
hanako = PowerMember("Hanako","hanako@flower.com") 
hanako.showMsg() 

여기에서는 Member 클래스를 상속하여 PowerMember라는 파생 클래스를 만들고 있다.이 PowerMember 클래스는 def __init__(self, str1, str2):이렇게 하여, 2개의 인수를 준비했다. 
그리고 self.name과 self.mail에 각각 설정하고 있다. 그런데, 이상한게 있다. 조금 자세히 더 살펴 보도록 하자.잘 보면 이 PowerMember 클래스는 "mail"밖에 인스턴스 변수가 포함되어 있지 않았다. 
그런데 self.name 값은 잘 저장하고 있다. 이것은 기본 클래스인 Member에 name가 준비되어 있기 때문이다. 상속은 기본 클래스의 모든 기능을 이어 받아 사용할 수 있다.
 따라서 PowerMember에 name을 준비 할 필요는 없다. 멤버 변수뿐만 아니라 메소드도 모든 슈퍼 클래스에 있는 것은 그대로 사용할 수 있다. 
이 상속을 사용하면 이미 있는 클래스를 점점 확장하여 기능 강화해 나갈 수 있다는 것이다. Python에는 다양한 클래스가 라이브러리에 포함되어 있다.
 그리고 그들을 이용할 때, 이 "상속"이 사용되고 있다. 예를 들어, 먼저 "리스트", "튜플", "레인지"라는 컨테이너에 대해 설명을 했었다. 이런 것도 실은 모든 "클래스"로 준비되어 있다.
 이 3개의 클래스에 공통된 기능이 많은 것은 '시컨스'라는 인덱스에서 관리하는 컨테이너 클래스가 있고 그것을 계승하고 리스트나 튜플이 있다고 생각하면 이미지화하기 쉬울 것이다.

출처: https://araikuma.tistory.com/371 [프로그램 개발 지식 공유:티스토리]

▶ 코딩도장
https://dojang.io/mod/page/view.php?id=2384

Unit 36. 클래스 상속 사용하기
지금까지 클래스의 기본적인 사용 방법을 알아보았습니다. 이번에는 클래스 상속(inheritance)을 사용해보겠습니다.
상속은 무언가를 물려받는다는 뜻입니다. 그래서 클래스 상속은 물려받은 기능을 유지한채로 다른 기능을 추가할 때 사용하는 기능입니다.
여기서 기능을 물려주는 클래스를 기반 클래스(base class), 상속을 받아 새롭게 만드는 클래스를 파생 클래스(derived class)라고 합니다.

보통 기반 클래스는 부모 클래스(parent class), 슈퍼 클래스(superclass)라고 부르고, 파생 클래스는 자식 클래스(child class), 서브 클래스(subclass)라고도 부릅니다.
클래스 상속은 생물 분류를 떠올리면 이해하기 쉽습니다. 예를 들어 조류, 어류는 공통된 조상인 척추동물로부터 물려받은 특성을 공유하면서 각자 고유한 특성을 가집니다.
척추를 가졌다는 특성은 변함이 없지만 날개를 가졌으면 조류, 물속에 살면 어류인 식입니다. 즉, 같은 계통으로 특성을 공유하며 전혀 상관없이 어류가 꽃식물의 특성을 가지지는 않습니다.

마찬가지로 클래스 상속도 기반 클래스의 능력을 그대로 활용하면서 새로운 클래스를 만들 때 사용합니다. 동물을 예로 들면 척추동물에서 포유류, 조류, 파충류 등을 만드는 식이죠.
그런데 그냥 새로운 클래스를 만들면 되지 왜 이런 상속 개념을 만들었을까요? 만약 새로운 기능이 필요할 때마다 계속 클래스를 만든다면 중복되는 부분을 반복해서 만들어야 합니다.
이럴 때 상속을 사용하면 중복되는 기능을 만들지 않아도 됩니다. 따라서 상속은 기존 기능을 재사용할 수 있어서 효율적입니다.

36.1 사람 클래스로 학생 클래스 만들기
클래스 상속은 다음과 같이 클래스를 만들 때 ( )(괄호)를 붙이고 안에 기반 클래스 이름을 넣습니다.

class 기반클래스이름:
    코드
 
class 파생클래스이름(기반클래스이름):
    코드

그럼 간단하게 사람 클래스를 만들고 사람 클래스를 상속받아 학생 클래스를 만들어보겠습니다.

class_inheritance.py
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def study(self):
        print('공부하기')
 
james = Student()
james.greeting()    # 안녕하세요.: 기반 클래스 Person의 메서드 호출
james.study()       # 공부하기: 파생 클래스 Student에 추가한 study 메서드
실행 결과
안녕하세요.
공부하기

Student 클래스를 만들 때 class Student(Person):과 같이 ( )(괄호) 안에 기반 클래스인 Person 클래스를 넣었습니다. 이렇게 하면 Person 클래스의 기능을 물려받은 Student 클래스가 됩니다.
Student 클래스에는 greeting 메서드가 없지만 Person 클래스를 상속받았으므로 greeting 메서드를 호출할 수 있습니다.
 
james = Student()
james.greeting()    # 안녕하세요.: 기반 클래스 Person의 메서드 호출
그리고 Student 클래스에 추가한 새로운 메서드인 study를 호출했습니다.
james.study()       # 공부하기: 파생 클래스 Student에 추가한 study 메서드
Person 클래스와 Student 클래스의 관계를 그림으로 나타내면 다음과 같은 모양이 됩니다.

이처럼 클래스 상속은 기반 클래스의 기능을 유지하면서 새로운 기능을 추가할 수 있습니다. 특히 클래스 상속은 연관되면서 동등한 기능일 때 사용합니다. 즉, 학생은 사람이므로 연관된 개념이고, 학생은 사람에서 역할만 확장되었을 뿐 동등한 개념입니다.

참고 | 상속 관계 확인하기
클래스의 상속 관계를 확인하고 싶을 때는 issubclass 함수를 사용합니다. 즉, 클래스가 기반 클래스의 파생 클래스인지 확인합니다. 기반 클래스의 파생 클래스가 맞으면 True, 아니면 False를 반환합니다.

issubclass(파생클래스, 기반클래스)

>>> class Person:
...     pass
...
>>> class Student(Person):
...     pass
...
>>> issubclass(Student, Person)
True
Student가 Person의 파생 클래스이므로 issubclass는 True가 나옵니다.

36.2 상속 관계와 포함 관계 알아보기
지금까지 기반 클래스를 상속하여 새로운 클래스를 만들어 보았습니다. 그런데 클래스 상속은 정확히 어디에 사용해야 할까요?

36.2.1  상속 관계
앞에서 만든 Student 클래스는 Person 클래스를 상속받아서 만들었습니다.

class_is_a.py
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def study(self):
        print('공부하기')
여기서 학생 Student는 사람 Person이므로 같은 종류입니다. 이처럼 상속은 명확하게 같은 종류이며 동등한 관계일 때 사용합니다. 
즉, "학생은 사람이다."라고 했을 때 말이 되면 동등한 관계입니다. 그래서 상속 관계를 영어로 is-a 관계라고 부릅니다(Student is a Person).

36.2.2  포함 관계
하지만 학생 클래스가 아니라 사람 목록을 관리하는 클래스를 만든다면 어떻게 해야 할까요? 다음과 같이 리스트 속성에 Person 인스턴스를 넣어서 관리하면 됩니다.

class_has_a.py
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class PersonList:
    def __init__(self):
        self.person_list = []    # 리스트 속성에 Person 인스턴스를 넣어서 관리
 
    def append_person(self, person):    # 리스트 속성에 Person 인스턴스를 추가하는 함수
        self.person_list.append(person)
여기서는 상속을 사용하지 않고 속성에 인스턴스를 넣어서 관리하므로 PersonList가 Person을 포함하고 있습니다. 
이러면 사람 목록 PersonList와 사람 Person은 동등한 관계가 아니라 포함 관계입니다. 즉, "사람 목록은 사람을 가지고 있다."라고 말할 수 있습니다. 
그래서 포함 관계를 영어로 has-a 관계라고 부릅니다(PersonList has a Person).

정리하자면 같은 종류에 동등한 관계일 때는 상속을 사용하고, 그 이외에는 속성에 인스턴스를 넣는 포함 방식을 사용하면 됩니다.


36.3 기반 클래스의 속성 사용하기

이번에는 기반 클래스에 들어있는 인스턴스 속성을 사용해보겠습니다. 다음과 같이 Person 클래스에 hello 속성이 있고, Person 클래스를 상속받아 Student 클래스를 만듭니다.
그다음에 Student로 인스턴스를 만들고 hello 속성에 접근해봅니다.

class_inheritance_attribute_error.py
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    def __init__(self):
        print('Student __init__')
        self.school = '파이썬 코딩 도장'
 
james = Student()
print(james.school)
print(james.hello)    # 기반 클래스의 속성을 출력하려고 하면 에러가 발생함


실행 결과
Student __init__
파이썬 코딩 도장
Traceback (most recent call last):
  File "C:\project\class_inheritance_attribute_error.py", line 14, in <module>
    print(james.hello)
AttributeError: 'Student' object has no attribute 'hello' 
실행을 해보면 에러가 발생합니다. 왜냐하면 기반 클래스 Person의 __init__ 메서드가 호출되지 않았기 때문입니다. 실행 결과를 잘 보면 'Student __init__'만 출력되었습니다.

즉, Person의 __init__ 메서드가 호출되지 않으면 self.hello = '안녕하세요.'도 실행되지 않아서 속성이 만들어지지 않습니다.

36.3.1  super()로 기반 클래스 초기화하기
이때는 super()를 사용해서 기반 클래스의 __init__ 메서드를 호출해줍니다. 다음과 같이 super() 뒤에 .(점)을 붙여서 메서드를 호출하는 방식입니다.

super().메서드()
class_inheritance_attribute.py
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    def __init__(self):
        print('Student __init__')
        super().__init__()                # super()로 기반 클래스의 __init__ 메서드 호출
        self.school = '파이썬 코딩 도장'
 
james = Student()
print(james.school)
print(james.hello)
실행 결과
Student __init__
Person __init__
파이썬 코딩 도장
안녕하세요.
실행을 해보면 기반 클래스 Person의 속성인 hello가 잘 출력됩니다. super().__init__()와 같이 기반 클래스 Person의 __init__ 메서드를 호출해주면 기반 클래스가 초기화되어서 속성이 만들어집니다.
실행 결과를 보면 'Student __init__'과 'Person __init__'이 모두 출력되었습니다.

기반 클래스 Person의 속성 hello를 찾는 과정을 그림으로 나타내면 다음과 같은 모양이 됩니다.

36.3.2  기반 클래스를 초기화하지 않아도 되는 경우
만약 파생 클래스에서 __init__ 메서드를 생략한다면 기반 클래스의 __init__이 자동으로 호출되므로 super()는 사용하지 않아도 됩니다.

class_inheritance_no_init.py
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    pass
 
james = Student()
print(james.hello)
실행 결과
Person __init__
안녕하세요.
이처럼 파생 클래스에 __init__ 메서드가 없다면 기반 클래스의 __init__이 자동으로 호출되므로 기반 클래스의 속성을 사용할 수 있습니다.

참고 | 좀 더 명확하게 super 사용하기
super는 다음과 같이 파생 클래스와 self를 넣어서 현재 클래스가 어떤 클래스인지 명확하게 표시하는 방법도 있습니다. 물론 super()와 기능은 같습니다.

super(파생클래스, self).메서드

class Student(Person):
    def __init__(self):
        print('Student __init__')
        super(Student, self).__init__()     # super(파생클래스, self)로 기반 클래스의 메서드 호출
        self.school = '파이썬 코딩 도장'



함수

스크립트의 일부분을 잘라내어 언제든지 사용할 수 있도록 하는 "함수", 이것을 잘 다루면 긴 프로그램을 구조적으로 조립이 가능하다. 그 기본을 설명한다.
함수란?
스크립트라고 하는 것은, 같은 처리를 여러번 반복하는 경우가 많다. 그 때마다 일일이 같은 스크립트를 여러번 쓰는 것은 매우 귀찮다. 
이러한 "정해진 처리"를 언제 어디서나 호출할 수 있도록 하는 것이 "함수"이다. 예를 들어, 아래에 올린 예제(1)과 같은 예를 생각해 보자. 
변수에 이름을 넣어 "Hello, OO. How are you?"라고 출력하는 스크립트이다. 이것은 유사한 텍스트를 출력하기 위해, 유사한 print 문을 여러번 작성을 하였다.
 어쩐지 너무 바보 같지 않은가?

예제 (1)
a = "Taro" 
b = "Hanako" 
c = "Ichiro" 
   
print("Hello, " + a + ". How are you?") 
print("Hello, " + b + ". How are you?") 
print("Hello, " + c + ". How are you?")

이러한 때 "함수"가 도움이 된다. 예제(2) 함수를 사용하여 다시 작성한 것이다. 
첫째로, 정해진 형태로 출력하는 함수를 먼저 준비해두면, 그 후로는 "showMsg("Taro ")"라고 하면 언제든지 호출 할 수 있다.  호출을 하는 것만으로 지정된 형태의 메시지가 표시될 것이다.

예제(2)
def showMsg(str): 
    print("Hello, " + str + ". How are you?") 
   
showMsg("Taro") 
showMsg("Hanako") 
showMsg("Ichiro") 

여기에서는 짧은 메시지를 표시 할 뿐이지만, 좀 더 복잡한 처리가 되면 "한번 스크립트를 작성해 놓으면, 그것은 언제든지 호출하여 실행할 수 있다"라는 것은 매우 편리하다라는 것을 알 수있을 것이다.
print도 함수? 이 함수라는 것은 이미 실은 여러분은 사용하고 있었다. 값을 출력하는 "print"이다. Python은 기본적으로 많은 기능을 사용할 수 있게 되어 있다. 대부분은 "함수"로 준비되어 있는 것이다. 

함수의 정의
이제 이 함수는 어떻게 만드는지, 설명하겠다. 함수는 다음과 같은 형태로 정의한다.

함수의 정의 (1)
def 함수 이름(인수1, 인수 2, ...):
    ...... 수행 할 작업 ......

함수 정의의 기본은 "def 함수 이름"이다. 이전에 샘플(2)는 "def showMsg ~"라고 되어 있기 때문에, showMsg라는 함수가 만들어진 것이다.
그리고 함수 이름 뒤에 ():을 붙이고 그 이후로는 줄 바꿈하고 들여 쓰기를 하여, 수행할 처리를 작성한다. (): 안에는 '인수'라는 것을 추가할 수 있다. 
인수는 함수를 호출할 때에 어떤 값을 받아서 전달하는데 사용한다. 예를 들어 샘플(2)에서def showMsg(str) : 이렇게 되어 있었다. 
이는 ()안에 있는 "str"라는 인수가 포함되어 있다는 것이다.이것은 "이 함수를 호출 할 때, 어떤 값을 함께 쓰기 때문에, 그것을 str이라는 변수에 넣어 전달한다"라는 의미이다. 
샘플에서 호출하는 부분을 살펴 보자.
showMsg( "Taro")
자, 이런 식으로 함수 이름 뒤에 ()를 붙이고, "Taro"라는 값이 작성되어 있는 걸까? 이 "Taro"가 showMsg 함수의 "str" 변수에 전달된다. 실행중인 처리를 보면, 이렇게 되어 있다.
print("Hello, " + str + ". How are you?") 
전달된 변수로 str을 사용하여 메시지를 print하고 있는 것을 알 수 있다. 인수는 하나뿐 아니라 얼마든지 추가할 수 있다. 이 경우 각각의 변수를 쉼표로 구분하여 작성한다.

def showMsg(a, b, c): 
이런 식이다. 인수가 없는 경우에도 ()은 붙이지 않으면 안된다. 함수를 이용하는데 있어서 최소한 기억하지 않으면 안 것은 우선 이것뿐이다. 의외로 간단하지 않는가?

반환 값
함수는 함수 이름과 인수가 제대로 알면 정의 할 수 있다. 사실은 함수 정의 부분에 나타나지 않는 또 하나의 중요한 요소가 있다. 그것은 "반환 값"이다. 
반환 값은 함수를 실행한 후, 어떤 값을 호출한 곳에 돌려주는 역할을 한다. 이 반환 값은 "return"이라는 것을 사용하여 설정한다. 

함수의 정의 (2) 
def 함수 이름(인수 1, 인수 2, ...):
     ...... 수행 할 작업 ......
     return 값

이와 같이 처리 한 후, 마지막에 "return 값"으로 인해 값을 반환하고, 호출 곳에 값이 전달된다. 실제로 반환 값을 사용해 보자. 이전에 샘플을 반환 값을 반환하는 형태로 고치면 아래와 같다.
def showMsg(str): 
    return "Hello," + str + ".How are you?"
   
res = showMsg("Taro") 
print(res) 
res = showMsg("Hanako") 
print(res) 

여기에서는 showMsg 함수에서 return을 사용하여 텍스트를 반환한다. 이 함수를 호출하는 부분을 보면, res = showMsg("Taro")
이렇게 되어있는 것을 확인할 수 있다. showMsg의 결과를 변수 res에 대입하고, 이것으로 반환 값이 res에 할당되게 된다. 그러고 나서는 이 res를 사용하여 결과를 표시하고 있다.
키워드 인수함수를 구성하는 요소 중에 의외로 다기능 것이 "인수"이다. 이것은 일반적으로 값을 전달 외에 여러가지 옵션을 가지고 있다. 
먼저 "키워드 인수"라는 것이 있다. 이것은 인수에 키워드(이름)을 붙여 사용할 수 있도록 하는 기능이다. 무슨 말인가 하면, 아래와 같은 것이다.

함수의 정의 (3)
def 함수(키1=초기값1, 키2=초기값2, ...):
키와 초기 값을 지정하는 것이다. 그러면 키를 사용하여 인수를 지정할 수 있다. 보통 인수는 순서가 정해져 있지만, 키를 사용하여 순서에 관계없이 값을 작성할 수 있다.
또한, 초기 값을 설정할 수 있기 때문에 값을 생략할 수 있다 (생략하면 기본값이 사용된다). 보통 인수는 반드시 값을 전달하지 않으면 안되지만, 
키워드 인수로 하게 되면 옵션 다루는 (없어도 OK) 인수를 만들 수 있다. 그럼 실제 사용 예를 살펴 보자.
def showMsg(name, header='Hello', footer='How are you?'): 
    print(header + "," + name + ". " + footer) 
   
showMsg("Taro") 
showMsg("철수", '안녕', '건강하니?') 
showMsg("영희", footer='잘지내니?', header='야') 
여기에는 세가지 인수의 지정을 해서 showMsg를 호출한다. showMsg("Taro")와 같이, 첫번째 인수에 이름을 지정하는 것만으로도 제대로 동작하고, 두번째와 세번째는 초기값으로 동작한다.
또한 키워드는 붙여도 붙이지 않아도 동작한다. 다만, 키워드를 붙이지 않는 경우는 인수가 정의된 순서대로 지정해야 한다. 키워드를 붙여 인수를 작성할 경우는 어떤 순서라도 상관없다.
여기에서는 키워드가 없는 인수와 있는 인수가 혼재하고 있지만, 이러한 경우에는 반드시 "키워드가 없는 인수"를 먼저 정의하고 키워드 인수는 다음에 정의해야 한다. 
키워드 인수 후에 키워드가 없는 인수를 지정하면 문법 오류이다. 가변 인자인수에 대해 또 다른 설명을 하고 싶은 것이 "가변 인자"라는 것이다. 
가변 인자라는 것은 "길이 (인수의 수)가 가변 인수"이다. 즉, "몇 개의 인수를 붙여도 된다"라는 특별한 인수이다. "인수가 몇개 있어도 된다? 그것을 어떻게 정의하는 걸까?"라고 이상하게 생각 하겠지만, 가능하다. 
"정의 할 수 있지만 어떻게 값을 받을 거야?"라고 생각 하겠지만, 받을 수 있다. 가변 인자라는 것은 알기 쉽게 말하자면, "많은 인수를 컨테이너에 모아서 받을 인수"이다. 
즉, "목록을 인수로 설정한 것"이라고 말할 수 있다. 다만, 목록을 인수에 쓰는 번거로움 때문에, (목록에 보관해 두는 값을) 하나씩 인수에 넣으면 자동으로 그것들을 한꺼번에 넘겨주게 되어 있다.
이 가변 인자는 다음과 같이 정의한다.

함수의 정의 (4)
def 함수(*인수):
인수 정의하는 변수 이름 앞에 별표 (*)를 붙이면, 그 인수가 가변 인자로 설정된다. 이 인수에는 여러 인수로 정의한 값이 n개로 모와서 전달된다. 
그 후로는 거기로 부터 필요한 값을 꺼내는 처리만 하면 된다. 그럼 이것도 간단한 예제를 살펴 보자.

def calc(*num): 
    total = 0
    for n in num: 
        total += int(n) 
    print('합계：' + str(total)) 
    print('평균：' + str(total // len(num))) 
   
calc(123, 456, 789, 246, 357, 910) 
여기에서는 calc(* num)와 같이 함수를 정의하고 있다. 이것으로 num이라는 변수에 입력된 모든 인수를 컨테이너에 모와서 전달된다. 그 후에는 이 num을 for문으로 반복해 나가면 된다.                                              
                    
출처: https://araikuma.tistory.com/365?category=782517 [프로그램 개발 지식 공유:티스토리]






https://maeng-gun.github.io/excel/excel3/
xlwings
Book Sheet Range
 
openpyxl


tkinter
- Python 설치시 기본적으로 내장되어 있는 파이썬 표준 라이브러리이기 때문에 PyQt처럼 별도로 설치할 필요가 없으며, 쉽고 간단한 GUI 프로그램을 만들 때 활용될 수 있다.
- 타 GUI 프레임워크나 툴킷에 비해 지원되는 위젯들이 부족하고 UI도 예쁘지 않다. 그래도 콘솔창보다는 낫다.

PyQt5
- 디자인 툴이 따로 제공되어 GUI 디자인이 용이하다
- pip을 이용하여 설치 (pip3 install PyQt5)
* 필자는 비쥬얼 스튜디오 코드(Visual Studio COde)를 사용한다.
- Codetorial에 설치에서부터 사용법까지 아주 자세히 잘 설명되어 있다. 
* 위 사이트에서는 파이참과 아나콘다를 이용한다
- Qt는 플랫폼에 관계없이 다양한 기능을 포함하는 C++ 라이브러리이자 개발툴이며, PyQt5는 Qt5 어플리케이션 프레임워크에 대한 파이썬 버전이다.

신뢰성 data read


os.chdir(r'C:\Users\Administrator\Documents\do-it-python-master\05')

1. Data Input
   IT 가속계수 산출 data → 기종정보 + 평가조건 + 가속계수 → 중간확인 : 화일 및 화면 출력
   관리번호	재료	파우더 사이즈	파우더	조성	Sheet T	유전체두께	기종	칩사이즈	Vr	시험온도	시험전압	시험전계	Vr/um	m	η	MTTF	B0.1
   온도하한	온도평균	온도상한	전압하한	전압평균	전압상한

2. Data 처리
   1) 10V/um 계산
   2) 장기신뢰성 조건 계산 : 1차 85℃, 6.3V → 2차 실제 온도, 정격 (보증전압)
       변환온도	변환전압(10V/um)
       온도가속(10V/um)	전압가속(10V/um)	η(10V/um) MTTF(10V/um) B0.1(10V/um)

3. Data Output
   변환온도	변환전압(10V/um)	온도가속(10V/um)	전압가속(10V/um)	η(10V/um) MTTF(10V/um) B0.1(10V/um)


정규 표현식을 지원 - re (regular expression) 모듈
OS 모듈은 환경 변수나 디렉터리, 파일 등의 OS 자원을 제어할 수 있게 해주는 모듈이다.
matplotlib
https://matplotlib.org/2.0.2/gallery.html



★ scipy.integrate: 수치적분 루틴과 미분방정식 해법기
★ scipy.linalg: numpy.linalg에서 제공하는 것보다 더 확장된 선형대수 루틴과 매트릭스 분해
★ scipy.optimize: 함수 최적화기와 방정식의 근을 구하는 알고리즘
★ scipy.signal: 시그널 프로세싱 도구
★ scipy.sparse: 희소 행렬과 희소 선형 시스템 풀이법
★ scipy.special: 감마 함수처럼 흔히 사용되는 수학 함수를 구현한 포트란 라이브러리인 SPECFUN 확장
★ scipy.stats: 표준 연속/이산 확률 분포(집적도 함수, 샘플러, 연속 분포 함수)와 다양한 통계 테스트, 그리고 좀 더 기술적인 통계 도구
★ scipy.weave: 배열 계산을 빠르게 하기 위해 인라인 C++ 코드를 사용하는 도구

https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf

B. pandas basic
# pandas 의 기본자료구조, Serise, DataFrame
# Serise : 컬럼이 없음, 인덱스만 존재하는 자료구조
# DataFrame: 인덱스와 컬럼이 존재하는 자료구조

s= pd.Series([1,2,3]) # 리스트 또는 배열을 시리즈로 변환, 인덱스는 0,1,2...자동
s= pd.Series(np.array([1,2,3]))
s= pd.Series({'a':5, 'b':6}) # 딕셔너리를 시리즈로 변환, 인덱스는 a, b가 됨
s= pd.Series([1,2,3], index=['a','b','c']) # 인덱스 설정가능
# 시리즈는 index와 value로 구성되어있음.
# 데이터프레임은 index, column, value로 구성

df= pd.DataFrame([2,3,4,5]) 와 df= pd.DataFrame([[2,3,4,5]])의 차이점
df= pd.DataFrame(2, index=[1,2], columns=['갑','을']) # 2*2, 값을 2로 채움
df= pd.DataFrame([[2,3],[4,5]], index=[1,2], columns=['갑','을']) # 2*2 값이 2,3,4,5로 채워짐
a= pd.Series([1,4,np.nan,6]) # 시리즈의 생성
a= pd.date_range('20180830', periods=7) # 날짜형을 연속으로 구성
# 인덱스와 컬럼은 리스트로 부여, values는 스칼라, 리스트 또는 배열가능, 단 리스트일 경우 행열차원이 맞아야함.
df= pd.DataFrame(values, index=dates, columns=cols) 
df= pd.DataFrame({'key':['K0','K4'], 'A':['A0','A1']}) #딕셔너리로 데이터 프레임 생성, 컬럼은 key, A가 되고 index는 디폴트로 0,1,2~
df= pd.DataFrame(a) # 시리즈에서 바로 데이터프레임 생성 , index와 column은 디폴트로 0,1,2~
df=pd.DataFrame(a, index=[1,2,3,4,5], columns=['숫자']) # index와 column 지정
df.head(), df.tail(), df.columns, df.index, 
df.values # ndarray형식으로 나옴
df.info() # 데이터프레임의 개요
df.describe() # 데이터프레임의 통계적 개요 (개수, 평균, 표준편차, 최소/최대, 25%/50%/75% 지점 정보)
df.sort_values(by='B', ascending=False) # B열 기준 내림차순
df.sort_index(ascending= False) # 인덱스 내림차순
df['C'] # 특정컬럼 데이터만 보기 -> 시리즈 형식, 차원축소
df.C # 위와 동일
df[1:3] # (행)슬라이싱, 차원유지
df['2018-08-31':'2018-09-02'] # 인덱스 값을 사용해 (행)슬라이싱
df.loc['2018-08-31'] # location 정보를 옵션으로 하여 슬라이싱 지원->컬럼명이 인덱스가 됨->시리즈형식, 차원축소
df.loc[:,['A','B']] # (열)슬라이싱
df.loc[:,df.columns[:2]] # (열)슬라이싱
df.loc[1:2, ['B','C']] # 안된다.
df.loc['2018-09-01':'2018-09-03', ['B','C']] # 행과열 슬라이싱
df.loc[df.index[2:5], df.columns[1:3]]
df.loc['2018-09-01', ['B','C']] # 차원축소
df.loc['2018-09-01', 'B'] # 인덱싱 2번, 데이터프레임->시리즈->값 (차원축소2번)
df.iloc[1] # 펜시인덱싱방식과 유사, 행과 열의 번호를 이요하여 데이터를 접근
df.iloc[1,2] 와 df.iloc[[1,2]]의 차이점
df.iloc[2:5, 1:3]
df.iloc[[1,4,2],[0,2]] # 통상 슬라이싱은 데이터가 붙어있을때 가능, 인덱스지정이 떨어져있어도(불연속) 지정가능
df.[df.C > 0] # C열 기준 0보다 큰 데이터를 가진 가로열 데이터만 모아서 출력
df.[df > 0] # 조건에 해당되지 않을때 NaN으로 처리
df.copy() 와 df[:] 동일함. 복제 df1=df와 차이점?

# 기존 df에 데이터 추가 df['new_col']= 리스트
# df['new_col']= 시리즈 ? 인덱스가 같으면 가능함?
# 해당컬럼안에 특정값있는지 체크, df['해당컬럼'].isin(['특정값','특정값'])
# 누적합 df.apply(np.cumsum)



# 컬럼 이름바꾸기
df.rename(index={'kim':'A'}, columns={'best':'1'})
# 인덱스 바꾸기
df.reset_index() 아래와 반대되는 개념으로 index를 0,1,2~ 로 만든다.
df1= df.set_index(['c','d']) 하나이상의 칼럼(c,d)을 색인으로 하는 새로운 df를 생성할수있다.
df1= df.reindex(['a','b','c','d']), 새로운 색인 a~d으로 설정한다. 색인값이 비어있다면 Nan또는 새로 추가가능

# NaN값 처리
df['A'].isnull() # df A칼럼에서 nan값을 가지는 항목을 true로 반환
nanIdx = df[df['A'].isnull()].index  # df A칼럼에서 nan값을 가지는 항목의 id를 얻는다.
if nanIdx.any():
    TR.loc[nanIdx, 'A'] = 0 # df['A'].fillna(0)과 동일
df.dropna(subset=['A']) # df A칼럼에서 nan값을 가지는 항목을 삭제한다.
df['A'].fillna(df['A'].median, inplace= True) # df A칼럼에서 nan값을 가지는 항목을 중간값으로 채워넣는다.

# 열 또는 행 제거하기 
df.drop(['E'], inplace=True, axis=1), E열 삭제, 또는 df.drop('E', axis=1) 또는 del df['E']
df.drop(['행1', '행2']) # 디폴트로 axis=0, 행삭제임.

# 데이터프레임 합치기 merge, join, concat
# 각 데이터프레임을 컬럼기준으로 합치기
pd.merge(df1, df2, on='A') # 두개의 df를 공통으로 있는(이름이 동일한) A컬럼을 기준으로 합친다. 교집합
pd.merge(df3, df4, left_on='L', right_on='R') # 두개의 df에 공통컬럼이 없다면 따로 지정해준다. 교집합
pd.merge(df1, df2, on='A', how='outer') # left 기본 교집합에 왼쪽 모든로우를 포함, right, outer 합집합 inner 교지합
pd.merge(df1, df2, on=['A','B'], how='outer') # 여러개의 key로 병합할때는 리스트

# 각 데이터프레임을 인덱스기준으로 합치기
pd.merge(left, right, how='outer', left_index= True, right_index= True)
left2.join(right2, how='outer') # 상기 동일

pd.merge(df1, s.to_frame(), left_index= True, right_index= True) # 기존 df1에 시리즈s를 병합하려면 공통된 인덱스를 기준으로
df1.merge(s.to_frame() .....) # 상기동일, 시리즈를 우선 데이터프레임으로 변환시킨다음 병합시킨다.

pd.merge(df1, s.to_frame(), left_index= True, right_index= True, how='left')
left2.join(right2) # 상기동일, join의 기본값은 left2의 index값을 기준으로 합친다. 왼쪽 우선조인
df1['컬럼']= s # 상기동일, 동일한 키가 아닐경우 NaN값으로 채워진다. df1의 인덱스기준으로 합친다.

# concat
pd.concat([s1,s2,s3]) # concat은 axis=0을 기본값으로 하고 새로운 시리즈 객체를 생성한다.
pd.concat([s1,s2,s3], axis=1) # axis1은 컬럼방향(가로)를 의미한다. 데이터프레임을 생성한다.
pd.concat([s1,s1,s3], keys=['one', 'two', 'three']) # 계층적 색인 생성
pd.concat([s1,s1,s3], axis=1, keys=['one', 'two', 'three']) # keys는 컬럼제목이 된다.
데이터프레임에 대해서도 위와 같은 방식으로 적용가능하다.

# stack과 unstack
stack은 컬럼을 로우로 회전시킨다.
unstack은 로우를 컬럼으로 회전시킨다.

시리즈 map(), apply()
데이터프레임 apply(), applymap(), groupby
applymap은 데이터프레임의 개별값을 인자로 받는다.
apply는 데이터프레임의 시리즈(컬럼)을 인자로 받는다.

# map(), apply()
df['class']= df['class'].map({'Kim':'A', 'Seo':'B', 'Han':'C'}) # 치환
df['A']= df['A'].apply(lambda v:1 if v>=1.3 else 0)
df['C'] df.apply(lambda r:r['A']*r['B'], axis=1) # axis 1은 인덱스방향, 0은 컬럼방향

# applymap() , 데이터프레임 전체 데이터셀에 적용한다.
df.applymap(lambda v: np.log(v) if isinstance(v, float) else v
df.applymap(lambda x: x if not '$' in str(x) else x.replace('$', ''))

# groupby()
df.groupby('A')['B'].mean()
df['B']groupby('A').mean()

정규 표현식
r'\([A-Za-z].+[a-z|\.]\)'

import os, re
os.chdir(r'C:\Users\Administrator\Documents\do-it-python-master\03')
f = open('friends101.txt', 'r')
f.read(100)
f.seek(0)
sentences = f.readlines()
sentences[:3]

for i in sentences[:20]:
    if re.match(r'[A-Z][a-z]+:',i):
        print(i)

lines = [i for i in sentences if re.match(r'[A-Z][a-z]+:', i)]
lines[:10]

take would could go
take = [i for i in sentences if re.match(r'[A-Z][a-z]+:', i) and re.search('take', i)]
take

for i in take:
    print(i)

newf = open('would2.txt', 'w')
newf.writelines(would)
newf.close()


import re

text = """\
010-1234-5678 Kim
011-1234-5678 Lee
016-1234-5678 Han
"""
# flags=re.MULTILINE 지정
text_mod = re.sub('^[0-9]{3}-[0-9]{4}-[0-9]{4}',"***-****-****",text, flags=re.MULTILINE) 
print (text_mod)

text_mod
Out[36]: '***-****-**** Kim\n***-****-**** Lee\n***-****-**** Han\n'

print(text_mod)
***-****-**** Kim
***-****-**** Lee
***-****-**** Han

■ usecsv
total = usecsv.opencsv('popSeoul.csv')	

# 콤마 등을 제거하는 함수 usecsv.switch를 사용합니다. 
newPop = usecsv.switch(total)	

■ Game 제작
https://m.blog.naver.com/jsk6824/222089416358


데이터 사이언스 스쿨
https://datascienceschool.net/index.html