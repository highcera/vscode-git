https://pybo.kr

질문과 답변 서비스 "디스코드" - https://discord.gg/ZwqRRYRYkR


https://github.com/pahkey/jump2flask


[파일명: C:/venvs/myproject.cmd]
@echo off
cd c:/projects/myproject
set FLASK_APP=pybo
set FLASK_DEBUG=true
c:/venvs/myproject/scripts/activate

vscode > terminal 경우 반드시 command mode

애플리케이션 팩토리
[파일명: projects\myproject\pybo\__init__.py]
from flask import Flask

def create_app():
    app = Flask(__name__)

    @app.route('/')
    def hello_pybo():
        return 'Hello, Pybo!'

    return app


블루프린트 (라우팅 함수 관리)
[파일명: projects/myproject/pybo/views/main_views.py]
from flask import Blueprint

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/')
def hello_pybo():
    return 'Hello, Pybo!'


[파일명: projects/myproject/pybo/__init__.py]
from flask import Flask

def create_app():
    app = Flask(__name__)

    from .views import main_views
    app.register_blueprint(main_views.bp)

    return app


모델로 데이터 처리하기
ORM(object relational mapping)
pip install flask-migrate

Collecting Flask-Migrate
(... 생략 ...)
설정 파일 추가하기
파이보에 ORM을 적용하려면 데이터베이스 설정이 필요하다. 루트 디렉터리에 config.py 파일을 생성하고 다음과 같은 코드를 작성하자.

[파일명: projects/myproject/config.py]
import os

BASE_DIR = os.path.dirname(__file__)

SQLALCHEMY_DATABASE_URI = 'sqlite:///{}'.format(os.path.join(BASE_DIR, 'pybo.db'))
SQLALCHEMY_TRACK_MODIFICATIONS = False

SQLALCHEMY_DATABASE_URI는 데이터베이스 접속 주소이고 SQLALCHEMY_TRACK_MODIFICATIONS는 SQLAlchemy의 이벤트를 처리하는 옵션이다. 이 옵션은 파이보에 필요하지 않으므로 False로 비활성화하자. 
SQLALCHEMY_DATABASE_URI 설정에 의해 SQLite 데이터베이스가 사용되고 데이터베이스 파일은 프로젝트 홈 디렉터리 바로 밑에 pybo.db 파일로 저장된다.

[파일명: projects/myproject/pybo/__init__.py]

from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy

import config

db = SQLAlchemy()
migrate = Migrate()


def create_app():
    app = Flask(__name__)
    app.config.from_object(config)

    # ORM
    db.init_app(app)
    migrate.init_app(app, db)

    # 블루프린트
    from .views import main_views
    app.register_blueprint(main_views.bp)

    return app


데이터베이스 초기화하기
이제 ORM을 사용할 준비가 되었으므로 flask db init 명령으로 데이터베이스를 초기화하자.

(myproject) c:\projects\myproject>flask db init (← 최초 1회 실행)
Creating directory c:\projects\myproject\migrations ...  done
Creating directory c:\projects\myproject\migrations\versions ...  done
Generating c:\projects\myproject\migrations\alembic.ini ...  done
Generating c:\projects\myproject\migrations\env.py ...  done
Generating c:\projects\myproject\migrations\README ...  done
Generating c:\projects\myproject\migrations\script.py.mako ...  done
Please edit configuration/connection/logging settings in 'c:\\projects\\myproject\\migrations\\alembic.ini' before proceeding.
flask db init 명령은 데이터베이스를 관리하는 초기 파일들을 다음처럼 migrations 디렉터리에 자동으로 생성한다.

[파일명: projects/myproject/pybo/models.py]
from pybo import db

class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)

class Answer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
    question = db.relationship('Question', backref=db.backref('answer_set'))
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)


[파일명: projects/myproject/pybo/__init__.py]
(... 생략 ...)
    # ORM
    db.init_app(app)
    migrate.init_app(app, db)
    from . import models
(... 생략 ...)

리비전 파일 생성하기
(myproject) c:\projects\myproject> flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected added table ‘question’
INFO [alembic.autogenerate.compare] Detected added table ‘answer’
Generating c:\projects\myproject\migrations\versions\18634a293520_.py ... done
이 명령을 수행하면 18634a293520_.py처럼 데이터베이스 변경 작업을 위한 리비전 파일이 생성

리비전 파일 실행하기
이어서 flask db upgrade 명령으로 만들어진 리비전 파일을 실행하자. (리비전 파일 내에는 테이블 생성을 위한 쿼리문들이 저장되어 있다.)

(myproject) c:\projects\myproject> flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade -> 18634a293520, empty message

데이터베이스에 모델 이름과 똑같은 question과 answer 테이블 생성
projects/myproject 디렉터리에 pybo.db 파일 생성

생성된 테이블 살펴보기
DB Browser for SQLite
 [파일 → 데이터베이스 열기] projects/myproject/pybo.db
* alembic_version 테이블 : Flask-Migrate 라이브러리가 데이터베이스를 변경·관리에 사용하는 테이블

모델 사용하기
모델도 만들었고 모델을 기반으로 테이블도 생성했으니 이제 모델을 사용할 차례다.

플라스크 셸 실행하기
명령 프롬프트에서 flask shell 명령으로 실행

(myproject) c:\projects\myproject>flask shell
Python 3.8.5 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32
App: pybo [development]
Instance: C:\projects\myproject\instance
>>> 
리
질문 저장하기
다음처럼 Question 모델 객체를 하나 생성하자.
>>> from pybo.models import Question, Answer
>>> from datetime import datetime
>>> q = Question(subject='pybo가 무엇인가요?', content='pybo에 대해서 알고 싶습니다.', create_date=datetime.now())

>>> from pybo import db
>>> db.session.add(q)
>>> db.session.commit()


데이터가 잘 생성되었는지 확인해 보자.
>>> q.id
1
id는 Question 모델의 기본 키다. id는 앞에서 모델을 생성할 때 설정했던대로 데이터를 생성할 때 속성값이 자동으로 1씩 증가한다. 정말 그런지 두 번째 질문 데이터를 생성한 후 id를 확인해 보자.

>>> q = Question(subject='플라스크 모델 질문입니다.', content='id는 자동으로 생성되나요?', create_date=datetime.now())
>>> db.session.add(q)
>>> db.session.commit()
>>> q.id
2
결과를 보면 두 번째 질문 데이터의 id는 예상대로 2가 출력됐다.

점프 투 플라스크
커밋(commit)과 롤백(rollback)
커밋은 취소할 수 없다는 점에 유의하자. 커밋은 일종의 "결정사인" 역할을 한다고 생각하면 이해하기 쉽다. 그래서 수행한 작업을 취소하려면 커밋 이전에 진행해야 한다. 이때 작업을 취소하고 싶으면 db.session.rollback()으로 되돌리기(롤백)를 실행하면 된다.

데이터 조회하기
이번에는 데이터베이스에 저장된 데이터를 조회해 보자.

>>> Question.query.all()
[<Question 1>, <Question 2>]
Question.query.all()로 데이터베이스에 저장된 질문을 전부 조회했다. 결과에서 보이는 숫자 1과 2는 Question 객체의 id 속성값이다.

이번에는 filter 함수를 이용해 첫 번째 질문만 조회해 보자.

>>> Question.query.filter(Question.id==1).all()
[<Question 1>]
filter 함수는 인자로 전달한 조건에 맞는 데이터를 찾아서 반환한다. 여기서는 기본 키인 id를 이용했으므로 값을 1개만 반환한다.

id는 유일한 값이므로 filter 함수 대신 get 함수를 이용해 조회할 수도 있다.

>>> Question.query.get(1)
<Question 1>
다만 get 함수의 리턴은 단 1건만 가능하므로 리스트가 아닌 Question 객체가 리턴된다.

이번에는 filter와 like로 제목에 "플라스크"라는 문자열이 포함된 질문을 조회해 보자.

>>> Question.query.filter(Question.subject.like('%플라스크%')).all()
[<Question 2>]
"플라스크"라는 문자열이 포함된 두 번째 질문이 조회되었다. filter 함수에 전달한 Question.subject.like('%플라스크%') 코드의 의미는 Question 모델 subject 속성에 "플라스크"라는 문자열이 포함되는가?"이다. 이때 like 함수에 전달한 문자열에 붙은 % 표기는 다음과 같은 의미를 갖는다.

플라스크%: "플라스크"로 시작하는 문자열
%플라스크: "플라스크"로 끝나는 문자열
%플라스크%: "플라스크"를 포함하는 문자열
대소 문자 구분하지 않고 문자열을 찾으려면 like 함수 대신 ilike 함수를 사용한다.

데이터를 조회하는 다양한 사용법은 SQLAlchemy공식 문서를 참조하자.

SQLAlchemy 공식 문서: https://docs.sqlalchemy.org/en/13/orm/query.html
데이터 수정하기
이번에는 질문 데이터를 수정해 보자. 데이터를 수정할 때는 단순히 대입 연산자를 사용하면 된다.

>>> q = Question.query.get(2)
>>> q
<Question 2>
>>> q.subject = 'Flask Model Question'
>>> db.session.commit()
두 번째 질문을 조회한 다음 subject 속성을 수정했다. 앞에서 설명했듯이 데이터를 변경한 후에는 반드시 커밋을 수행해야 데이터베이스에 반영된다.

데이터 삭제하기
이어서 데이터를 삭제하는 것도 실습해 보자. 여기서는 첫 번째 질문을 삭제하자.

>>> q = Question.query.get(1)
>>> db.session.delete(q)
>>> db.session.commit()
첫 번째 질문을 조회한 다음 delete 함수를 이용해 삭제했다. 삭제도 역시 커밋이 필요하다.

이어서 실제로 데이터베이스에서 첫 번째 질문이 삭제되었는지 확인해 보자.

>>> Question.query.all()
[<Question 2>]
첫 번째 질문이 삭제되어서 두 번째 질문만 남아 있는 것을 확인할수 있다.

답변 데이터 저장하기
이번에는 답변(Answer)을 생성하고 저장해 보자.

>>> from datetime import datetime
>>> from pybo.models import Question, Answer
>>> from pybo import db
>>> q = Question.query.get(2)
>>> a = Answer(question=q, content='네 자동으로 생성됩니다.', create_date=datetime.now())
>>> db.session.add(a)
>>> db.session.commit()
답변을 생성하려면 연결할 질문이 필요하므로 우선 질문을 조회했다. id가 2인 질문을 조회하여 q 객체에 저장했다. 그런 다음 Answer 모델의 question 속성에 방금 조회한 q 객체를 대입해 답변을 생성했다.

Answer 모델에는 어떤 질문에 해당하는 답변인지 연결할 목적으로 question_id 속성이 있다. Answer 모델의 객체를 생성할 때 question에 q를 대입하면 question_id에 값을 지정하지 않아도 자동으로 입력되어 저장된다. 따라서 question_id에 값을 설정할 필요가 없다.

Answer도 Question 모델과 마찬가지로 id 속성이 기본 키이므로 값이 자동으로 생성된다. 다음 명령으로 id값을 확인해 보고 이 값을 이용해 데이터도 조회해 보자.

>>> a.id
1
>>> a = Answer.query.get(1)
>>> a
<Answer 1>
답변에 연결된 질문 찾기 vs 질문에 달린 답변 찾기
Answer 모델의 question 속성을 이용하면 "답변에 연결된 질문"을 조회할 수 있다.

>>> a.question
<Question 2>
답변에 연결된 질문 찾기는 Answer 모델에 question 속성이 정의되어 있어서 매우 쉽다. 그런데 반대의 경우도 가능할까? 즉, 질문에서 답변을 찾을수 있을까?

Question 모델과 Answer 모델은 현재 연결된 상태이고, Answer 모델의 question 속성에 역참조 설정 backref=db.backref('answer_set')이 적용되어 있다. 그러므로 이를 사용하면 질문에 연결된 답변들을 쉽게 가져올 수 있다.

>>> q.answer_set
[<Answer 1>]
지금 여러분은 역참조의 유용함을 별로 느끼지 못할 것이다. 하지만 이 기능은 개발자에게 큰 편의를 가져다주는 신통방통한 녀석이다. 앞으로도 자주 사용할 예정이니 꼭 기억해 두자.

플라스크 셸 종료 - <Ctrl+Z><Enter> or quit()

--------------------------------------------------
2-05 질문 목록과 질문 상세 기능 만들기
이번 장에서는 파이보의 핵심 기능인 질문 목록과 질문 상세 기능을 구현해 보자.

질문 목록 만들기
플라스크 서버를 실행하고 웹 브라우저에서 localhost:5000에 접속해 보자. 지금까지 실습을 잘 따라 했다면 화면에 "Pybo index"라는 문구가 출력될 것이다.

게시판 질문 목록 출력하기
[파일명: projects/myproject/pybo/views/main_views.py]

from flask import Blueprint, render_template
from pybo.models import Question

(...생략...)

@bp.route('/')
def index():
    question_list = Question.query.order_by(Question.create_date.desc())
    return render_template('question/question_list.html', question_list=question_list)


질문 목록 템플릿 작성하기

이제 render_template 함수에서 사용할 question/question_list.html 템플릿 파일을 작성해야 한다. 그런데 이 파일은 어디에 저장해야 할까? 
바로 플라스크가 앱으로 지정한 모듈 아래에 templates라는 디렉터리에 저장하면 된다. 
그러면 별다른 설정을 하지 않아도 temptates 디렉터리를 템플릿 디렉터리로 인식한다. 다음 명령으로 pybo 앱 디렉터리 아래에 templates 디렉터리를 생성하자.

(myproject) c:\projects\myproject> cd pybo
(myproject) c:\projects\myproject\pybo> mkdir templates

[파일명: projects/myproject/pybo/templates/question/question_list.html]
<!-- 질문 목록 -->
{% if question_list %}
    <ul>
    {% for question in question_list %}
        <li><a href="/detail/{{ question.id }}/">{{ question.subject }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>질문이 없습니다.</p>
{% endif %}


질문 상세 기능 만들기
http://localhost:5000/detail/2/

[파일명: projects/myproject/pybo/views/main_views.py]
(...생략...)
@bp.route('/detail/<int:question_id>/')
def detail(question_id):
    question = Question.query.get(question_id)
    return render_template('question/question_detail.html', question=question)

detail 함수의 매개변수 question_id에는 URL 매핑 규칙에 사용한 <int:question_id>가 전달된다. 
즉, http://localhost:5000/detail/[[MARK]]2[[/MARK]]/ 페이지를 요청하면 main_views.py 파일의 detail 함수가 실행되고, 매개변수 question_id에는 2라는 값이 전달된다.

URL 매핑 규칙에 있는 int는 question_id에 숫자값이 매핑됨을 의미한다.

질문 상세 템플릿 작성하기
이어서 질문 상세 화면에 해당하는 question/question_detail.html 템플릿을 작성하자. templates/question 디렉터리에 question_detail.html 파일을 만들고 다음 코드를 작성하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>

{{ question.subject }}와 {{ question.content }}의 question은 render_template 함수에 전달한 질문 객체이다. 
이제 웹 브라우저에서 http://localhost:5000/detail/2/ 페이지를 다시 요청해 보자. 그러면 question_id가 2인 질문의 제목과 내용이 표시된다.

404 오류 페이지 표시하기

이번에는 웹 브라우저에서 http://localhost:5000/detail/30/ 페이지를 요청해 보자. 그러면 빈 페이지(아무것도 보이지 않는 하얀 화면)가 나타날 것이다.

왜냐하면 detail 함수가 전달받은 question_id가 30이므로 Question.query.get(30)이 호출되는데 question_id가 30인 질문은 없기 때문이다. 
그런데 이처럼 잘못된 URL을 요청받을 때 단순히 빈 페이지를 표시하면 안된다. 이때는 보통 "Not Found (404)"처럼 오류 페이지를 표시해야 한다. 404는 HTTP 주요 응답 코드의 하나이다. 
아래 표에서 HTTP 주요 응답 코드의 종류를 확인하자.

응답 코드	설명
200	성공(OK)
500	서버 오류(Internal Server Error)
404	서버가 요청한 페이지 없음(Not Found)
존재하지 않는 페이지를 요청받으면 빈 페이지 대신 404 오류 페이지를 표시하도록 다음처럼 detail 함수의 일부를 수정해 보자.

[파일명: projects/myproject/pybo/views/main_views.py]

(...생략...)

@bp.route('/detail/<int:question_id>/')
def detail(question_id): 
    question = Question.query.get_or_404(question_id)   
    return render_template('question/question_detail.html', question=question)

기존 코드에서 get 함수 대신 get_or_404 함수를 사용했다. get_or_404 함수는 해당 데이터를 찾을 수 없는 경우에 404 페이지를 출력해 준다. 
이제 웹 브라우저에서 http://localhost:5000/detail/30/ 페이지를 다시 요청하면 404 오류 페이지가 출력된다.

블루프린트로 기능 분리하기
지금까지는 질문 목록과 질문 상세 기능을 main_views.py 파일에 구현했다. 모든 기능을 main_views.py 파일에 구현할 수도 있지만, 각 기능을 블루프린트 파일로 분리해서 관리하면 유지·보수하는 데 유리하다.

질문 목록, 질문 상세 기능 분리하기

pybo/views 디렉터리에 question_views.py 파일을 새로 만들고 질문 목록과 질문 상세 기능을 이동해 보자.

[파일명: projects/myproject/pybo/views/question_views.py]
from flask import Blueprint, render_template
from pybo.models import Question
bp = Blueprint('question', __name__, url_prefix='/question')

@bp.route('/list/')
def _list():
    question_list = Question.query.order_by(Question.create_date.desc())
    return render_template('question/question_list.html', question_list=question_list)

@bp.route('/detail/<int:question_id>/')
def detail(question_id):
    question = Question.query.get_or_404(question_id)
    return render_template('question/question_detail.html', question=question) 

[파일명: projects/myproject/pybo/__init__.py]
(...생략...)

def create_app():
    (...생략...)

    # 블루프린트
    from .views import main_views, question_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)

    (...생략...)

url_for로 리다이렉트 기능 추가하기
question_views.py 파일에 질문 목록과 질문 상세 기능을 구현했으므로 main_views.py 파일에서는 해당 기능을 제거하자.

[파일명: projects/myproject/pybo/views/main_views.py]

from flask import Blueprint, url_for
from werkzeug.utils import redirect

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/hello')
def hello_pybo():
    return 'Hello, Pybo!'

@bp.route('/')
def index():
    return redirect(url_for('question._list'))

detail 함수는 제거하고 index 함수는 question._list에 해당하는 URL로 리다이렉트(redirect)하도록 코드를 수정했다. redirect 함수는 입력받은 URL로 리다이렉트하고, url_for 함수는 라우팅 함수명으로 URL을 역으로 찾는 함수이다.

redirect(URL) - URL로 페이지를 이동
url_for(라우팅 함수명) - 라우팅 함수에 매핑되어 있는 URL을 리턴
url_for 함수에 전달된 question._list는 question, _list 순서로 해석되어 라우팅 함수를 찾는다. question은 등록된 블루프린트 별칭, _list는 블루프린트에 등록된 함수명이다. 
따라서 question._list는 question이라는 별칭으로 등록한 question_views.py 파일의 _list 함수를 의미한다. 
그리고 _list 함수에 등록된 URL 매핑 규칙은 @bp.route('/list/')이므로 url_for('question._list')는 bp의 프리픽스 URL인 /question/과 /list/가 더해진 /question/list/ URL을 반환한다.

이제 http://localhost:5000에 접속하면 리다이렉트 기능 덕분에 localhost:5000/question/list/ 페이지가 호출될 것이다. 확인해 보자.

하드 코딩된 URL에 url_for 함수 이용하기
앞서 url_for 함수를 이용하면 라우팅 함수명으로 URL을 찾아준다고 했다. 이 기능을 이용해 질문 목록에서 질문 상세를 호출하는 링크도 url_for를 사용하도록 해보자.

[파일명: C:/projects/myproject/pybo/templates/question/question_list.html]

<!-- 질문 목록 -->
{% if question_list %}
    <ul>
    {% for question in question_list %}
        <li><a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>질문이 없습니다.</p>
{% endif %}

기존에는 상세 페이지로 연결하는 링크가 /detail/{{ question.id }}/ 처럼 하드 코딩되어 있었다. 이 부분을 url_for 함수를 이용해 question.detail 라우팅 함수로 URL을 찾도록 변경했다. 
이때 question.detail 함수는 question_id 매개변수가 필요하므로 question_id를 전달해야 한다.

이제 질문 목록에서 제목을 누르면 상세 페이지로 잘 이동할 것이다.

점프 투 플라스크
url_for 함수를 사용하면 유지·보수하기 쉬워진다
템플릿에서 URL을 사용할 때 다음과 같이 url_for를 사용하지 않으면 어떻게 될까?

<a href="/question/detail/{{ question.id }}">{{question.subject}}</a>
이렇게 URL을 하드 코딩하면 유지·보수하는 데 불리하다. 예를 들어 다음처럼 URL 구성 방식 자체가 변경되면 이런 코드는 쉽게 대응하기 어렵다.

localhost:5000/detail/question/2
localhost:5000/detail/2/question
실제 프로젝트에서 URL 리팩토링은 빈번하게 발생한다.

이와 같이 URL 구성 방식을 자주 변경하면 템플릿에서 사용한 모든 URL을 일일이 찾아가며 수정해야 할 것이다. 이런 부담을 줄이고 싶다면 url_for 함수를 사용하기를 추천한다.

---------------------------------
2-06 답변 등록 기능 만들기

[완성 소스] : github.com/pahkey/jump2flask/tree/2-06
[실습 영상] : https://youtu.be/767Sl_tv0ks
앞 장에서 우리는 질문을 조회하는 기능을 만들었다. 이번에는 질문에 답변을 등록하고 보여 주는 기능을 만들어 보자.

답변 저장하기
질문 상세 화면에 답변을 입력하기 위한 텍스트 창(textarea)과 <답변등록> 버튼을 생성하고, 이 버튼을 누르면 텍스트 창에 입력된 답변이 저장되도록 구현해 보자.

답변 등록 버튼 만들기
질문 상세 템플릿에 답변 저장을 위한 form, textarea, input 엘리먼트를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>
<form action="{{ url_for('answer.create', question_id=question.id) }}" method="post">
    <textarea name="content" id="content" rows="15"></textarea>
    <input type="submit" value="답변등록">
</form>

답변 블루프린트 만들기
앞에서 질문을 관리하는 블루프린트를 만들었듯이, 답변을 관리하는 블루프린트를 만들어 보자. views 디렉터리에 answer_views.py 파일을 만들고 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/views/answer_views.py]
from datetime import datetime

from flask import Blueprint, url_for, request
from werkzeug.utils import redirect

from pybo import db
from pybo.models import Question, Answer

bp = Blueprint('answer', __name__, url_prefix='/answer')

@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    question = Question.query.get_or_404(question_id)
    content = request.form['content']
    answer = Answer(content=content, create_date=datetime.now())
    question.answer_set.append(answer)
    db.session.commit()
    return redirect(url_for('question.detail', question_id=question_id))

bp.route 애너테이션
create 함수의 매개변수 question_id는 URL 매핑 규칙을 통해 전달된다. 만약 http://locahost:5000/answer/create/[[MARK]]2[[/MARK]]/ 페이지를 요청받으면 question_id에는 2가 넘어온다. 
그리고 @bp.route의 methods 속성에는 'POST'를 지정했다. 답변을 저장하는 질문 상세 템플릿의 form 엘리먼트가 POST 방식이므로 같은 값을 지정해야 한다. 만약 @bp.route에 똑같은 폼 방식을 지정하지 않으면 다음과 같은 오류가 발생하므로 주의하자.

methods 속성은 웹 브라우저에서 요청하는 GET 또는 POST와 같은 폼 방식을 의미한다.

create 함수
템플릿의 form 엘리먼트를 통해 전달된 데이터들은 create 함수에서 request 객체로 얻을 수 있다. request.form['content'] 코드는 POST 폼 방식으로 전송된 데이터 항목 중 name 속성이 content인 값을 의미한다. 그리고 question.answer_set은 "질문에 달린 답변들"을 의미한다. 앞에서 Question과 Answer 모델이 연결되어 있어 backref에 설정한 answer_set를 사용할 수 있다고 설명했던 내용을 기억하자. 그리고 답변을 생성한 후 화면을 상세 화면으로 이동하도록 redirect 함수를 사용했다.

점프 투 플라스크
답변을 저장하는 방법은 한 가지만 있을까?
아니다. 다음처럼 Answer 모델을 직접 사용해도 답변을 저장할 수 있다. 이번 실습 코드와 다음 코드 중 어떤 것을 사용해도 결과는 같다.


[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime

from flask import Blueprint, url_for, request
from werkzeug.utils import redirect

from pybo import db
from pybo.models import Question, Answer

bp = Blueprint('answer', __name__, url_prefix='/answer')


@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    question = Question.query.get_or_404(question_id)
    content = request.form['content']
    answer = Answer(question=question, content=content, create_date=datetime.now())
    db.session.add(answer)
    db.session.commit()
    return redirect(url_for('question.detail', question_id=question_id))

점프 투 플라스크
request 객체는 무엇일까?
request 객체는 플라스크에서 생성 과정 없이 사용할 수 있는 기본 객체다. 플라스크는 브라우저의 요청부터 응답까지의 처리 구간에서 request 객체를 사용할 수 있게 해준다. 이 객체를 이용해 브라우저에서 요청한 정보를 확인할 수 있다.

request 객체 외에 g라는 객체도 알아야 하는데 g는 조금 후에 알아보기로 하자.

답변 블루프린트 등록하기
위에서 생성한 답변 블루프린트를 pybo/__init__.py 파일에 등록하자.

[파일명: projects/myproject/pybo/__init__.py]

(...생략...)

def create_app():
    (...생략...)

    # 블루프린트
    from .views import main_views, question_views, answer_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)
    app.register_blueprint(answer_views.bp)

    return app

이제 질문 상세 페이지에 다시 접속해 보자. 그러면 다음처럼 답변을 등록할 수 있는 창과 등록 버튼이 보인다.
화면이 엉성해 보이지만 조금만 참자. 다음 절에서 화면을 깔끔하게 만드는 방법도 설명한다.

텍스트 창에 아무 값이나 입력하고 <답변등록>을 눌러 보자. 하지만 아무런 변화가 없을 것이다. 왜냐하면 우리는 아직 등록한 답변을 표시하는 기능을 추가하지 않았기 때문이다.

답변 표시하기
이번에는 질문에 등록된 답변을 화면에 표시해 보자. 답변은 등록된 질문 밑에 보여야 하므로 질문 상세 템플릿에 다음 코드를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>
<h5>{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
<div>
    <ul>
    {% for answer in question.answer_set %}
        <li>{{ answer.content }}</li>
    {% endfor %}
    </ul>
</div>
<form action="{{ url_for('answer.create', question_id=question.id) }}" method="post">
    <textarea name="content" id="content" rows="15"></textarea>
    <input type="submit" value="답변등록">
</form>

기존 코드에서 답변을 확인할 수 있는 영역을 추가했다. {{ question.answer_set|length }} 코드는 답변 개수를 의미한다. length는 템플릿 필터인데 객체의 길이를 반환해 준다. 이처럼 템플릿 필터는 | 문자 뒤에 추가해서 사용한다.

이와 같이 수정하고 질문 상세 페이지를 새로 고침하면 이제 등록한 답변들이 보인다.
축하한다! 이제부터 여러분은 답변을 저장하고 또 볼 수 있게 되었다.


2-07 화면 예쁘게 꾸미기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-07
[실습 영상] : https://youtu.be/KsBfPE5q1PU

지금까지 질문과 답변을 등록하고 조회하는 기능을 만들었다. 그런데 그럴싸한 화면이 아니라서 아쉽다. 이번에는 스타일시트를 이용해 웹 페이지에 디자인을 적용하는 방법에 대해서 알아보자.

웹 페이지에 디자인을 적용하려면 CSS를 사용해야 한다. CSS를 파이보에 적용하려면 CSS 파일이 pybo/static 디렉터리에 있어야 한다. 이때 CSS 파일은 플라스크에서 정적(static) 파일로 분류한다. 정적 파일은 주로 이미지(.png, .jpg)나 자바스크립트(.js), 스타일시트(.css)와 같은 파일을 의미한다.

static 디렉터리 만들고 스타일시트 작성하기
질문 상세 화면에 스타일시트 적용하기
static 디렉터리 만들고 스타일시트 작성하기
정적 파일을 저장할 디렉터리는 템플릿 디렉터리와 마찬가지로 플라스크가 앱으로 지정한 모듈 아래에 static이라는 이름으로 생성하면 된다. 우리가 사용한 플라스크 앱은 pybo 모듈이므로 pybo 디렉터리 아래에 static 디렉터리를 생성하자.

(myproject) c:\projects\myproject> cd pybo
(myproject) c:\projects\myproject\pybo> mkdir static
static 디렉터리를 만들었으면 그곳에 style.css 파일을 만들고 다음과 같은 코드를 작성하자.

[파일명: projects/myproject/pybo/static/style.css]

textarea {
    width:100%;
}
input[type=submit] {
    margin-top:10px;
}
style.css 파일은 질문 상세 페이지에 사용할 목적으로 작성했다. 답변을 등록할 때 사용하는 텍스트 창(textarea)의 너비를 100%로 넓히고, <답변등록> 버튼 위에 마진을 10px 추가했다. 여기서 텍스트 창에 지정한 너비 100%란 웹 브라우저 너비를 기준으로 한다. 즉, 웹 브라우저의 너비에 따라서 텍스트 창의 크기가 꽉 차도록 조절된다.

질문 상세 화면에 스타일시트 적용하기
이제 작성한 스타일시트를 질문 상세 화면에 적용해 보자. question_detail.html 파일을 열고 가장 위쪽에 다음의 코드 한 줄을 추가하면 된다.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
<h1>{{ question.subject }}</h1>
(...생략...)
추가한 코드는 static 디렉터리의 style.css 파일을 연결한다는 의미다. 그리고 url_for 함수는 앞에서 배운 URL 추적 함수다. 앞에서는 url_for가 라우팅 함수의 URL을 찾아준다고 했지만 정적 파일의 URL도 찾아준다.
이제 질문상세 화면이 어떻게 변경되었는지 확인해 보자.
텍스트 창이 넓어지고 <답변등록> 버튼 위에 여유 공간이 생겼다.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-08 부트스트랩으로 더 쉽게 화면 꾸미기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-08
[실습 영상] : https://youtu.be/ycMgH8Fo4KU

웹 디자이너 없이 웹 프로그램을 만들다 보면 화면 디자인 작업을 하는 데 얼마나 많은 시간과 고민이 필요한지 알 수 있을 것이다. 이번에 소개하는 부트스트랩(Bootstrap)은 개발자 혼자서도 화면을 괜찮은 수준으로 만들 수 있게 도와주는 도구다. 부트스트랩은 트위터를 개발하면서 만들어졌고 지속적으로 관리되고 있는 오픈소스 프로젝트이다.

파이보에 부트스트랩을 적용해 멋진 모습으로 변신해 보자.
부트스트랩 다운로드 - https://getbootstrap.com/docs/5.1/getting-started/download/

점프 투 플라스크
부트스트랩 주의사항
부트스트랩은 3.x, 4.x, 5.x 등의 버전이 존재하고 메이저 번호(3, 4, 5)에 따라 그 사용방법이 다르다. 이 책은 부트스트랩 버전 5 기준으로 실습을 진행한다. 다른 부트스트랩 버전을 사용하면 이 책의 예제가 정상 동작하지 않는다.

부트스트랩 다운로드 페이지 접속후 "Download" 버튼을 누르면 다음과 같은 파일이 다운로드 된다.
bootstrap-5.1.3-dist.zip
이 책을 작성하는 시점의 부트스트랩 최신 버전은 5.1.3 이다. 압축파일 안에는 많은 파일들이 있는데 이 중에서 bootstrap.min.css 파일을 카피하여 스태틱 디렉터리에 저장하자.

구분	파일 위치
압축파일내 경로	bootstrap-5.1.3-dist.zip\bootstrap-5.1.3-dist\css\bootstrap.min.css
카피할 경로	projects\myproject\pybo\static\bootstrap.min.css
나중에 진행되는 챕터에서 bootstrap.min.js 파일도 필요하니 bootstrap-5.1.3-dist.zip 파일을 삭제하지 말자.

질문 목록에 부트스트랩 적용하기
질문 목록에 부트스트랩을 적용해 보자. question_list.html 파일 맨 위에 있는 bootstrap.min.css 파일을 연결하는 것을 시작으로 전체를 수정해야 한다.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
<div class="container my-3">
    <table class="table">
        <thead>
        <tr class="table-dark">
            <th>번호</th>
            <th>제목</th>
            <th>작성일시</th>
        </tr>
        </thead>
        <tbody>
        {% if question_list %}
        {% for question in question_list %}
        <tr>
            <td>{{ loop.index }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date }}</td>
        </tr>
        {% endfor %}
        {% else %}
        <tr>
            <td colspan="3">질문이 없습니다.</td>
        </tr>
        {% endif %}
        </tbody>
    </table>
</div>

기존 질문 목록은 ul 엘리먼트로 간단히 표시했지만 여기서는 table 엘리먼트로 표현했다. table 태그와 하위 태그들에 부트스트랩을 적용했는데, 여기에 사용된 class="container my-3", class="table", class="table-dark" 등이 바로 부트스트랩이 제공하는 클래스다.

앞으로 다른 화면을 만들 때도 부트스트랩을 사용할 것이다. 그러나 이 책의 주제가 부트스트랩은 아니므로 간단히 설명한다. 혹시 자세한 내용이 궁금하다면 부트스트랩 공식 문서를 읽어 보기를 권한다.

부트스트랩 공식 문서: * https://getbootstrap.com/docs/5.1/getting-started/introduction/
이제 웹 브라우저에서 http://localhost:5000/question/list에 접속하면 부트스트랩이 적용된 질문 목록 화면을 볼 수 있다.


질문 상세에 부트스트랩 적용하기

[파일명: projects/myproject/pybo/templates/question_detail.html]
<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
<div class="container my-3">
    <!-- 질문 -->
    <h2 class="border-bottom py-2">{{ question.subject }}</h2>
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ question.create_date }}
                </div>
            </div>
        </div>
    </div>
    <!-- 답변 목록 -->
    <h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
    {% for answer in question.answer_set %}
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ answer.create_date }}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}
    <!-- 답변 등록 -->
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        <div class="mb-3">
            <textarea name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
    </form>
</div>

이번에는 수정사항이 좀 많다. 부트스트랩으로 화면을 구성하다 보면 가끔은 이렇게 많은 양의 HTML코드를 작성해야 한다. 질문이나 답변은 하나의 뭉치에 해당하므로 부트스트랩의 card 컴포넌트를 사용했다.

부트스트랩 card 컴포넌트 : https://getbootstrap.com/docs/5.1/components/card/

질문 상세 템플릿에 사용한 부트스트랩 클래스를 다음처럼 표로 정리하였다.

부트스트랩 클래스	설명
card, card-body, card-text	부트스트랩 Card 컴포넌트
badge	부트스트랩 Badge 컴포넌트
form-control, form-label	부트스트랩 Form 컴포넌트
border-bottom	아래방향 테두리 선
my-3	상하 마진값 3
py-2	상하 패딩값 2
p-2	상하좌우 패딩값 2
d-flex justify-content-end	컴포넌트의 우측 정렬
bg-light	연회색 배경
text-dark	검은색 글씨
text-start	좌측 정렬
btn btn-primary	부트스트랩 버튼 컴포넌트
그리고 질문 내용과 답변 내용에는 style="white-space: pre-line;" 스타일을 지정해 주었다. 
글 내용의 줄 바꿈을 정상적으로 보여주기위해 적용한 스타일이다.


2-09 표준 HTML과 템플릿 상속 사용해 보기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-09
[실습 영상] : https://youtu.be/RMAv052dcSM

혹시 눈치챘는지 모르겠지만 우리가 지금까지 작성한 질문 목록과 질문 상세 템플릿 파일은 표준 HTML 구조가 아니다. 어떤 운영체제나 브라우저를 사용하더라도 웹 페이지가 동일하게 보이고 정상적으로 동작하게 하려면 반드시 웹 표준을 지키는 HTML 문서를 작성해야 한다.

표준 HTML 구조는 어떻게 생겼을까?
표준 HTML 문서의 구조는 다음과 같아야 한다.

[표준 HTML 구조의 예]
<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
    <!-- pybo CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Hello, pybo!</title>
</head>
<body>
(... 생략 ...)
</body>
</html>

표준 HTML 문서의 구조는 위와 같이 html, head, body 엘리먼트가 있어야 하고 CSS 파일 링크는 head 엘리먼트 안에 있어야 한다. 또한 head 엘리먼트 안에는 meta, title 엘리먼트 등이 포함되어야 한다.

점프 투 플라스크
**태그와 엘리먼트 **
<table> (... 생략 ...) </table>  <!-- table 엘리먼트 -->
위에서 <table>은 table 태그이고 <table> ~ </table> 처럼 table 태그로 시작해서 table 태그로 닫힌 구간(Block)은 table 엘리먼트이다.

템플릿을 표준 HTML 구조로 바꾸기
앞에서 작성한 질문 목록, 질문 상세 템플릿을 표준 HTML 구조가 되도록 수정해 보자. 그런데 템플릿 파일들을 모두 표준 HTML 구조로 변경하면 body 엘리먼트 바깥 부분(head 엘리먼트 등)은 모두 같은 내용으로 중복될 것이다. 그러면 CSS 파일 이름이 변경되거나 새로운 CSS 파일이 추가될 때마다 모든 템플릿 파일을 일일이 수정해야 한다.

플라스크는 이런 불편함을 해소하기 위한 템플릿 상속(extends) 기능을 제공한다. 여기서는 단순히 템플릿을 표준 HTML 구조로 바꿀 뿐 아니라 템플릿 상속 기능까지 사용할 것이다.

템플릿 파일의 기본 틀 작성하기
우선 템플릿 파일의 기본 틀이 되는 base.html 템플릿을 작성하자. 모든 템플릿에서 공통으로 입력할 내용을 여기에 포함한다고 생각하면 된다.

[파일명: projects/myproject/pybo/templates/base.html]
<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
    <!-- pybo CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Hello, pybo!</title>
</head>
<body>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
</body>
</html>

body 엘리먼트에 {% block content %}와 {% endblock %} 템플릿 태그가 보일 것이다. 바로 이 부분이 base.html 템플릿 파일을 상속한 템플릿에서 구현해야 할 영역이 된다.

질문 목록 템플릿 수정하기
질문 목록을 나타내는 question_list.html 템플릿 파일을 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]
<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
    </table>
</div>
{% endblock %}
base.html 템플릿 파일을 상속받고자 {% extends 'base.html' %} 템플릿 태그를 사용했다. 그리고 {% block content %}와 {% endblock %} 사이에 question_list.html에서만 사용할 내용을 작성했다. 그리고 기존에 bootstrap.min.css 파일을 링크했던 첫번째 라인은 더이상 필요없으므로 삭제하자. 왜냐하며 base.html 기본 템플릿에 이미 해당 라인이 포함되어 있기 때문이다.
이제 question_list.html은 base.html을 상속받았으므로 표준 HTML 구조를 갖추게 된다.

질문 상세 템플릿 파일 수정하기
질문 상세를 나타내는 question_detail.html 파일도 마찬가지 방법으로 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    (... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        (... 생략 ...)
    </form>
</div>
{% endblock %}
{% extends 'base.html' %} 템플릿 태그를 맨 위에 추가하고 기존 내용 위 아래로 {% block content %}와 {% endblock %}를 작성했다.

표준 HTML 구조 확인하기
템플릿 상속을 적용한 후 질문 목록, 질문 상세를 조회해 보자. 화면에 보여지는 것은 동일하지만 표준 HTML 구조로 변경된 것을 확인할 수 있다.

브라우저에서 소스보기 기능으로 생성된 HTML을 확인할 수 있다.

기존 스타일 파일 내용 비우기
부트스트랩을 사용하게 되었으므로 style.css 파일의 내용을 비우자. 이 파일은 이후 부트스트랩으로 표현할 수 없는 스타일을 위해 사용할 것이므로 파일 자체를 삭제하지 말고 내용만 비워 두자.

[파일명: projects/myproject/pybo/static/style.css]
textarea {
    width:100%;
}

input[type=submit] {
    margin-top:10px;
}







2-10 폼 모듈로 데이터 검증 더 쉽게 하기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-10
[실습 영상] : https://youtu.be/gPo1p7mwxMc

웹 프로그램에서 폼(form)은 사용자에게 입력 양식을 편리하게 제공하기 위해 사용한다. 이번에는 플라스크의 폼 모듈을 어떻게 사용하는지 알아보자. 폼 모듈을 사용하면 폼으로 전송되는 데이터의 필수 여부, 길이, 형식 등을 더 쉽게 검증할 수 있다.

플라스크 폼 모듈 설치하기
플라스크에서 폼을 사용하려면 Flask-WTF 라이브러리를 설치해야 한다. 명령 프롬프트에서 다음 명령으로 Flask-WTF를 설치하자.
(myproject) c:\projects\myproject> pip install flask-wtf
그리고 Flask-WTF를 사용하려면 플라스크의 환경변수 SECRET_KEY가 필요하다.

점프 투 플라스크
SECRET_KEY
SECRET_KEY는 CSRF(cross-site request forgery)라는 웹 사이트 취약점 공격을 방지하는 데 사용된다. CSRF는 사용자의 요청을 위조하는 웹 사이트 공격 기법인데 SECRET_KEY를 기반으로 해서 생성되는 CSRF 토큰은 폼으로 전송된 데이터가 실제 웹 페이지에서 작성된 데이터인지를 판단해 주는 가늠자 역할을 한다. 플라스크에서 CSRF 토큰을 어떻게 사용하는지는 잠시 후에 알아보자.

CSRF 토큰은 쉽게 말해 CSRF를 방어하려고 플라스크에서 생성하는 무작위 문자열이다. CSRF 토큰이라는 명칭 때문에 "공격 기술에 사용하는 요소"라고 오해하지 않길 바란다.

먼저 config.py 파일을 열고 마지막 줄에 SECRET_KEY 변수를 추가하자.

[파일명: projects/myproject/config.py]
import os

BASE_DIR = os.path.dirname(__file__)

SQLALCHEMY_DATABASE_URI = 'sqlite:///{}'.format(os.path.join(BASE_DIR, 'pybo.db'))
SQLALCHEMY_TRACK_MODIFICATIONS = False
SECRET_KEY = "dev"

사실 SECRET_KEY = "dev"는 위험한 설정이다. 실제 서비스를 운영할 때에는 "dev"처럼 유추하기 쉬운 문자열을 입력하면 안 된다. 물론 현재는 개발환경이므로 괜찮다. 서비스 운영 환경에서 SECRET_KEY를 설정하는 방법은 뒤에서 자세히 알아보자.

질문 등록

이제 파이보에 질문을 등록할수 있도록 만들어 보자. 참고로 질문 등록은 이번 장 끝까지 진행해야 완벽하게 동작한다. (왜냐하면 맨 마지막에 진행하는 CSRF 설정까지 끝나야만 질문 등록이 정상동작하기 때문이다.)

질문 등록 버튼 만들기
우선 다음처럼 질문 목록 템플릿을 열고 </table> 태그 아래에 질문등록 버튼을 생성하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

(... 생략 ...)
    </table>
    <a href="{{ url_for('question.create') }}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}

질문 폼 만들기
질문 목록 화면에 질문 등록 URL을 추가했으므로 question_views.py 파일에 라우팅 함수 create를 추가해야 한다. 하지만 create 함수를 작성하기 전에 질문 등록시 사용할 QuestionForm을 먼저 만들어 보자.

QuestionForm은 질문을 등록할 때 사용할 플라스크의 폼(Form)이다.

pybo 디렉터리에 forms.py 파일을 새로 만든 다음 QuestionForm을 다음처럼 작성하자.

[파일명: projects/myproject/pybo/forms.py]

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms.validators import DataRequired

class QuestionForm(FlaskForm):
    subject = StringField('제목', validators=[DataRequired()])
    content = TextAreaField('내용', validators=[DataRequired()])
질문을 등록할 때 사용할 QuestionForm을 만들었다. QuestionForm과 같은 플라스크의 폼은 FlaskForm 클래스를 상속하여 만들어야 한다.


QuestionForm의 속성은 "제목"과 "내용"이다. 글자수의 제한이 있는 "제목"의 경우 StringField를 사용하고 글자수의 제한이 없는 "내용"은 TextAreaField를 사용한다. 플라스크에서 사용할 수 있는 폼 속성에 대한 보다 자세한 내용은 다음 URL을 참고하자.

https://wtforms.readthedocs.io/en/2.3.x/fields/#basic-fields
StringField('제목', validators=[DataRequired()]) 에서 첫번째 입력인수인 "제목"은 폼 라벨(Label)이다. 템플릿에서 이 라벨을 이용하여 "제목"이라는 라벨을 출력할 수 있다. 이 부분은 잠시후에 다시 알아보기로 하자. 두번째 입력인수는 validators이다. validators는 검증을 위해 사용되는 도구로 필수 항목인지를 체크하는 DataRequired, 이메일인지를 체크하는 Email, 길이를 체크하는 Length등이 있다. 예를들어 필수값이면서 이메일이어야 하면 validators=[DataRequired(), Email()] 과 같이 사용할 수 있다. 플라스크에서 사용할 수 있는 validators에 대한 보다 자세한 내용은 다음 URL을 참고하자.

https://wtforms.readthedocs.io/en/2.3.x/validators/#built-in-validators
질문 등록 라우팅 함수 추가하기
그리고 question_views.py 파일에 라우팅 함수 create를 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from pybo.forms import QuestionForm

(... 생략 ...)

@bp.route('/create/')
def create():
    form = QuestionForm()
    return render_template('question/question_form.html', form=form)
question_form.html 템플릿에 전달하는 QuestionForm의 객체(form)는 템플릿에서 라벨이나 입력폼 등을 만들때 필요하다.

질문 등록 템플릿 작성하기
이제 질문을 등록하는 템플릿을 만들어 보자. pybo/templates/question 디렉터리에 question_form.html 파일을 만들고 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post" class="my-3">

        {{ form.subject.label }}
        {{ form.subject() }}

        {{ form.content.label }}
        {{ form.content() }}

        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
질문 등록을 위해서는 질문의 제목과 내용이라는 입력항목이 필요하다. 위의 템플릿에서는 질문의 제목과 내용에 해당하는 입력 항목을 form 객체를 사용해서 만들었다. QuestionForm에서 작성한 두개의 필드 subject와 content가 템플릿에서 사용되었다. {{ form.subject.label }} 는 라벨을 표시하고 {{ form.subject() }}는 입력폼을 표시한다.


질문 등록 기능 사용해 보기
웹 브라우저에서 질문 등록 기능을 확인해 보자.

http://localhost:5000/question/list에 접속해 보면 질문 목록 화면에 <질문 등록하기> 버튼이 추가되었다.



여기서 <질문 등록하기> 버튼을 누르면 다음처럼 질문 등록 화면이 나타난다.



QuestonForm 객체가 자동으로 만들어 준 입력 항목(제목과 내용)이 보인다. 각 항목에 값을 입력하고 <저장하기> 버튼을 눌러 보자.

하지만 다음처럼 ‘Method NotAllowed’ 오류 화면이 나타날 것이다.



위와 같은 오류 화면이 나타난 이유는 현재 폼이 POST 방식으로 데이터를 전송하기 때문이다. 다음은 위에서 작성한 질문 등록을 위한 question_form.html 템플릿의 폼 태그이다.


<form method="post" class="my-3">
코드에서 보듯 form 태그의 method 속성이 “post”이므로 폼에 입력한 데이터는 POST 방식로 전송된다. 그런데 현재 create 라우팅 함수에는 별도의 method 속성을 지정하지 않았으므로 기본 처리 방식인 GET 방식만 처리할 수 있다. 즉, POST 방식으로 데이터를 처리하게 하려면 create 함수의 라우팅 정보를 수정해야 한다.

점프 투 플라스크
action 속성을 지정하지 않은 이유
잠깐, 다음으로 진행하기 전에 한 가지 눈여겨 보아야 할 부분이 있다. 그것은 바로 <form method="post"> 처럼 form 태그에 action 속성을 지정하지 않았다는 점이다. 보통 form 태그에는 항상 action 속성을 지정하여 submit 실행시 action에 정의된 URL로 폼을 전송해야 한다. 하지만 여기서는 특별하게 action 속성을 지정하지 않았다. form 태그에 action 속성을 지정하지 않으면 현재 페이지의 URL이 디폴트 action으로 설정된다.

물론 action 속성을 다음처럼 명확하게 지정해도 된다.

<form method="post" action="{{ url_for('question.create') }}">
하지만 이렇게 하면 action 속성을 지정하면 question_form.html 템플릿은 "질문 등록" 에서만 사용 가능하다. 이후에 진행할 "질문 수정" 에서는 이 템플릿을 활용할 수가 없다. 왜냐하면 질문 수정일 경우에는 action 값을 달리해야 하기 때문이다. 동일한 템플릿을 여러 기능에서 함께 사용할 경우에는 이처럼 form의 action 속성을 비워두는 트릭을 종종 사용한다. 우리는 이후에 "질문 수정" 기능을 구현할 때도 question_form.html 템플릿을 사용할 것이므로 action 속성은 비워두도록 하자.

form에 action을 사용하지 않는 이유에 대해서는 질문 수정시에도 다시 한번 설명한다.

질문 전송 방식 수정하기
create 함수가 GET과 POST 방식을 모두 처리할수 있도록 라우팅 애너테이션에 methods 속성을 추가하자.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    return render_template('question/question_form.html', form=form)
그런 다음 질문 등록 화면에서 <저장하기> 버튼을 다시 한번 눌러 보자. 그러면 이제 오류는 발생하지 않을 것이다. 하지만 여전히 아무런 반응 없이 질문 등록 화면만 보인다. 왜냐하면 create 함수에 데이터를 저장하는 코드를 아직 작성하지 않았기 때문이다.


이제 템플릿에서 전송한 폼 데이터를 저장하는 코드를 작성해 보자.

폼 데이터를 저장하는 코드 작성하기
create 함수에 POST 방식으로 요청된 폼 데이터를 데이터베이스에 저장하는 코드를 추가하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from datetime import datetime

from flask import Blueprint, render_template, request, url_for
from werkzeug.utils import redirect

from .. import db
from ..models import Question
from ..forms import QuestionForm

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    if request.method == 'POST' and form.validate_on_submit():
        question = Question(subject=form.subject.data, content=form.content.data, create_date=datetime.now())
        db.session.add(question)
        db.session.commit()
        return redirect(url_for('main.index'))
    return render_template('question/question_form.html', form=form)
if 문의 request.method는 create 함수로 요청된 전송 방식을 의미한다. 그리고 form.validate_on_submit 함수는 전송된 폼 데이터의 정합성을 점검한다. 즉, QuestionForm 클래스의 각 속성에 지정한 DataRequired() 같은 점검 항목에 이상이 없는지 확인한다. 즉, 위 코드에 추가한 내용은 POST 요청이고 폼 데이터에 이상이 없을 경우 질문을 저장한 뒤 main.index 페이지로 이동하라는 내용이다.

코드를 보면 폼으로부터 전달받은 "제목"에 해당하는 데이터는 form.subject.data로 얻고 있다. form.content.data도 마찬가지이다.

방금 추가한 코드의 핵심은 데이터 전송 방식이 POST인지 GET인지에 따라서 달리 처리하는 부분이다. 질문 목록에서 <질문 등록하기> 버튼을 누르거나 질문 등록 화면에서 <저장하기> 버튼을 누르면 똑같이 localhost:5000/question/create/ 페이지를 요청하므로 create 함수가 이 요청을 받는다. 다만 create 함수에서 요청 방식을 구분해서 처리한다. 즉, <질문 등록하기> 버튼을 누르는 것은 GET 방식 요청이므로 질문 등록 화면을 보여 주고, <저장하기>버튼을 누르면 POST 방식 요청이므로 데이터베이스에 질문을 저장한다.

그런데 여기까지 작성하고 <저장하기> 버튼을 눌러도 제대로 동작하지 않는다. 이 문제는 잠시 후에 해결하기로 하고 먼저 폼에 부트스트랩을 적용해 보자.

CSRF 문제를 해결해야 저장이 가능하다. 이것은 뒤에서 자세히 알아보자.

폼에 부트스트랩 적용하기

앞서 화면을 깔끔하게 만들어 주는 부트스트랩을 도입했는데, {{ form.subject() }}와 같은 코드는 폼이 HTML을 자동으로 생성하므로 부트스트랩을 적용할 수 없다. 하지만 템플릿을 조금 수정하면 부트스트랩을 어느정도 적용할 수 있다. form.subject나 form.content에 부트스트랩 클래스 class="form-control"을 적용해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
{{ form.subject.label }}
{{ form.subject(class="form-control") }}

{{ form.content.label }}
{{ form.content(class="form-control") }}
(... 생략 ...)
이와같이 수정하면 다음처럼 부트스트랩 클래스가 적용된 질문등록 화면을 볼 수 있다.



수작업으로 폼 작성하기
앞에서 {{ form.subject() }}처럼 폼을 생성하는 HTML 코드를 자동으로 생성하도록 했다. 하지만 이 방식은 폼을 빠르게 만드는 데는 도움이 되지만 내가 원하는 디자인을 적용하기가 어렵다. 이러한 단점을 보완하고자 이번에는 HTML을 직접 작성하는 방식으로 질문 등록 기능을 완성해 보자.

폼을 자동으로 만드는 코드는 디자인과 프로그램 영역이 혼재되므로 웹 디자이너와 개발자의 역할 분리도 모호해진다.

question_form.html 파일을 열고 form 엘리먼트의 내용을 다음처럼 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
(... 생략 ...)
    <form method="post" class="my-3">
        <div class="mb-3">
            <label for="subject">제목</label>
            <input type="text" class="form-control" name="subject" id="subject">
        </div>
        <div class="mb-3">
            <label for="content">내용</label>
            <textarea class="form-control" name="content" id="content" rows="10"></textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
{{ form.subject() }}와 같이 자동으로 생성되는 HTML 대신 제목과 내용에 해당되는 HTML코드를 직접 작성하였다. 이렇게 수정하면 다음과 같은 질문등록 화면을 볼 수 있다.




HTML 코드를 자동으로 생성하는 방식과 수동으로 작성하는 방식을 모두 실습했다. 어떤 방식이 옳은지 정답은 없으므로 프로젝트 성격에 적합한 방식을 골라 사용하면 된다. 다만 이 책에서는 HTML을 직접 작성하는 방식으로 화면을 구성할 것이다.

질문 등록 완성하기
앞선 실습에서 데이터를 데이터베이스에 저장하는 기능을 추가했지만, 질문 등록 화면에서 <저장하기>를 눌러도 화면에는 아무런 변화가 없었다. 이번 실습에서 그 이유를 알아보고 보완해서 질문 등록 기능을 완성해 보자.

오류 내용을 표시해 원인 알아내기
질문 등록 화면에서 <저장하기>를 눌러도 화면에 아무런 변화가 없으니 무엇이 잘못됐는지 알기 어렵다. 이러한 점을 보완하고자 오류 내용을 표시하도록 질문 등록 템플릿을 다음처럼 수정해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
    <form method="post" class="post-form my-3">
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field, errors in form.errors.items() %}
            <strong>{{ form[field].label }}</strong>
            <ul>
                {% for error in errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="form-group">
(... 생략 ...)
오류를 표시할 수 있는 영역을 위와 같이 추가했다. create함수에서 form.validate_on_submit() 코드가 실패(false 반환)하면 폼에는 오류 내용이 자동으로 등록된다. 
등록된 오류는 form.errors 속성을 사용하여 위와 같이 표시할 수 있다. form.errors.items 의 field는 subject나 content와 같은 입력 폼의 필드를 의미한다.

이렇게 수정하고 질문등록화면에 아무런 값도 입력하지 않고 <저장하기> 버튼을 클릭해 보자. 아마도 다음과 같이 오류를 확인할 수 있는 화면을 볼수 있을 것이다.




제목과 내용 필드에 발생한 오류 메시지는 값을 입력하라는 뜻으로 쉽게 이해할 수 있다. 
그런데 "CSRF Token" 오류는 무엇일까? 앞서 언급했듯 CSRF는 보안 관련 항목으로, form 엘리먼트를 통해 전송된 데이터가 실제 웹 사이트에서 만들어진 데이터인지 검증하는 데 필요한 CSRF 토큰이 빠졌다는 의미다.

CSRF 토큰 오류 처리하기
form 태그 바로 밑에 {{ form.csrf_token }} 코드를 삽입하여 CSRF 토큰 오류에서 탈출해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
(... 생략 ...)
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post" class="my-3">
        {{ form.csrf_token }}
        (... 생략 ...)
    </form>
(... 생략 ...)
이제 코드를 저장하고 질문 등록 페이지의 각 필드를 채운 후 <저장하기>를 눌러 질문을 등록해 보자. 질문 목록 화면으로 이동하고 방금 등록한 질문이 보이면 성공한 것이다.

입력한 값 유지하고 오류 메시지 한글로 바꾸기
이제 질문 등록 기능이 제대로 동작한다. 
그런데 질문을 등록할 때 제목은 입력하고 내용은 입력하지 않으면 오류 메시지가 나타나면서 입력한 내용(제목)이 사라진다. 그래서 다시 입력해야 하는 불편함이 있다.

이 문제를 해결해 보자.

입력한 값 유지하기

폼을 전송했을 때 오류가 있더라도 이미 입력한 값을 유지하도록 질문 폼 템플릿을 다음처럼 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
        <div class="mb-3">
            <label for="subject">제목</label>
            <input type="text" class="form-control" name="subject" id="subject"
                value="{{ form.subject.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="content">내용</label>
            <textarea class="form-control" name="content"
                id="content" rows="10">{{ form.content.data or '' }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
(... 생략 ...)
subject 필드의 value값으로 {{ form.subject.data or '' }}를 입력하면 이미 전송한 데이터가 다시 설정된다. 
{{ form.subject.data or '' }}에서 or ''은 "현재 템플릿이 GET 방식으로 요청되는 경우 기존 입력값이 없으므로(None으로 출력) 이를 방지하기 위해서" 사용했다. 
즉, 이렇게 하면 form.subject.data에 값이 없을 때 None이 아니라 ''이 출력된다. content필드에도 마찬가지 방법이 적용되었다.

이제 제목에만 값을 입력하고 <저장하기>를 눌러 보자. 그러면 내용도 입력하라는 오류가 표시되지만, 제목에 입력한 값이 더이상 사라지지 않는다.

오류 메시지 한글로 바꾸기
이번에는 필수 항목을 입력하지 않았을 때 발생하는 오류 메시지를 우리말로 바꾸어 보자. forms.py 파일을 열어 DataRequired에 한글 메시지를 설정하자.

[파일명: projects/myproject/pybo/forms.py]

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms.validators import DataRequired

class QuestionForm(FlaskForm):
    subject = StringField('제목', validators=[DataRequired('제목은 필수입력 항목입니다.')])
    content = TextAreaField('내용', validators=[DataRequired('내용은 필수입력 항목입니다.')])
이제 필수 입력 항목을 빠뜨리고 질문을 등록하면 오류 메시지가 한글로 나타난다.


답변 등록에 폼 사용하기
지금까지 폼을 이용하여 질문 등록을 만들어 봤다. 이제 각 질문에 답변을 달 수 있는 기능도 폼을 사용하여 만들어 보자. 코드 설명은 대부분 질문 등록 때와 중복되므로 간단히 설명한다.

빠르게 진행해 보자.

답변 등록 폼 추가하기
답변을 등록할 때도 플라스크 폼을 사용해 보자. 먼저 답변 등록을 할 때 사용할 AnswerForm을 forms.py 파일에 추가하자.

[파일명: projects/myproject/pybo/forms.py]

(... 생략 ...)

class AnswerForm(FlaskForm):
    content = TextAreaField('내용', validators=[DataRequired('내용은 필수입력 항목입니다.')])
답변에는 content 필드만 필요하다.

답변 등록 라우팅 함수 수정하기
그리고 answer_views.py 파일에서 create 함수가 AnswerForm을 사용하도록 변경하자. 원리는 질문 등록할 때와 같다.

[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime
from flask import Blueprint, url_for, request, render_template
from werkzeug.utils import redirect

from .. import db
from ..forms import AnswerForm
from ..models import Question, Answer

bp = Blueprint('answer', __name__, url_prefix='/answer')


@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    form = AnswerForm()
    question = Question.query.get_or_404(question_id)
    if form.validate_on_submit():
        content = request.form['content']
        answer = Answer(content=content, create_date=datetime.now())
        question.answer_set.append(answer)
        db.session.commit()
        return redirect(url_for('question.detail', question_id=question_id))
    return render_template('question/question_detail.html', question=question, form=form)
답변 등록은 POST요청만 있으므로 GET, POST 분기처리는 필요없다.

CSRF 코드와 오류 표시 기능 추가하기
이어서 CSRF 토큰과 오류 표시 기능을 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        {{ form.csrf_token }}
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field, errors in form.errors.items() %}
            <strong>{{ form[field].label }}</strong>
            <ul>
                {% for error in errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="mb-3">
            <textarea name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
(... 생략 ...)
질문 상세 템플릿에 폼이 추가되었으므로 question_views.py 파일의 detail 함수도 폼을 사용하도록 수정해야 한다. 이 과정이 없으면 템플릿에서 form 객체를 읽지 못해 오류가 난다.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
from ..forms import QuestionForm, AnswerForm
(... 생략 ...)

@bp.route('/detail/<int:question_id>/')
def detail(question_id):
    form = AnswerForm()
    question = Question.query.get_or_404(question_id)
    return render_template('question/question_detail.html', question=question, form=form)

(... 생략 ...)
이제 답변 등록 기능을 테스트해 보자. 답변을 등록해 보고 내용 없이 등록하여 오류메시지도 확인해 보자.











-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3-01 내비게이션바
[완성 소스] : github.com/pahkey/jump2flask/tree/3-01
[실습 영상] : https://youtu.be/gn9biT-3MQo

지금까지 만든 파이보의 기능(질문 등록·조회, 답변 등록·조회)을 사용해 봤다면 편의 기능이 없어서 이런저런 불편함을 느꼈을 것이다. 그중에서 메인 페이지로 돌아갈 수 있는 장치가 없다는 것이 가장 불편할 것이다. 
여기서는 이런 불편함을 해소하기 위해 내비게이션 바를 만들어 볼 것이다.

내비게이션 바 추가하기
내비게이션 바는 모든 페이지에서 보여야 하므로 base.html 템플릿 파일을 열어 <body> 태그 바로 아래에 추가하자. 
내비게이션 바에는 메인 페이지로 이동해 주는 "Pybo" 로고(클래스값 navbar-brand)를 가장 왼쪽에 배치하고, 오른쪽에는 "계정생성"과 "로그인" 링크를 추가하자.

내비게이션 바는 모든 화면 위쪽에 고정되어 있는 부트스트랩 컴포넌트이다.

부트스트랩 내비게이션바 공식 문서: https://getbootstrap.com/docs/5.1/components/navbar

[파일명: projects/myproject/pybo/templates/base.html]
<!doctype html>
<html lang="ko">
<head>
    (... 생략 ...)
</head>
<body>
<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        <button class="navbar-toggler" type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="#">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
</body>
</html>
질문 목록 화면에서 상단 내비게이션 바 확인하기
이제 질문 목록 페이지를 요청하면 맨 위에 멋진 내비게이션 바가 보일 것이다. 또한 내비게이션 바의 "Pybo" 로고를 누르면 메인 페이지로 돌아갈 수 있다. "Pybo" 로고를 눌러서 잘 동작하는지 확인해 보자.

내비게이션 바는 모든 화면이 상속하는 base.html 파일에 추가된 것이므로 질문 목록, 질문 상세, 질문 등록 화면 모두에 나타날 것이다. 한번 확인해 보자.
부트스트랩이 제공하는 햄버거 메뉴 버튼 확인하기
그런데 부트스트랩 내비게이션 바에는 재미있는 기능이 하나 숨어 있다. 아무 페이지나 접속해서(여기서는 질문 목록에 접속했다) 웹 브라우저의 너비를 줄여 보자. 그러면 어느 순간 햄버거 메뉴 버튼이 생긴다. 그리고 "계정생성"과 "로그인" 링크는 사라진다.
혹시 햄버거 메뉴 버튼을 눌렀는데 아무 변화가 없더라도 당황하지 말자. 아직은 제대로 동작하지 않는 것이 정상이다.

이렇게 부트스트랩은 크기가 작은 기기를 고려한 "반응형 웹"까지 적용되어있다. 그런데 햄버거 메뉴 버튼을 클릭해도 아무런 변화가 없을 것이다. 그 이유는 부트스트랩 자바스크립트 파일(bootstrap.min.js)이 base.html 파일에 포함되지 않았기 때문이다.

부트스트랩에 필요한 파일 추가하기 - 부트스트랩 자바스크립트 파일
부트스트랩 자바스크립트 파일은 bootstrap-5.1.3-dist.zip 압축 파일에 있다. 이 파일을 찾아 다음과 같은 위치에 복사해 붙여 넣자.

부트스트랩 자바스크립트 파일 위치: bootstrap-5.1.3-dist.zip/bootstrap-5.1.3-dist/js/bootstrap.min.js
붙여 넣을 위치: projects/myproject/pybo/static/bootstrap.min.js

이제 base.html 파일을 다음과 같이 수정한 다음 햄버거메뉴 버튼을 누르면 숨어 있는 링크가 표시된다.

[파일명: projects/myproject/pybo/templates/base.html]

(... 생략 ...)
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
<!-- Bootstrap JS -->
<script src="{{ url_for('static', filename='bootstrap.min.js') }}"></script>
</body>
</html>

include 기능으로 내비게이션 바 추가해 보기
이번에는 조금 더 나은 방법으로 내비게이션 바를 템플릿에 추가해 볼 것이다. 플라스크에는 템플릿 특정 위치에 HTML을 삽입해 주는 include 기능이 있다. 이번에는 include 기능으로 내비게이션 바를 base.html 파일 템플릿에 추가해 보자.

templates/navbar.html 파일을 생성하고 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        <button class="navbar-toggler" type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="#">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
navbar.html 파일의 코드는 base.html 파일에 작성했던 내비게이션 바를 위한 HTML을 그대로 복사한 것이다. 내비게이션 바와 관련된 코드를 분리했다고 생각하면 된다.

이제 include 기능을 이용해 위에서 만든 navbar.html 파일을 base.html 파일에 삽입해 보자.

[파일명: projects/myproject/pybo/templates/base.html]
<!doctype html>
<html lang="ko">
<head>
    (... 생략 ...)
</head>
<body>
<!-- 네비게이션바 -->
{% include "navbar.html" %}
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
<!-- Bootstrap JS -->
<script src="{{ url_for('static', filename='bootstrap.min.js') }}"></script>
</body>
</html>

기존의 nav 엘리먼트는 모두 삭제한다.
내비게이션바가 이전과 동일하게 잘 동작할 것이다.

이렇게 include 기능은 템플릿의 특정 영역을 중복, 반복해서 사용할 경우에 유용하다. 즉, 중복, 반복하는 템플릿의 특정 영역을 따로 템플릿 파일로 만들고, include 기능으로 그 템플릿을 포함한다. 
navbar.html 파일은 base.html 파일에서 1번만 사용되지만 따로 파일로 관리해야 이후 유지·보수하는 데 유리하므로 분리했다.


3-02 게시판 페이징
[완성 소스] : github.com/pahkey/jump2flask/tree/3-02
[실습 영상] : https://youtu.be/1JiqgV0gBcw

지금까지 만든 파이보의 질문 목록은 페이징(paging) 기능이 없었다. 페이징 기능이 없으면 어떻게 될까? 만약 게시물이 300개 작성되면 질문 목록 화면에 게시물이 300개 그대로 표시될 것이다. 
이런 경우 한 화면에 표시할 게시물이 많아져서 스크롤 바를 내려야 하는 등의 불편함이 생기므로 페이징 기능은 필수다.


임시 질문 데이터 300개 생성하기
페이징을 구현하기 전에 페이징을 테스트할 정도로 데이터를 충분히 생성하자. 여기서는 테스트 데이터를 300개 생성한다. 테스트 데이터를 대량으로 만드는 가장 좋은 방법은 플라스크 셸을 이용하는 것이다.

다음처럼 플라스크 셸을 실행하자.

(myproject) c:\projects\myproject>flask shell
Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32
App: pybo [development]
Instance: C:\projects\myproject\instance
>>> 
이어서 질문 데이터를 생성하기 위한 모듈을 임포트하자.

>>> from pybo import db
>>> from pybo.models import Question
>>> from datetime import datetime
for 문을 이용하여 다음처럼 테스트 데이터를 300개 생성하자.

>>> for i in range(300):
...     q = Question(subject='테스트 데이터입니다:[%03d]' % i, content='내용무', create_date=datetime.now())
...     db.session.add(q)
...
>>>  db.session.commit()
>>>
db.session.commit()은 데이터를 모두 추가한 이후 마지막에 1번만 실행하면 된다.

이제 플라스크 셸을 종료하고 로컬 서버를 실행한 다음 브라우저에서 질문 목록을 보자.
플라스크 셸로 등록한 테스트 데이터가 보일 것이다. 그리고 300개 이상의 데이터가 한 페이지 보여지는 것을 확인할 수 있다. 이러한 이유로 페이징은 반드시 필요하다.


페이징 구현하기
views/question_views.py 파일을 열어 _list 함수에 다음처럼 페이징을 적용하자. 페이징은 paginate 함수를 사용하여 쉽게 구현할 수 있다.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
@bp.route('/list/')
def _list():
    page = request.args.get('page', type=int, default=1)  # 페이지
    question_list = Question.query.order_by(Question.create_date.desc())
    question_list = question_list.paginate(page=page, per_page=10)
    return render_template('question/question_list.html', question_list=question_list)

Flask-SQLAlchemy 3.0 부터 paginate() 함수가 키워드로만 인자를 보낼 수 있도록 변경되어 question_list = question_list.paginate(page, per_page=10) 대신 question_list = question_list.paginate(page=page, per_page=10) 처럼 사용해야 한다.
_list 함수에 추가한 내용을 가볍게 살펴보자. page = request.args.get('page', type=int, default=1)는 다음과 같은 GET 방식으로 요청한 URL에서 page값을 가져올 때 사용한다. (type=int는 page 파라미터가 정수임을 의미한다.)

http://localhost:5000/question/list/?page=5

만약 다음과 같이 URL에 page값이 없으면 default=1을 적용해 기본값 1이 설정된다.
http://localhost:5000/question/list

이어서 question_list = question_list.paginate(page=page, per_page=10)는 조회한 데이터 question_list에 paginate 함수로 페이징을 적용한다. 이 함수의 1번째 인수로 전달된 page는 현재 조회할 페이지의 번호를 의미하고, 2번째 인수 per_page로 전달된 10은 페이지마다 보여 줄 게시물이 10건임을 의미한다.

만약 URL이 http://localhost:5000/question/list/?page=5와 같다면 질문 목록 5번째 페이지부터 한 페이지에 10건의 게시물을 보여 줄 것이다.

이렇게 paginate 함수를 적용하면 Pagination 객체가 리턴되어 다음과 같은 속성들을 사용할 수 있게 된다.

항목	설명	값의 예
items	현재 페이지에 해당하는 게시물 리스트	[<Question 282>,<Question 283>, ...]
total	게시물 전체 개수	302
per_page	페이지당 보여 줄 게시물 개수	10
page	현재 페이지 번호	2
iter_pages	페이지 범위	[1, 2, 3, 4, 5, None, 30, 31]
prev_num / next_num	이전 페이지 번호 / 다음 페이지 번호	현재 페이지가 3인 경우, 2 / 4
has_prev / has_next	이전 페이지 존재 여부 / 다음 페이지 존재 여부	True / False
paginate 함수를 사용하면 별다른 수고없이 위의 속성들을 사용할 수 있어 페이징 처리가 아주 쉬워진다.


템플릿에 페이징 적용해 보기
이제 Pagination 객체의 속성들을 사용하여 템플릿에서 어떻게 페이징을 처리하는지 알아보자.

질문 목록 출력 코드 수정하기
먼저 템플릿에서 사용하는 question_list가 Pagination 객체로 변경되었으므로 목록을 출력하는 부분을 다음과 같이 수정해야 한다.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        {% for question in question_list.items %}
        (... 생략 ...)
    </table>
    <a href="{{ url_for('question.create') }}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}
원래 코드인 {% for question in question_list %}를 {% for question in question_list.items %} 처럼 .items 를 추가하여 수정해 주었다. Pagination객체는 현재 조회된 목록데이터를 가져오기 위해서는 items 함수를 호출해야 한다.
이제 질문 목록 페이지에 접속하면 이제 질문 데이터 300건이 한꺼번에 표시되지 않고 페이징 기능으로 한 페이지에 10건씩 출력되는 것을 확인할 수 있다.
앞에서 설명했지만 만약 /question/list로 기본 페이지 요청을 하면 디폴트 값에 의해 첫 번째 페이지가 나타난다.

페이지 이동 기능 추가로 페이징 기능 완성하기
이번에는 페이지 이동 기능을 추가해 보자. question_list.html 템플릿의 </table> 바로 아래에 다음과 같이 코드를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]
(... 생략 ...)
    </table>
    <!-- 페이징처리 시작 -->
    <ul class="pagination justify-content-center">
        <!-- 이전페이지 -->
        {% if question_list.has_prev %}
        <li class="page-item">
            <a class="page-link" href="?page={{ question_list.prev_num }}">이전</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="javascript:void(0)">이전</a>
        </li>
        {% endif %}
        <!-- 페이지번호 -->
        {% for page_num in question_list.iter_pages() %}
        {% if page_num %}
        {% if page_num != question_list.page %}
        <li class="page-item">
            <a class="page-link" href="?page={{ page_num }}">{{ page_num }}</a>
        </li>
        {% else %}
        <li class="page-item active" aria-current="page">
            <a class="page-link" href="javascript:void(0)">{{ page_num }}</a>
        </li>
        {% endif %}
        {% else %}
        <li class="disabled">
            <a class="page-link" href="javascript:void(0)">...</a>
        </li>
        {% endif %}
        {% endfor %}
        <!-- 다음페이지 -->
        {% if question_list.has_next %}
        <li class="page-item">
            <a class="page-link" href="?page={{ question_list.next_num }}">다음</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="javascript:void(0)">다음</a>
        </li>
        {% endif %}
    </ul>
    <!-- 페이징처리 끝 -->
    <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}
상당히 많은 양의 HTML코드가 추가되었지만 어렵지 않으니 찬찬히 살펴보자.

이전 페이지가 있는 경우에는 "이전" 링크가 활성화되게 하였고 이전 페이지가 없는 경우에는 "이전" 링크가 비활성화되도록 하였다. (다음페이지의 경우도 마찬가지 방법으로 적용되었다.) 
그리고 페이지 리스트를 루프 돌면서 해당 페이지로 이동할 수 있는 링크를 생성하였다. 이때 현재 페이지와 같을 경우에는 active클래스를 적용하여 강조표시도 해 주었다.

위 템플릿에 사용된 주요 페이징 기능을 표로 정리해 보았다.

페이징 기능	코드
이전 페이지가 있는지 체크	{% if question_list.has_prev %}
이전 페이지 번호	{{ question_list.prev_num }}
다음 페이지가 있는지 체크	{% if question_list.has_next %}
다음 페이지 번호	{{ question_list.next_num }}
페이지 리스트 루프	{% for page_num in question_list.iter_pages() %}
현재 페이지와 같은지 체크	{% if page_num != question_list.page %}
그리고 페이지 리스트를 보기 좋게 표시하기 위해 부트스트랩의 pagination 컴포넌트를 이용하였다. 템플릿에 사용한 pagination, page-item, page-link 등이 부트스트랩 pagination 컴포넌트의 클래스이다.

부트스트랩 pagination - https://getbootstrap.com/docs/5.1/components/pagination/

축하한다! 페이징 기능이 완성되었다. 페이징은 사실 구현하기가 무척 어려운 기술이다. 플라스크의 paginate 함수가 없었다면 아마 이렇게 쉽게 해내기는 힘들었을 것이다.

점프 투 플라스크
생략 기능까지 완벽한 플라스크의 paginate 함수
위 코드를 보면 iter_pages 함수로 페이지가 나열될 때 페이지 번호(page_num)가 없는 경우 ‘...’을 표시한다. 이는 보여 줄 페이지 번호가 지나치게 많은 경우 현재 페이지 위주로 보여 주는 기술이다.

질문 제목의 숫자가 왜 뒤섞여 있나요?

앞에서 대량으로 만든 질문 데이터 제목에 대괄호와 함께 0~299 사이의 숫자를 부여했다. 혹시 페이지를 넘기면서 숫자를 확인했다면 "숫자가 마구 섞여 있는 경우"가 있다는 것을 확인했을 것이다. 
이런 현상이 나타난 이유는 데이터가 아주 빠른 속도로 저장되어 같은 시간이 입력되었기 때문이다. 현재 질문 목록은 작성일시의 역순으로 정렬되므로 데이터가 생성된 시간이 같다면 뒤죽박죽으로 섞인 것처럼 보일 수 있다. 
페이징 기능을 테스트하느라 게시물 데이터를 동시에 저장하느라 발생한 일이니 참고만 하고 넘어가자.

3-03 템플릿 필터 직접 만들어 보기

[완성 소스] : github.com/pahkey/jump2flask/tree/3-03
[실습 영상] : https://youtu.be/UMvEu59WDa8
이번 장에서는 템플릿 필터를 직접 만드는 방법에 대해서 알아보자. 템플릿 필터는 이미 전체 답변 개수를 구할 때 경험한 적이 있다. {{ question.answer_set|length }}와 같이 템플릿에서 사용한 객체에 파이프라인 문자 |를 붙여 필터 기능을 수행한다.

{{ question.answer_set|length }}의 length는 전체 답변 개수를 구할 때 사용한 템플릿 필터이다.

질문 목록 화면의 작성일시를 살펴보자. 작성일시의 날짯값은 datetime 객체이다. 현재 질문 목록 템플릿에서는 datetime 객체를 문자열로 표시했으므로 2020-06-15 14:03:26.769051과 같은 값으로 표시된다. 
그러나 대부분의 게시판 서비스에서는 시간을 이런 식으로 표시하지 않는다.

템플릿 필터를 사용하면 이런 출력 문자열을 다듬을 수 있다.

템플릿 필터 만들기
먼저 datetime 객체를 보기 편한 문자열로 만들수 있는 템플릿 필터를 만들어보자. 다음처럼 pybo/filter.py 파일을 생성하자.

[파일명: projects/myproject/pybo/filter.py]
def format_datetime(value, fmt='%Y년 %m월 %d일 %p %I:%M'):
    return value.strftime(fmt)

filter.py 파일을 pybo디렉터리가 있는곳에 생성하고 위와 같이 format_datetime 함수를 만들었다. format_datetime 함수는 전달받은 datetime 객체(value)를 날짜포맷형식(fmt)에 맞게 변환하여 리턴하는 함수이다. 
만약 fmt가 전달되지 않을 경우 디폴트 값인 '%Y년 %m월 %d일 %p %I:%M'이 사용된다.

[필터에 사용한 날짜 포맷 코드]
항목	설명
%Y	년
%m	월
%d	일
%p	AM, PM (오전, 오후의 구분)
%I	시간 (0~12 시로 표현)
%M	분

점프 투 플라스크
UnicodeEncodeError

만약 format_datetime 함수 실행시 UnicodeEncodeError 오류가 발생한다면 filter.py 파일을 다음과 같이 수정하자.

import locale
locale.setlocale(locale.LC_ALL, '')

def format_datetime(value, fmt='%Y년 %m월 %d일 %p %I:%M'):
    return value.strftime(fmt)

앱에 필터 등록하기
필터를 템플릿에서 사용하려면 pybo/__init__.py 파일의 create_app 함수를 다음처럼 수정해야 한다.

[파일명: projects/myproject/pybo/__init__.py]
(... 생략 ...)
def create_app():
   (... 생략 ...)

    # 블루프린트
    from .views import main_views, question_views, answer_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)
    app.register_blueprint(answer_views.bp)

    # 필터
    from .filter import format_datetime
    app.jinja_env.filters['datetime'] = format_datetime
    return app

format_datetime 함수를 임포트한 다음 app.jinja_env.filters['datetime']와 같이 datetime이라는 이름으로 필터를 등록해 주었다.

필터 사용해 보기
이제 필터를 사용할 차례이다. 먼저 질문 목록 템플릿에 작성한 필터를 적용해 보자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        <tr>
            <td>{{ loop.index }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date|datetime }}</td>
        </tr>
        (... 생략 ...)
    </table>
    (... 생략 ...)
</div>
{% endblock %}

{{ question.create_date|datetime }}과 같이 파이프라인 문자와 함께 datetime 필터를 적용했다. datetime 필터가 적용되었으므로 format_datetime 필터 함수가 실행된다. 이때 format_datetime의 매개변수 value에 question.create_date가 전달된다.

질문 목록 페이지로 이동해 보면 필터가 적용된 작성일시를 확인할 수 있다.

질문 상세 화면에 필터 적용하기
이어서 질문 상세 템플릿에도 같은 필터를 적용하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <!-- 질문 -->
    <h2 class="border-bottom py-2">{{ question.subject }}</h2>
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ question.create_date|datetime }}
                </div>
            </div>
        </div>
    </div>
    <!-- 답변 목록 -->
    <h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
    {% for answer in question.answer_set %}
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ answer.create_date|datetime }}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}
(... 생략 ...)
질문 생성일시인 question.create_date와 답변 생성일시인 answer.create_date에 datetime 필터를 적용했다.

질문 상세 페이지로 이동해 보면 필터가 적용된 화면을 확인할 수 있다.

여기서는 템플릿 필터를 직접 작성하고, 이 필터를 템플릿에 적용하는 방법을 알아보았다. 물론 플라스크는 이미 만들어진 템플릿 필터가 많으므로 그냥 사용해도 되지만 가끔은 나한테 필요한 필터가 없는 경우도 있다. 그런 경우에는 이 과정에 따라 필터를 직접 만들어 적용하면 된다.

플라스크 필터 공식 문서: https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters
마지막 편집일시 : 2022년 8월 11일 10:39 오전

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-04 게시물에 일련번호 추가하기
[완성 소스] : github.com/pahkey/jump2flask/tree/3-04
[실습 영상] : https://youtu.be/519TCvFMaXU

게시물 번호 문제
계속해서 파이보 서비스를 개선해 보자. 현재 파이보 질문 목록 화면을 유심히 보면 페이지마다 게시물 번호가 항상 1부터 시작되는 문제가 있다. 페이지를 이리저리 이동해 봐도 게시물 번호는 1부터 시작한다. 이 문제를 해결해 보자.
두번째 페이지로 이동하더라도 여전히 게시물 번호가 1부터 시작된다.

게시물 번호 공식 만들기
만약 질문 게시물이 12개라면 1페이지에는 12번째~3번째 게시물이, 2페이지에는 2번째~1번째 게시물이 역순으로 표시되어야 한다. 질문 게시물의 번호를 역순으로 정렬하려면 다음과 같은 공식을 적용해야 한다.

번호 = 전체 게시물 개수 - (현재 페이지 - 1) * 페이지당 게시물 개수 - 나열 인덱스

항목	                        설명
번호	                        최종 표시될 게시물 번호
전체 게시물 개수	        데이터베이스에 저장된 게시물 전체 개수
현재 페이지	        페이징에서 현재 선택한 페이지
페이지당 게시물 개수	한 페이지당 보여줄 게시물의 개수
나열 인덱스	         for 문 안의 게시물 순서

나열 인덱스는 현재 페이지에서 표시할 수 있는 게시물의 인덱스이므로 10개를 표시하는 페이지에서는 0~9, 2개를 표시하는 페이지에서는 0~1로 반복된다.

공식이 조금 복잡하니 질문 게시물이 12개인 상황을 예로 들어 설명해 보자. 현재 페이지가 1이면 현재 페이지 - 1은 0이다. 그래서 번호는 전체 게시물 개수 12에서 나열 인덱스 0~9를 뺀 12~3이 된다. 
현재 페이지가 2이면 현재 페이지 - 1은 1이다. 페이지당 게시물 개수는 10이므로 12에서 10을 뺀 값 2에 나열 인덱스 0~1을 다시 빼므로 번호는 2~1이다.

게시물 번호 공식을 질문 목록 템플릿에 적용하기
이제 게시를 번호 공식을 다음처럼 질문 목록 템플릿에 적용해 보자. 다음 코드의 1번째 td 엘리먼트에 이 공식을 그대로 적용했다.

[파일명: projects/myproject/pybo/templates/question/question_list.html]
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        <tr>
            <td>{{ question_list.total - ((question_list.page-1) * question_list.per_page) - loop.index0 }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date|datetime }}</td>
        </tr>
        (... 생략 ...)
    </table>
    (... 생략 ...)
</div>
{% endblock %}
다음 표는 템플릿에 사용한 공식의 상세 정보이다. 코드를 따라 입력하고 이해가 잘 되지 않으면 참고하자.

항목	                        설명
question_list.total	        전체 게시물 개수
question_list.page	현재 페이지
question_list.per_page	페이지당 게시물 개수
loop.index0	                나열 인덱스(0부터 시작)

이제 게시물 번호가 우리가 의도한 대로 출력된다.
성공이다! 페이지를 이리저리 이동하며 게시물 번호를 확인해 보자.

마지막 편집일시 : 2022년 8월 11일 11:07 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-05 질문에 달린 답변 개수 표시하기
[완성 소스] : github.com/pahkey/jump2flask/tree/3-05
[실습 영상] : https://youtu.be/THrofFYl5WY

이제 질문 목록에서 "해당 질문에 달린 답변 개수"를 표시해 보자. 코드의 분량은 많지 않지만 "게시판 서비스를 더욱 서비스답게 만들어 주는 기능"이다.
답변 개수는 다음처럼 게시물 제목 바로 오른쪽에 표시하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        <tr>
            <td>{{ question_list.total - ((question_list.page-1) * question_list.per_page) - loop.index0 }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
                {% if question.answer_set|length > 0 %}
                <span class="text-danger small mx-2">{{ question.answer_set|length }}</span>
                {% endif %}
            </td>
            <td>{{ question.create_date|datetime }}</td>
        </tr>
        (... 생략 ...)
    </table>
    (... 생략 ...)
</div>
{% endblock %}
{% if question.answer_set|length > 0 %}로 답변이 있는 경우를 검사하고, {{ question.answer_set|length }}로 답변 개수를 표시했다.

이제 질문 목록 페이지로 이동하면 답변이 있는 질문은 제목 오른쪽에 빨간색 숫자가 표시될 것이다.

마지막 편집일시 : 2022년 8월 11일 11:20 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------





>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

3-06 회원가입
[완성 소스] : github.com/pahkey/jump2flask/tree/3-06
[실습 영상] : https://youtu.be/iCsHsnPoSyw
이번에는 파이보에 회원가입 기능을 구현해 보자. 회원가입을 만들어 보았다면 웹 프로그래밍은 거의 마스터했다고 할 수 있다. 그만큼 회원가입 기능은 웹 사이트에서 핵심 중의 핵심이라 할 수 있다.

회원 모델
지금까지는 질문, 답변 모델만 사용했다면 이제 회원 정보를 위한 모델이 필요하다. 회원 정보 모델에는 최소한 다음과 같은 속성이 필요하다.

속성	설명
username	사용자 이름(ID)
password	비밀번호
email	이메일
pybo/models.py 파일을 열어 앞에서 정의한 속성을 바탕으로 User 모델을 작성하자.

[파일명: projects/myproject/pybo/models.py]
(... 생략 ...)
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

id는 자동으로 증가하는 User 모델의 기본 키이다. username, password, email에는 null값을 허용하지 않도록 nullable=False로 설정했다. 또 username, email에는 unique=True를 지정했다. 
unique=True는 "같은 값을 저장할 수 없다"를 뜻한다. 이렇게 해야 username과 email이 중복되어 저장되지 않는다.

User 모델을 새로 작성했으니 flask db migrate 명령으로 리비전 파일을 생성하자.

(myproject) c:\projects\myproject>flask db migrate

INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'user'
Generating c:\projects\myproject\migrations\versions\333358e4c885_.py ...  done

이어서 flask db upgrade 명령으로 생성된 리비전 파일(예: 333358e4c885_.py)로 데이터베이스를 변경하자. 명령이 아무 문제 없이 잘 수행되는지 반드시 확인하자.

(myproject) c:\projects\myproject>flask db upgrade

INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 2cfa792a602e -> 333358e4c885, empty message

회원가입 폼
이어서 회원가입을 위한 폼을 작성하자. 다음처럼 FlaskForm을 상속하는 UserCreateForm을 만들자.

[파일명: projects/myproject/pybo/forms.py]
from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, PasswordField, EmailField
from wtforms.validators import DataRequired, Length, EqualTo, Email

(... 생략 ...)

class UserCreateForm(FlaskForm):
    username = StringField('사용자이름', validators=[DataRequired(), Length(min=3, max=25)])
    password1 = PasswordField('비밀번호', validators=[
        DataRequired(), EqualTo('password2', '비밀번호가 일치하지 않습니다')])
    password2 = PasswordField('비밀번호확인', validators=[DataRequired()])
    email = EmailField('이메일', validators=[DataRequired(), Email()])
계정생성을 위한 폼의 클래스명은 UserCreateForm이다. username은 필수항목이고 길이가 3-25 사이여야 한다는 검증조건을 설정했다. Length는 폼 유효성 검증시 문자열의 길이가 최소길이(min)와 최대길이(max) 사이에 해당하는지를 검증한다.

password1과 password2는 "비밀번호"와 "비밀번호확인"에 대한 필드이다. 로그인 할때는 비밀번호가 한번만 필요하지만 계정생성시에는 입력한 비밀번호가 정확한지 확인하기 위해 2개의 필드가 필요하다. 
password1과 password2 속성은 PasswordField로 생성되었다. StringField와 비슷하지만 템플릿에서 자동변환으로 사용시 <input type="password"> 태그로 변환되는 차이점이 있다. 
password1 속성과 password2 속성은 모두 필수값이어야 하고 두개의 값이 일치해야 하는 EqualTo 검증이 추가되었다. password1 속성에 지정된 EqualTo('password2') 는 password1과 password2의 값이 일치해야 함을 의미한다.

그리고 email 속성은 EmailField로 생성되었다. EmailField 역시 StringField와 동일하지만 템플릿 자동변환으로 사용시 <input type="email"> 태그로 변환된다. email 속성에는 필수값 검증조건에 더하여 Email() 검증조건이 추가되었다. 
Email() 검증조건은 해당 속성의 값이 이메일형식과 일치하는지를 검증한다.

그리고 Email() 검증을 사용하기 위해서는 다음처럼 email-validator를 설치해야 한다.

(myproject) c:\projects\myproject>pip install email_validator
Collecting email_validator
(... 생략 ...)

회원가입 구현하기
이제 계정모델과 계정폼이 준비되었으니 회원가입을 위한 블루프린트를 만들어보자. 회원가입은 메인(main_views.py), 질문(question_views.py), 답변(answer_views.py) 어디에도 해당되지 않으므로 회원가입과 로그인/로그아웃을 담당할 auth_views.py 파일을 신규로 생성하자.

블루프린트
views/auth_views.py 파일을 새로 만들어 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/views/auth_views.py]
from flask import Blueprint, url_for, render_template, flash, request
from werkzeug.security import generate_password_hash
from werkzeug.utils import redirect

from pybo import db
from pybo.forms import UserCreateForm
from pybo.models import User

bp = Blueprint('auth', __name__, url_prefix='/auth')

@bp.route('/signup/', methods=('GET', 'POST'))
def signup():
    form = UserCreateForm()
    if request.method == 'POST' and form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            user = User(username=form.username.data,
                        password=generate_password_hash(form.password1.data),
                        email=form.email.data)
            db.session.add(user)
            db.session.commit()
            return redirect(url_for('main.index'))
        else:
            flash('이미 존재하는 사용자입니다.')
    return render_template('auth/signup.html', form=form)

우선 /auth/로 시작하는 URL이 호출되면 auth_views.py 파일의 함수들이 호출될 수 있도록 블루프린트 객체 bp를 생성했다. 그리고 회원가입을 위한 signup 함수를 생성했다. signup 함수는 POST 방식에는 계정을 저장하고 GET 방식에는 계정 등록 화면을 출력한다.
코드를 자세히 보면 계정 등록을 할 때 username으로 데이터를 조회해서 "이미 등록된 사용자"인지를 확인한다. 만약 이미 등록된 사용자라면 flash('이미 존재하는 사용자입니다.')로 오류를 발생시킨다.

flash는 필드 자체 오류가 아닌 프로그램 논리 오류를 발생시키는 함수이다. flash로 발생시킨 오류를 템플릿에 표시하는 방법도 곧 알아볼 것이다.
그리고 비밀번호는 폼으로 전달받은 값을 그대로 저장하지 않고 generate_password_hash 함수로 암호화하여 저장했다.
generate_password_hash 함수로 암호화한 데이터는 복호화할 수 없다. 그래서 로그인할 때 입력받은 비밀번호는 암호화하여 저장된 비밀번호와 비교해야 한다.

블루프린트 등록
새로 만든 블루프린트를 사용하려면 pybo/__init__.py 파일에 등록해야 한다.

[파일명: projects/myproject/pybo/__init__.py]

(... 생략 ...)

def create_app():
    (... 생략 ...)

    # 블루프린트
    from .views import main_views, question_views, answer_views, auth_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)
    app.register_blueprint(answer_views.bp)
    app.register_blueprint(auth_views.bp)

    (... 생략 ...)

    return app

회원가입 템플릿
이어서 회원가입 템플릿을 작성하자. signup.html 파일은 templates 디렉터리 아래에 auth 디렉터리를 추가한 후 다음처럼 작성하자.

[파일명: projects/myproject/pybo/templates/auth/signup.html]
{% extends "base.html" %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">계정생성</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password1">비밀번호</label>
            <input type="password" class="form-control" name="password1" id="password1"
                   value="{{ form.password1.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password2">비밀번호 확인</label>
            <input type="password" class="form-control" name="password2" id="password2"
                   value="{{ form.password2.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="email">이메일</label>
            <input type="text" class="form-control" name="email" id="email"
                   value="{{ form.email.data or '' }}">
        </div>
        <button type="submit" class="btn btn-primary">생성하기</button>
    </form>
</div>
{% endblock %}

회원가입을 위한 "사용자 이름", "비밀번호", "비밀번호 확인", "이메일"에 해당되는 input 엘리먼트를 추가했다. <생성하기> 버튼을 누르면 폼 데이터가 POST 방식으로 /auth/signup/ URL로 요청된다.
form 태그에 action 속성이 지정되지 않은 경우에는 현재의 URL, 즉, 브라우저에 현재 표시된 URL로 폼이 전송된다. 따라서 현재 브라우저에 표시되는 URL은 /auth/signup/ 이므로 버튼을 누르면 POST 방식으로 /auth/signup/ 이 호출된다.

그리고 회원가입을 할 때 발생할 수 있는 오류를 표시하도록 {% include "form_errors.html" %}를 사용했다.

오류 표시하기
form_errors.html 템플릿 파일은 다음과 같이 "필드에서 발생한 오류를 표시하는 부분"과 "flash를 거치면서 발생한 오류를 표시하는 부분"으로 구성된다. 
필드 오류는 폼 validators 검증에 실패한 경우 표시되고, flash 오류는 flash('이미 존재하는 사용자입니다.')와 같은 로직에 의해 표시된다.

[파일명: projects/myproject/pybo/templates/form_errors.html]
<!-- 필드오류 -->
{% if form.errors %}
<div class="alert alert-danger" role="alert">
    {% for field, errors in form.errors.items() %}
    <strong>{{ form[field].label }}</strong>
    <ul>
        {% for error in errors %}
        <li>{{ error }}</li>
        {% endfor %}
    </ul>
    {% endfor %}
</div>
{% endif %}
<!-- flash 오류 -->
{% for message in get_flashed_messages() %}
<div class="alert alert-danger" role="alert">
    {{ message }}
</div>
{% endfor %}

회원가입 링크
이제 회원가입 화면으로 이동할 수 있는 링크를 내비게이션 바에 추가하자.

[파일명: projects/myproject/pybo/templates/navbar.html]
<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        (... 생략 ...)
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.signup') }}">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>

이제 내비게이션 바의 ‘계정생성’ 링크를 누르면 다음과 같은 회원가입 화면이 나온다.
입력값 중에서 "비밀번호"와 "비밀번호 확인"을 서로 다르게 입력하고 <생성하기>를 누르면 validator 오류가 발생하여 화면에 다음과 같은 오류 메시지가 나타날 것이다.
이처럼 우리가 만든 회원가입 기능에는 필숫값 검증, 이메일 규칙 검증 등이 적용되어 있다. 올바른 입력값으로 회원가입을 완료하면 메인 페이지로 리다이렉트될 것이다.

회원 데이터 확인
플라스크 셸에서 회원가입을 통해 생성된 계정 정보를 확인해 보자.

(myproject) c:\projects\myproject>flask shell
>>> from pybo.models import User
>>> User.query.all()
[<User 1>]
>>> User.query.first().username
'pahkey'

축하한다. 이제 파이보에 회원가입 기능이 추가되었다.

마지막 편집일시 : 2022년 8월 14일 11:25 오후
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
































3-07 로그인과 로그아웃


[완성 소스] : github.com/pahkey/jump2flask/tree/3-07
[실습 영상] : https://youtu.be/QwMW-wt7CK8
파이보는 여러 사람이 사용하는 게시판 서비스다. 그러므로 로그인, 로그아웃은 필수 기능이다.

로그인 정보가 있어야 질문한 사람, 답변한 사람이 누구인지 알수 있다.

로그인
로그인 폼
로그인 라우팅 함수
로그인 템플릿
로그인 링크
로그아웃
로그인 여부 확인
로그인 로그아웃 표시하기
로그아웃 라우팅 함수
로그아웃 링크
로그인
로그인 폼
다음과 같이 로그인시 사용할 UserLoginForm을 만들자.

[파일명: projects/myproject/pybo/forms.py]

(... 생략 ...)

class UserLoginForm(FlaskForm):
    username = StringField('사용자이름', validators=[DataRequired(), Length(min=3, max=25)])
    password = PasswordField('비밀번호', validators=[DataRequired()])
username, password 필드를 추가하고 각각 필수 입력 항목으로 지정해 주었다. 또한 username의 길이는 3~25자로 제한했다.

로그인 라우팅 함수
그리고 로그인을 수행할 라우팅 함수를 다음처럼 작성하자.

[파일명: projects/myproject/pybo/views/auth_views.py]

from flask import Blueprint, url_for, render_template, flash, request, session
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import redirect

from pybo import db
from pybo.forms import UserCreateForm, UserLoginForm

(... 생략 ...)

@bp.route('/login/', methods=('GET', 'POST'))
def login():
    form = UserLoginForm()
    if request.method == 'POST' and form.validate_on_submit():
        error = None
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            error = "존재하지 않는 사용자입니다."
        elif not check_password_hash(user.password, form.password.data):
            error = "비밀번호가 올바르지 않습니다."
        if error is None:
            session.clear()
            session['user_id'] = user.id
            return redirect(url_for('main.index'))
        flash(error)
    return render_template('auth/login.html', form=form)
/login/ URL과 매핑되는 login 함수를 생성했다. login 함수는 signup 함수와 비슷하게 동작한다. POST 방식에는 로그인을 수행하고, GET 요청에는 로그인 화면을 보여준다.


POST 요청에 의해 로그인 하는 과정을 알아보자. 우선 폼 입력으로 받은 username으로 데이터베이스에 해당 사용자가 있는지를 검사한다. 만약 사용자가 없으면 "존재하지 않는 사용자입니다."라는 오류를 발생시킨다. 사용자가 존재한다면 폼 입력으로 받은 password와 check_password_hash 함수를 사용하여 데이터베이스의 비밀번호와 일치하는지를 비교한다.

데이터베이스에 저장된 비밀번호는 암호화되었으므로 입력된 비밀번호와 바로 비교할 수 없다. 입력 비밀번호는 반드시 check_password_hash 함수로 암호화한 후 데이터베이스의 값과 비교해야 한다.

사용자도 존재하고 비밀번호도 일치한다면 플라스크 세션(session)에 사용자 정보를 저장한다. 세션 키에 'user_id'라는 문자열을 저장하고 키에 해당하는 값은 데이터베이스에서 조회한 사용자의 id 값을 저장했다.

세션에 대해 잠시 생각해 보자. session은 request와 마찬가지로 플라스크가 자체적으로 생성하여 제공하는 객체이다. 브라우저가 플라스크 서버에 요청을 보내면 request 객체는 요청할 때마다 새로운 객체가 생성된다. 하지만 session은 request와 달리 한번 생성하면 그 값을 계속 유지하는 특징이 있다.

세션은 서버에 브라우저별로 생성되는 메모리 공간이라고 할수 있다.

따라서 세션에 사용자의 id 값을 저장하면 다양한 URL 요청에 이 세션에 저장된 값을 읽을 수 있다. 예를 들어 세션 정보를 확인하여 현재 요청한 주체가 로그인한 사용자인지 아닌지를 판별할 수 있다

점프 투 플라스크
쿠키와 세션 이해하기
웹 프로그램은 [웹 브라우저 요청 → 서버 응답] 순서로 실행되며, 서버 응답이 완료되면 웹 브라우저와 서버 사이의 네트워크 연결은 끊어진다. 하지만 수 많은 브라우저가 서버에 요청할 때마다 매번 새로운 세션이 생성되는 것이 아니라 동일한 브라우저의 요청에서 서버는 동일한 세션을 사용한다.

그렇다면 서버는 도대체 어떻게 웹 브라우저와 연결 고리(세션)를 맺는걸까?

그 해답은 쿠키(Cookie)에 있다. 쿠키는 서버가 웹 브라우저에 발행하는 값이다. 웹 브라우저가 서버에 어떤 요청을 하면 서버는 쿠키를 생성하여 전송하는 방식으로 응답한다. 그러면 웹 브라우저는 서버에서 받은 쿠키를 저장한다. 이후 서버에 다시 요청을 보낼 때는 저장한 쿠키를 HTTP 헤더에 담아서 전송한다. 그러면 서버는 웹 브라우저가 보낸 쿠키를 이전에 발행했던 쿠키값과 비교하여 같은 웹 브라우저에서 요청한 것인지 아닌지를 구분할 수 있다. 이때 세션은 바로 쿠키 1개당 생성되는 서버의 메모리 공간이라고 할 수 있다.


로그인 템플릿
이어서 로그인 템플릿을 만들자. 로그인 폼에서 생성한 필드 2개(username, password)를 input 엘리먼트로 만들자.

[파일명: projects/myproject/pybo/templates/auth/login.html]

{% extends "base.html" %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">로그인</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password">비밀번호</label>
            <input type="password" class="form-control" name="password" id="password"
                   value="{{ form.password.data or '' }}">
        </div>
        <button type="submit" class="btn btn-primary">로그인</button>
    </form>
</div>
{% endblock %}
템플릿에서 <로그인> 버튼을 누르면 form 엘리먼트가 POST 방식으로 현재 웹 브라우저의 주소 창에 표시된 URL인 /auth/login/로 요청될 것이다.

로그인 링크
이제 로그인할 수 있는 모든 준비를 마쳤으므로 내비게이션 바에 로그인 링크를 추가하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        (... 생략 ...)
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            (... 생략 ...)
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.signup') }}">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.login') }}">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
내비게이션 바의 "로그인" 링크를 누르면 /auth/login으로 이동하며, 다음과 같은 로그인 화면이 나타난다.



만약 데이터베이스에 없는 username 또는 password를 입력하면 다음처럼 오류 메시지가 나타난다.




username과 password를 제대로 입력하면 로그인을 수행한 다음 메인 화면으로 이동한다.

로그인에 성공했다. 축하한다!

로그아웃
하지만 로그인한 후에도 내비게이션 바에는 여전히 "로그인" 링크가 남아 있다. 이 링크는 "로그아웃" 링크로 바뀌어야 한다.

반대로 로그아웃 상태에서는 "로그인" 링크로 바뀌어야 한다.

사용자의 로그인 여부는 "session에 저장된 값을 조사"하면 알 수 있다. 단순히 session에 저장된 user_id값 여부로 로그인을 확인할 수도 있지만 여기서는 좀 더 일반적으로 사용할 수 있는 방법에 대해서 알아보자.

로그인 여부 확인
우선 로그인한 사용자 정보를 조회하여 사용할 수 있도록 auth_views.py파일에 load_logged_in_user 함수를 다음처럼 구현해 보자.

[파일명: projects/myproject/pybo/views/auth_views.py]


from flask import Blueprint, url_for, render_template, flash, request, session, g
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import redirect

(... 생략 ...)

@bp.before_app_request
def load_logged_in_user():
    user_id = session.get('user_id')
    if user_id is None:
        g.user = None
    else:
        g.user = User.query.get(user_id)
여기서는 @bp.before_app_request 애너테이션을 사용했다. 이 애너테이션이 적용된 함수는 라우팅 함수보다 항상 먼저 실행된다. 즉, 앞으로 load_logged_in_user 함수는 모든 라우팅 함수보다 먼저 실행될 것이다.

@bp.before_app_request를 적용한 함수는 auth_views.py의 라우팅 함수 뿐만 아니라 모든 라우팅 함수보다 항상 먼저 실행된다.

load_logged_in_user 함수에서 사용한 g는 플라스크의 컨텍스트 변수이다. 이 변수는 request 변수와 마찬가지로 [요청 → 응답] 과정에서 유효하다. 코드에서 보듯 session 변수에 user_id값이 있으면 데이터베이스에서 사용자 정보를 조회하여 g.user에 저장한다. 이렇게 하면 이후 사용자 로그인 검사를 할 때 session을 조사할 필요가 없다. g.user에 값이 있는지만 확인하면 된다. g.user에는 User 객체가 저장되어 있으므로 여러 가지 사용자 정보(username, email 등)를 추가로 얻어내는 이점이 있다.

g.user에는 User 객체가 저장된다.

로그인 로그아웃 표시하기
이제 내비게이션 바를 다음과 같이 수정하자. {% if g.user %} 코드를 추가하여 사용자의 로그인 유무를 판별할 것이다.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        (... 생략 ...)
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            {% if g.user %}
            <ul class="navbar-nav">
                <li class="nav-item ">
                    <a class="nav-link" href="#">{{ g.user.username }} (로그아웃)</a>
                </li>
            </ul>
            {% else %}
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.signup') }}">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.login') }}">로그인</a>
                </li>
            </ul>
            {% endif %}
        </div>
    </div>
</nav>
"로그아웃" 링크는 곧 구현할 것이므로 여기서는 우선 href 속성값을 ‘#’ 로 해두자.

g.user는 앞 단계에서 구현한 load_logged_in_user 함수로 생성한 사용자 정보값이다. 로그인 했다면 g.user가 만들어진 상태이므로 username을 표시하고 "로그아웃" 링크를 보여 줄 것이다. 반대로 로그인을 하지 않았다면 "로그인"과 "계정생성" 링크를 보여 줄 것이다.




로그아웃 라우팅 함수
그리고 로그아웃을 구현하기 위해 auth_views.py 파일을 열어 /logout/ URL에 매핑되는 logout 함수를 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/views/auth_views.py]

(... 생략 ...)

@bp.route('/logout/')
def logout():
    session.clear()
    return redirect(url_for('main.index'))
logout 함수에는 세션의 모든 값을 삭제할 수 있도록 session.clear()를 추가했다. 따라서 session에 저장된 user_id는 삭제될 것이며, 앞서 작성한 load_logged_in_user 함수에서 session의 값을 읽을 수 없으므로 g.user도 None이 될 것이다.

로그아웃 링크
"로그아웃" 링크가 활성화될 수 있도록 내비게이션바를 수정하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    (... 생략 ...)
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        {% if g.user %}
        <ul class="navbar-nav">
            <li class="nav-item ">
                <a class="nav-link" href="{{ url_for('auth.logout') }}">{{ g.user.username }} (로그아웃)</a>
            </li>
        </ul>
        {% else %}
        (... 생략 ...)
    </div>
</nav>
이제 로그인, 로그아웃 기능이 잘 실행되는지 확인해 보자.

로그아웃을 누르면 네비게이션 바에는 다시 계정생성, 로그인 링크가 나타날 것이다.

마지막 편집일시 : 2022년 8월 14일 10:59 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-08 모델 수정하기


[완성 소스] : github.com/pahkey/jump2flask/tree/3-08
[실습 영상] : https://youtu.be/6qsz0ACb4rs
회원가입, 로그인, 로그아웃 기능이 완성되어 질문, 답변을 "누가" 작성했는지 알 수 있게 되었다. 이제 기능을 조금씩 다듬어서 파이보를 완벽하게 만들어 보자. 여기서는 Question, Answer 모델을 수정하여 "글쓴이"에 해당하는 user 속성을 추가할 것이다.

SQLite 설정 수정하기
Question 모델에 글쓴이 추가하기
리비전 파일 생성하기
리비전 파일 적용하기
flask db upgrade 명령 오류 해결하기
nullable=True
리비전 오류 확인하기
최종 리비전
현재 리비전
현재 리비전을 최종 리비전으로 변경하기
migrate, upgrade 다시 수행하기
nullable=False
Answer 모델에 글쓴이 추가하기
질문, 답변 등록시 글쓴이 저장하기
답변 등록
질문 등록
login_required
@login_required 데코레이터
@login_required 적용하기
로그아웃 상태에서 답변 등록 불가능하게 만들기



SQLite 설정 수정하기
SQLite 데이터베이스는 ORM을 사용할 때 몇 가지 문제점이 있다. 이것은 SQLite 데이터베이스에만 해당하고 PostgreSQL이나 MySQL 등의 다른 데이터베이스와는 상관없는 내용이다. 
앞으로의 진행을 원활하게 하기 위해 SQLite가 발생시킬 수 있는 오류를 먼저 해결하고 넘어가자.

pybo/__init__.py 파일을 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/__init__.py]

from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import MetaData

import config

naming_convention = {
    "ix": 'ix_%(column_0_label)s',
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(column_0_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}
db = SQLAlchemy(metadata=MetaData(naming_convention=naming_convention))
migrate = Migrate()

def create_app():
    app = Flask(__name__)
    app.config.from_object(config)

    # ORM
    db.init_app(app)
    if app.config['SQLALCHEMY_DATABASE_URI'].startswith("sqlite"):
        migrate.init_app(app, db, render_as_batch=True)
    else:
        migrate.init_app(app, db)
    from . import models
    (... 생략 ...)
이와 같이 수정하면 데이터베이스의 프라이머리 키, 유니크 키, 인덱스 키 등의 이름이 변경되므로 flask db migrate 명령과 flask db upgrade 명령으로 데이터베이스를 변경해야 한다.

데이터베이스에서 디폴트 값으로 명명되던 프라이머리 키, 유니크 키 등의 제약조건 이름을 수동으로 설정한 것이다.

(myproject) c:\projects\myproject>flask db migrate
(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.

점프 투 플라스크
SQLite 버그패치
SQLite 데이터베이스에서 사용하는 인덱스 등의 제약 조건 이름은 MetaData 클래스를 사용하여 규칙을 정의해야 한다. 만약 이름을 정의하지 않으면 SQLite 데이터베이스는 다음과 같은 제약 조건에 이름이 없다는 오류를 발생시킨다.

ValueError: Constraint must have a name
또 SQLite 데이터베이스는 migrate.init_app(app, db, render_as_batch=True)처럼 render_as_batch 속성을 True로 지정해야 한다. 만약 이 속성이 False라면 다음과 같은 오류가 발생한다.

ERROR [root] Error: No support for ALTER of constraints in SQLite dialectPlease refer to the batch mode feature which allows for SQLite migrations using a copy-and-move strategy.
pybo/__init__.py 파일에서 수정한 내용은 SQLite 데이터베이스를 플라스크 ORM에서 정상으로 사용하기 위한 것이라고 이해하면 된다.


Question 모델에 글쓴이 추가하기
다음과 같이 글쓴이 정보를 Question 모델에 추가하기 위해 user_id, user 속성을 추가하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    user = db.relationship('User', backref=db.backref('question_set'))
(... 생략 ...)
user_id 속성은 User 모델을 Question 모델과 연결하기 위한 속성이고 user 속성은 Question 모델에서 User 모델을 참조하기 위한 속성이다. db.ForeignKey와 db.relationship은 질문과 답변 모델을 연결하는 부분에서 다루었으므로 자세한 설명은 생략한다.

리비전 파일 생성하기
모델을 수정했으므로 flask db migrate 명령을 실행해서 리비전 파일을 생성하자.

(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'question.user_id'
INFO  [alembic.autogenerate.compare] Detected added foreign key (user_id)(id) on table question
Generating c:\projects\myproject\migrations\versions\4c3f98cdbcab_.py ...  done
리비전 파일 적용하기
이어서 flask db upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 8f2a98320302 -> 4c3f98cdbcab, empty message
Traceback (most recent call last):
  ...
sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: _alembic_tmp_question.user_id
[SQL: INSERT INTO _alembic_tmp_question (id, subject, content, create_date) SELECT question.id, question.subject, question.content, question.create_date
FROM question]
(Background on this error at: http://sqlalche.me/e/gkpj)
그런데 오류가 발생했다. 그 이유는 "user_id 속성이 Null을 허용하지 않기 때문"이다. (모델에서 user_id 속성을 만들 때 nullable 설정을 False로 지정했다.) 앞서 실습을 진행하며 데이터베이스에 Question 모델 데이터를 여러 건 저장했던 것이 기억나는가? 그 데이터에는 user_id 속성의 값이 없다. 그런데 변경된 모델은 이를 허용하지 않으므로 오류가 발생한 것이다. 즉, 기존에 이미 저장되어 있던 데이터들 때문에 발생한 오류이다.

flask db upgrade 명령 오류 해결하기

이 문제를 해결하려면 다음과 같은 과정을 거쳐야 한다. 이런 과정은 어떤 모델에 nullable=Flase 인 속성을 추가하고자 할 때 어쩔수 없이 거져야 하는 과정이다.

다음 순서대로 따라 해보자.

user_id의 nullable 설정을 False 대신 True로 바꾸기
user_id를 임의의 값으로 설정하기(여기서는 1로 설정)
flask db migrate 명령, flask db upgrade 명령 다시 실행하기
user_id의 nullable 설정을 다시 False로 변경하기
flask db migrate 명령, flask db upgrade 명령 다시 실행하기
nullable=True
우선 user_id 속성의 nullable=False를 nullable=True로 변경하자. 그리고 user_id 속성의 기본값을 1로 설정하기 위해 server_default='1'을 입력하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=True, server_default='1')
    user = db.relationship('User', backref=db.backref('question_set'))
(... 생략 ...)
여기서 server_default에 지정한 '1'은 최초로 생성한 User 모델 데이터의 id 값을 의미한다. 기존에 저장된 Question 데이터의 user_id값을 설정하기 위해서 server_default='1'이라는 속성을 추가했다.

점프 투 플라스크
server_default와 default의 차이
컬럼 속성의 default 값은 default와 server_default를 사용해서 설정할수 있다. 그런데 server_default와 default에는 어떤 차이가 있을까? server_default를 사용하면 flask db upgrade 명령을 수행할 때 해당 속성을 갖고 있지 않던 기존 데이터에도 기본값이 저장된다. 하지만 default는 새로 생성되는 데이터에만 기본값을 생성해 준다. 따라서 현재처럼 "없던 속성을 만들어야 하는 상황"에서는 default 대신 server_default를 사용해야 한다.

리비전 오류 확인하기
이제 다시 flask db migrate 명령을 수행해 보자.


(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
ERROR [root] Error: Target database is not up to date.
하지면 여전히 오류가 발생한다. 왜냐하면 이전의 migrate 명령은 제대로 수행되었지만 upgrade를 실패하여 정상으로 종료되지 않았기 때문이다. 이 문제를 해결해 보자.

최종 리비전
우선 flask db heads 명령으로 현재 migrate 작업의 최종 리비전을 확인해 보자.

(myproject) c:\projects\myproject>flask db heads
4c3f98cdbcab (head)
현재 리비전
그런 다음 flask db current 명령으로 현재 시점의 리비전을 확인해 보자.

(myproject) c:\projects\myproject>flask db current
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
8f2a98320302
결과를 보면 알겠지만 "현재 시점의 리비전"과 "최종 리비전"이 같지 않다. 2개의 리비전이 다른 이유는 migrate 이후 upgrade를 실패했기 때문이다. 이 때문에 migrate 명령을 수행할 수 없는 것이다. 이 둘이 일치해야 migrate 작업을 진행할 수 있다.

현재 리비전을 최종 리비전으로 변경하기
앞에서 설명했듯 migrate 작업을 계속 진행하려면 flask db stamp heads 명령을 사용하여 현재 리비전을 최종 리비전으로 되돌려야 한다.

(myproject) c:\projects\myproject>flask db stamp heads
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running stamp_revision 8f2a98320302 -> 4c3f98cdbcab
리비전을 변경한 뒤 다시 flask db current 명령을 수행하자.

(myproject) c:\projects\myproject>flask db current
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
4c3f98cdbcab (head)
현재(current) 리비전이 최종(head) 리비전으로 되돌려진 것을 확인할 수 있다.


즉, 이 작업은 마지막에 수행했던 flask db migrate 작업을 취소한 것이다.

migrate, upgrade 다시 수행하기
다시 flask db migrate 명령과 flask db upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'question.user_id'
INFO  [alembic.autogenerate.compare] Detected added foreign key (user_id)(id) on table question
Generating c:\projects\myproject\migrations\versions\d4b2f566b87c_.py ...  done

(myproject) c:\projects\myproject>flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 4c3f98cdbcab -> d4b2f566b87c, empty message
오류 없이 잘 수행된다. 이제 데이터베이스에는 Question 모델 데이터 모두 user_id 속성에 '1'이 저장된다.

nullable=False
이제 비로소 Question 모델의 user_id 속성을 nullable=True에서 nullable=False로 변경할수 있다. 그리고 server_default는 필요하지 않으므로 제거하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    user = db.relationship('User', backref=db.backref('question_set'))
(... 생략 ...)
코드를 수정한 뒤 flask db migrate, flask db upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected NOT NULL on column 'question.user_id'
Generating c:\projects\myproject\migrations\versions\ce4336d5bbb6_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade d4b2f566b87c -> ce4336d5bbb6, empty message
지금까지 이미 데이터베이스에 저장된 데이터와 이와 관련된 모델이 변경되었을 때 처리하는 방법을 알아보았다. 여기서는 모델 속성에 nullable=False를 설정하는 방법을 알아보았다. migrate 명령을 사용하다 보면 뭔가 꼬이는 현상이 종종 발생한다. 이럴 때는 현재 데이터베이스의 변경 내역을 세심히 살펴보아야 한다.

Answer 모델에 글쓴이 추가하기

Answer 모델도 같은 방법으로 user_id 속성을 추가하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Answer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
    question = db.relationship('Question', backref=db.backref('answer_set'))
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=True, server_default='1')
    user = db.relationship('User', backref=db.backref('answer_set'))
(... 생략 ...)
user_id 속성에 nullable=True를 설정했다. 실습하면서 nullable=False 지정은 고생길이라는 것을 훤히 알았을 것이므로 nullable=True, server_default='1'이라고 설정하여 기본값을 저장한 다음에 진행하자.

다음처럼 migrate 명령과 upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected added column 'answer.user_id'
INFO [alembic.autogenerate.compare] Detected added foreign key (user_id)(id) on table answer
Generating c:\projects\myproject\migrations\versions\f1503ea99f7c_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade ce4336d5bbb6 -> f1503ea99f7c,empty message
Answer 모델에서 server_default는 제거하고 nullable=False로 변경하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Answer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
    question = db.relationship('Question', backref=db.backref('answer_set'))
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    user = db.relationship('User', backref=db.backref('answer_set'))
(... 생략 ...)
이어서 migrate, upgrade 명령을 순서대로 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected NOT NULL on column 'answer.user_id'
Generating c:\projects\myproject\migrations\versions\0fbf53a8e0af_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade f1503ea99f7c -> 0fbf53a8e0af, empty message
오류없이 잘 처리될 것이다.

질문, 답변 등록시 글쓴이 저장하기
Question, Answer 모델에 글쓴이 속성을 추가했으므로 질문과 답변을 등록할 때 글쓴이 정보를 저장할 수 있다.


답변 등록
먼저 답변 등록시 글쓴이를 저장하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime
from flask import Blueprint, url_for, request, render_template, g
from werkzeug.utils import redirect
(... 생략 ...)

@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    form = AnswerForm()
    question = Question.query.get_or_404(question_id)
    if form.validate_on_submit():
        content = request.form['content']
        answer = Answer(content=content, create_date=datetime.now(), user=g.user)
        question.answer_set.append(answer)
        db.session.commit()
        return redirect(url_for('question.detail', question_id=question_id))
    return render_template('question/question_detail.html', question=question, form=form)
g.user는 세션에 저장된 사용자 정보 데이터이다.

g.user는 auth_views.py 파일의 @bp.before_app_request 애너테이션에 의해 생성된다.

질문 등록
질문 등록도 마찬가지 방법으로 수정하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from datetime import datetime
from flask import Blueprint, render_template, request, url_for, g
from werkzeug.utils import redirect
(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    if request.method == 'POST' and form.validate_on_submit():
        question = Question(subject=form.subject.data, content=form.content.data,
                            create_date=datetime.now(), user=g.user)
        db.session.add(question)
        db.session.commit()
        return redirect(url_for('main.index'))
    return render_template('question/question_form.html', form=form)
이제 로그인 후에 질문과 답변을 등록해 보자. 문제 없이 잘 등록될 것이다.

login_required

그런데 로그아웃 상태에서 질문 또는 답변을 등록하면 다음과 같은 오류가 발생한다.

sqlalchemy.exc.IntegrityError
sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: question.user_id
[SQL: INSERT INTO question (subject, content, create_date, user_id) VALUES (?, ?, ?, ?)]
(... 생략 ...)
오류가 발생한 이유는 로그아웃 상태에서는 g.user의 값이 None이기 때문이다. 이 문제를 해결하려면 로그아웃 상태에서는 질문 또는 답변을 작성하려고 할 때 로그인을 먼저 진행할 수 있도록 로그인 페이지로 리다이렉트해야 한다. 그렇게 하려면 모든 질문, 답변 등록 함수의 시작 부분에 세션 값을 체크하여 사용자 정보가 없을 경우 로그인 페이지로 리다이렉트하는 코드를 추가해야 한다. 하지만 이런식으로 코드를 작성하면 코드가 중복되므로 무척 비효율적이다.

그러면 어떻게 해야 할까?

@login_required 데코레이터
auth_views.py 파일에 login_required라는 이름의 데코레이터 함수를 다음과 같이 만들어 보자.

[파일명: projects/myproject/pybo/views/auth_views.py]

import functools

(... 생략 ...)

def login_required(view):
    @functools.wraps(view)
    def wrapped_view(*args, **kwargs):
        if g.user is None:
            _next = request.url if request.method == 'GET' else ''
            return redirect(url_for('auth.login', next=_next))
        return view(*args, **kwargs)
    return wrapped_view
코드에서 보듯 데코레이터 함수는 기존 함수를 감싸는 방법으로 간단히 만들 수 있다. 이제 라우팅 함수에 @login_required 애너테이션을 지정하면 login_required 데코레이터 함수가 먼저 실행될 것이다. login_required 함수는 g.user가 있는지를 조사하여 없으면 로그인 URL로 리다이렉트 하고 g.user가 있으면 원래 함수를 그대로 실행할 것이다.

요청 방식이 GET인 경우에는 로그인 후에 원래 가려던 페이지로 다시 찾아갈수 있도록 로그인 페이지에 next 파라미터를 전달했다. 따라서 로그인 함수도 next 파라미터를 처리하기 위해 다음과 같이 수정해야 한다.

[파일명: projects/myproject/pybo/views/auth_views.py]

(... 생략 ...)
@bp.route('/login/', methods=('GET', 'POST'))
def login():
    form = UserLoginForm()
    if request.method == 'POST' and form.validate_on_submit():
        error = None
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            error = "존재하지 않는 사용자입니다."
        elif not check_password_hash(user.password, form.password.data):
            error = "비밀번호가 올바르지 않습니다."
        if error is None:
            session.clear()
            session['user_id'] = user.id
            _next = request.args.get('next', '')
            if _next:
                return redirect(_next)
            else:
                return redirect(url_for('main.index'))
        flash(error)
    return render_template('auth/login.html', form=form)
(... 생략 ...)    
로그인시 next 파라미터 값이 있으면 읽어서 로그인 후 해당 페이지로 이동하고 없으면 메인 페이지로 이동하게 했다.


@login_required 적용하기
로그인이 필요한 함수에 @login_required 데코레이터를 적용해 보자.

우선 질문 등록 함수에 적용하자.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
from pybo.views.auth_views import login_required

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
@login_required
def create():
    (... 생략 ...)
@login_required 데코레이터는 반드시 함수명 바로 위에 위치해야 한다. @login_required 데코레이터가 @bp.route 데코레이터보다 위에 위치할 경우 정상동작하지 않는다.

이어서 답변을 등록하는 함수에도 적용하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

(... 생략 ...)
from .auth_views import login_required
(... 생략 ...)

@bp.route('/create/<int:question_id>', methods=('POST',))
@login_required
def create(question_id):
    (... 생략 ...)
이제 로그아웃 상태에서 질문 또는 답변 등록을 시도하면 로그인 화면으로 리다이렉트될 것이다.





로그아웃 상태에서 답변 등록 불가능하게 만들기
한가지 더 생각해 봐야 할 것이 있다. 현재 질문 등록은 로그아웃 상태에서는 아예 글을 작성할 수 없어서 만족스럽다. 하지만 답변 등록은 로그아웃 상태에서도 글을 작성할 수 있다. 물론 답변 작성 후 <저장하기>를 누르면 자동으로 로그인 화면으로 이동되므로 큰 문제는 아니지만 작성한 답변이 사라지는 문제가 있다.

작성한 글이 사라지는 문제를 해결하려면 로그아웃 상태에서는 아예 답변 작성을 못하게 막는 것이 좋을 것이다. 답변 작성 템플릿에서 textarea 엘리먼트가 로그인 상태가 아닌 경우 disabled를 지정하여 입력 자체를 하지 못하도록 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    (... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        (... 생략 ...)
        <div class="mb-3">
            <textarea {% if not g.user %}disabled{% endif %}
                    name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
    </form>
</div>
{% endblock %}
이제 disabled 설정으로 textarea 엘리먼트가 비활성화될 것이다.



마지막 편집일시 : 2022년 8월 17일 8:20 오전

















































========================================================================================================================


1-03 플라스크 개발 환경 준비하기
[실습 영상] : https://youtu.be/UD-ox3sw6_o

이제 본격적으로 플라스크를 이용한 웹 개발 환경을 준비해 보자. 그전에 여러분이 알아야 할 중요한 개념이 하나 있다. 바로 파이썬 가상 환경이다. 우리는 플라스크를 파이썬 가상 환경에 설치할 것이다.

파이썬 가상 환경 알아보기
파이썬 가상 환경 사용해 보기
가상 환경 디렉터리 생성하기
가상 환경 만들기
가상 환경에 진입하기
가상 환경에서 벗어나기
플라스크 설치
가상 환경인지 확인하기
가상 환경에서 플라스크 설치하기
pip 최신 버전으로 설치하기

파이썬 가상 환경 알아보기
파이썬 가상 환경은 파이썬 프로젝트를 진행할 때 독립된 환경을 만들어 주는 고마운 도구다. 예를 들어 파이썬 개발자 A가 2개의 플라스크 프로젝트를 개발하고 관리한다고 가정하자. 파이썬 플라스크 프로젝트를 각각 P-1, P-2라고 부르겠다. 
이때 P-1, P-2에 필요한 플라스크의 버전이 다를 수 있다. 이를테면 P-1에는 플라스크 2.1 버전이, P-2에는 플라스크 1.2 버전이 필요할 수 있다. 이때 하나의 PC에 서로 다른 버전의 플라스크를 설치해야 하는 문제가 생긴다.

이러한 개발 환경은 구축하기도 어렵고 사용하기도 힘들다. 가상 환경이 없던 예전에는 그런 고생을 감수할 수밖에 없었다. 하지만 파이썬 가상 환경을 이용하면 하나의 PC 안에 독립된 가상 환경을 여러 개 만들 수 있다. 
즉, 프로젝트 P-1을 위해 가상 환경 V-1을 만들어 플라스크 2.1 버전을 설치하고, 프로젝트 P-2를 위해 가상 환경 V-2를 만들어 플라스크 1.2 버전을 설치해서 사용할 수 있다.

이처럼 가상2-09 표준 HTML과 템플릿 상속 사용해 보기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-09
[실습 영상] : https://youtu.be/RMAv052dcSM
혹시 눈치챘는지 모르겠지만 우리가 지금까지 작성한 질문 목록과 질문 상세 템플릿 파일은 표준 HTML 구조가 아니다. 어떤 운영체제나 브라우저를 사용하더라도 웹 페이지가 동일하게 보이고 정상적으로 동작하게 하려면 반드시 웹 표준을 지키는 HTML 문서를 작성해야 한다.

표준 HTML 구조는 어떻게 생겼을까?
템플릿을 표준 HTML 구조로 바꾸기
템플릿 파일의 기본 틀 작성하기
질문 목록 템플릿 수정하기
질문 상세 템플릿 파일 수정하기
표준 HTML 구조 확인하기
기존 스타일 파일 내용 비우기
표준 HTML 구조는 어떻게 생겼을까?
표준 HTML 문서의 구조는 다음과 같아야 한다.

[표준 HTML 구조의 예]

<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
    <!-- pybo CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Hello, pybo!</title>
</head>
<body>
(... 생략 ...)
</body>
</html>
표준 HTML 문서의 구조는 위와 같이 html, head, body 엘리먼트가 있어야 하고 CSS 파일 링크는 head 엘리먼트 안에 있어야 한다. 또한 head 엘리먼트 안에는 meta, title 엘리먼트 등이 포함되어야 한다.

점프 투 플라스크
**태그와 엘리먼트 **
<table> (... 생략 ...) </table>  <!-- table 엘리먼트 -->
위에서 <table>은 table 태그이고 <table> ~ </table> 처럼 table 태그로 시작해서 table 태그로 닫힌 구간(Block)은 table 엘리먼트이다.

템플릿을 표준 HTML 구조로 바꾸기
앞에서 작성한 질문 목록, 질문 상세 템플릿을 표준 HTML 구조가 되도록 수정해 보자. 그런데 템플릿 파일들을 모두 표준 HTML 구조로 변경하면 body 엘리먼트 바깥 부분(head 엘리먼트 등)은 모두 같은 내용으로 중복될 것이다. 그러면 CSS 파일 이름이 변경되거나 새로운 CSS 파일이 추가될 때마다 모든 템플릿 파일을 일일이 수정해야 한다.

플라스크는 이런 불편함을 해소하기 위한 템플릿 상속(extends) 기능을 제공한다. 여기서는 단순히 템플릿을 표준 HTML 구조로 바꿀 뿐 아니라 템플릿 상속 기능까지 사용할 것이다.

그러면 파일을 하나씩 수정해 보자.


템플릿 파일의 기본 틀 작성하기
우선 템플릿 파일의 기본 틀이 되는 base.html 템플릿을 작성하자. 모든 템플릿에서 공통으로 입력할 내용을 여기에 포함한다고 생각하면 된다.

[파일명: projects/myproject/pybo/templates/base.html]

<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
    <!-- pybo CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Hello, pybo!</title>
</head>
<body>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
</body>
</html>
body 엘리먼트에 {% block content %}와 {% endblock %} 템플릿 태그가 보일 것이다. 바로 이 부분이 base.html 템플릿 파일을 상속한 템플릿에서 구현해야 할 영역이 된다.

질문 목록 템플릿 수정하기
질문 목록을 나타내는 question_list.html 템플릿 파일을 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
    </table>
</div>
{% endblock %}
base.html 템플릿 파일을 상속받고자 {% extends 'base.html' %} 템플릿 태그를 사용했다. 그리고 {% block content %}와 {% endblock %} 사이에 question_list.html에서만 사용할 내용을 작성했다. 그리고 기존에 bootstrap.min.css 파일을 링크했던 첫번째 라인은 더이상 필요없으므로 삭제하자. 왜냐하며 base.html 기본 템플릿에 이미 해당 라인이 포함되어 있기 때문이다.

이제 question_list.html은 base.html을 상속받았으므로 표준 HTML 구조를 갖추게 된다.

질문 상세 템플릿 파일 수정하기

질문 상세를 나타내는 question_detail.html 파일도 마찬가지 방법으로 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    (... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        (... 생략 ...)
    </form>
</div>
{% endblock %}
{% extends 'base.html' %} 템플릿 태그를 맨 위에 추가하고 기존 내용 위 아래로 {% block content %}와 {% endblock %}를 작성했다.

표준 HTML 구조 확인하기
템플릿 상속을 적용한 후 질문 목록, 질문 상세를 조회해 보자. 화면에 보여지는 것은 동일하지만 표준 HTML 구조로 변경된 것을 확인할 수 있다.

브라우저에서 소스보기 기능으로 생성된 HTML을 확인할 수 있다.

[질문 목록 - 브라우저 소스보기 화면]



기존 스타일 파일 내용 비우기
부트스트랩을 사용하게 되었으므로 style.css 파일의 내용을 비우자. 이 파일은 이후 부트스트랩으로 표현할 수 없는 스타일을 위해 사용할 것이므로 파일 자체를 삭제하지 말고 내용만 비워 두자.

[파일명: projects/myproject/pybo/static/style.css]

textarea {
    width:100%;
}

input[type=submit] {
    margin-top:10px;
}
마지막 편집일시 : 2022년 8월 10일 1:10 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-10 폼 모듈로 데이터 검증 더 쉽게 하기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-10
[실습 영상] : https://youtu.be/gPo1p7mwxMc
웹 프로그램에서 폼(form)은 사용자에게 입력 양식을 편리하게 제공하기 위해 사용한다. 이번에는 플라스크의 폼 모듈을 어떻게 사용하는지 알아보자. 폼 모듈을 사용하면 폼으로 전송되는 데이터의 필수 여부, 길이, 형식 등을 더 쉽게 검증할 수 있다.

플라스크 폼 모듈 설치하기
질문 등록
질문 등록 버튼 만들기
질문 폼 만들기
질문 등록 라우팅 함수 추가하기
질문 등록 템플릿 작성하기
질문 등록 기능 사용해 보기
질문 전송 방식 수정하기
폼 데이터를 저장하는 코드 작성하기
폼에 부트스트랩 적용하기
수작업으로 폼 작성하기
질문 등록 완성하기
오류 내용을 표시해 원인 알아내기
CSRF 토큰 오류 처리하기
입력한 값 유지하고 오류 메시지 한글로 바꾸기
입력한 값 유지하기
오류 메시지 한글로 바꾸기
답변 등록에 폼 사용하기
답변 등록 폼 추가하기
답변 등록 라우팅 함수 수정하기
CSRF 코드와 오류 표시 기능 추가하기
플라스크 폼 모듈 설치하기
플라스크에서 폼을 사용하려면 Flask-WTF 라이브러리를 설치해야 한다. 명령 프롬프트에서 다음 명령으로 Flask-WTF를 설치하자.

(myproject) c:\projects\myproject> pip install flask-wtf
Collecting Flask-WTF
    (... 생략 ...)
그리고 Flask-WTF를 사용하려면 플라스크의 환경변수 SECRET_KEY가 필요하다.

점프 투 플라스크
SECRET_KEY
SECRET_KEY는 CSRF(cross-site request forgery)라는 웹 사이트 취약점 공격을 방지하는 데 사용된다. CSRF는 사용자의 요청을 위조하는 웹 사이트 공격 기법인데 SECRET_KEY를 기반으로 해서 생성되는 CSRF 토큰은 폼으로 전송된 데이터가 실제 웹 페이지에서 작성된 데이터인지를 판단해 주는 가늠자 역할을 한다. 플라스크에서 CSRF 토큰을 어떻게 사용하는지는 잠시 후에 알아보자.

CSRF 토큰은 쉽게 말해 CSRF를 방어하려고 플라스크에서 생성하는 무작위 문자열이다. CSRF 토큰이라는 명칭 때문에 "공격 기술에 사용하는 요소"라고 오해하지 않길 바란다.

먼저 config.py 파일을 열고 마지막 줄에 SECRET_KEY 변수를 추가하자.

[파일명: projects/myproject/config.py]

import os

BASE_DIR = os.path.dirname(__file__)

SQLALCHEMY_DATABASE_URI = 'sqlite:///{}'.format(os.path.join(BASE_DIR, 'pybo.db'))
SQLALCHEMY_TRACK_MODIFICATIONS = False
SECRET_KEY = "dev"
사실 SECRET_KEY = "dev"는 위험한 설정이다. 실제 서비스를 운영할 때에는 "dev"처럼 유추하기 쉬운 문자열을 입력하면 안 된다. 물론 현재는 개발환경이므로 괜찮다. 서비스 운영 환경에서 SECRET_KEY를 설정하는 방법은 뒤에서 자세히 알아보자.

질문 등록

이제 파이보에 질문을 등록할수 있도록 만들어 보자. 참고로 질문 등록은 이번 장 끝까지 진행해야 완벽하게 동작한다. (왜냐하면 맨 마지막에 진행하는 CSRF 설정까지 끝나야만 질문 등록이 정상동작하기 때문이다.)

질문 등록 버튼 만들기
우선 다음처럼 질문 목록 템플릿을 열고 </table> 태그 아래에 질문등록 버튼을 생성하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

(... 생략 ...)
    </table>
    <a href="{{ url_for('question.create') }}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}
질문 폼 만들기
질문 목록 화면에 질문 등록 URL을 추가했으므로 question_views.py 파일에 라우팅 함수 create를 추가해야 한다. 하지만 create 함수를 작성하기 전에 질문 등록시 사용할 QuestionForm을 먼저 만들어 보자.

QuestionForm은 질문을 등록할 때 사용할 플라스크의 폼(Form)이다.

pybo 디렉터리에 forms.py 파일을 새로 만든 다음 QuestionForm을 다음처럼 작성하자.

[파일명: projects/myproject/pybo/forms.py]

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms.validators import DataRequired

class QuestionForm(FlaskForm):
    subject = StringField('제목', validators=[DataRequired()])
    content = TextAreaField('내용', validators=[DataRequired()])
질문을 등록할 때 사용할 QuestionForm을 만들었다. QuestionForm과 같은 플라스크의 폼은 FlaskForm 클래스를 상속하여 만들어야 한다.


QuestionForm의 속성은 "제목"과 "내용"이다. 글자수의 제한이 있는 "제목"의 경우 StringField를 사용하고 글자수의 제한이 없는 "내용"은 TextAreaField를 사용한다. 플라스크에서 사용할 수 있는 폼 속성에 대한 보다 자세한 내용은 다음 URL을 참고하자.

https://wtforms.readthedocs.io/en/2.3.x/fields/#basic-fields
StringField('제목', validators=[DataRequired()]) 에서 첫번째 입력인수인 "제목"은 폼 라벨(Label)이다. 템플릿에서 이 라벨을 이용하여 "제목"이라는 라벨을 출력할 수 있다. 이 부분은 잠시후에 다시 알아보기로 하자. 두번째 입력인수는 validators이다. validators는 검증을 위해 사용되는 도구로 필수 항목인지를 체크하는 DataRequired, 이메일인지를 체크하는 Email, 길이를 체크하는 Length등이 있다. 예를들어 필수값이면서 이메일이어야 하면 validators=[DataRequired(), Email()] 과 같이 사용할 수 있다. 플라스크에서 사용할 수 있는 validators에 대한 보다 자세한 내용은 다음 URL을 참고하자.

https://wtforms.readthedocs.io/en/2.3.x/validators/#built-in-validators
질문 등록 라우팅 함수 추가하기
그리고 question_views.py 파일에 라우팅 함수 create를 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from pybo.forms import QuestionForm

(... 생략 ...)

@bp.route('/create/')
def create():
    form = QuestionForm()
    return render_template('question/question_form.html', form=form)
question_form.html 템플릿에 전달하는 QuestionForm의 객체(form)는 템플릿에서 라벨이나 입력폼 등을 만들때 필요하다.

질문 등록 템플릿 작성하기
이제 질문을 등록하는 템플릿을 만들어 보자. pybo/templates/question 디렉터리에 question_form.html 파일을 만들고 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post" class="my-3">

        {{ form.subject.label }}
        {{ form.subject() }}

        {{ form.content.label }}
        {{ form.content() }}

        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
질문 등록을 위해서는 질문의 제목과 내용이라는 입력항목이 필요하다. 위의 템플릿에서는 질문의 제목과 내용에 해당하는 입력 항목을 form 객체를 사용해서 만들었다. QuestionForm에서 작성한 두개의 필드 subject와 content가 템플릿에서 사용되었다. {{ form.subject.label }} 는 라벨을 표시하고 {{ form.subject() }}는 입력폼을 표시한다.


질문 등록 기능 사용해 보기
웹 브라우저에서 질문 등록 기능을 확인해 보자.

http://localhost:5000/question/list에 접속해 보면 질문 목록 화면에 <질문 등록하기> 버튼이 추가되었다.



여기서 <질문 등록하기> 버튼을 누르면 다음처럼 질문 등록 화면이 나타난다.



QuestonForm 객체가 자동으로 만들어 준 입력 항목(제목과 내용)이 보인다. 각 항목에 값을 입력하고 <저장하기> 버튼을 눌러 보자.

하지만 다음처럼 ‘Method NotAllowed’ 오류 화면이 나타날 것이다.



위와 같은 오류 화면이 나타난 이유는 현재 폼이 POST 방식으로 데이터를 전송하기 때문이다. 다음은 위에서 작성한 질문 등록을 위한 question_form.html 템플릿의 폼 태그이다.


<form method="post" class="my-3">
코드에서 보듯 form 태그의 method 속성이 “post”이므로 폼에 입력한 데이터는 POST 방식로 전송된다. 그런데 현재 create 라우팅 함수에는 별도의 method 속성을 지정하지 않았으므로 기본 처리 방식인 GET 방식만 처리할 수 있다. 즉, POST 방식으로 데이터를 처리하게 하려면 create 함수의 라우팅 정보를 수정해야 한다.

점프 투 플라스크
action 속성을 지정하지 않은 이유
잠깐, 다음으로 진행하기 전에 한 가지 눈여겨 보아야 할 부분이 있다. 그것은 바로 <form method="post"> 처럼 form 태그에 action 속성을 지정하지 않았다는 점이다. 보통 form 태그에는 항상 action 속성을 지정하여 submit 실행시 action에 정의된 URL로 폼을 전송해야 한다. 하지만 여기서는 특별하게 action 속성을 지정하지 않았다. form 태그에 action 속성을 지정하지 않으면 현재 페이지의 URL이 디폴트 action으로 설정된다.

물론 action 속성을 다음처럼 명확하게 지정해도 된다.

<form method="post" action="{{ url_for('question.create') }}">
하지만 이렇게 하면 action 속성을 지정하면 question_form.html 템플릿은 "질문 등록" 에서만 사용 가능하다. 이후에 진행할 "질문 수정" 에서는 이 템플릿을 활용할 수가 없다. 왜냐하면 질문 수정일 경우에는 action 값을 달리해야 하기 때문이다. 동일한 템플릿을 여러 기능에서 함께 사용할 경우에는 이처럼 form의 action 속성을 비워두는 트릭을 종종 사용한다. 우리는 이후에 "질문 수정" 기능을 구현할 때도 question_form.html 템플릿을 사용할 것이므로 action 속성은 비워두도록 하자.

form에 action을 사용하지 않는 이유에 대해서는 질문 수정시에도 다시 한번 설명한다.

질문 전송 방식 수정하기
create 함수가 GET과 POST 방식을 모두 처리할수 있도록 라우팅 애너테이션에 methods 속성을 추가하자.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    return render_template('question/question_form.html', form=form)
그런 다음 질문 등록 화면에서 <저장하기> 버튼을 다시 한번 눌러 보자. 그러면 이제 오류는 발생하지 않을 것이다. 하지만 여전히 아무런 반응 없이 질문 등록 화면만 보인다. 왜냐하면 create 함수에 데이터를 저장하는 코드를 아직 작성하지 않았기 때문이다.


이제 템플릿에서 전송한 폼 데이터를 저장하는 코드를 작성해 보자.

폼 데이터를 저장하는 코드 작성하기
create 함수에 POST 방식으로 요청된 폼 데이터를 데이터베이스에 저장하는 코드를 추가하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from datetime import datetime

from flask import Blueprint, render_template, request, url_for
from werkzeug.utils import redirect

from .. import db
from ..models import Question
from ..forms import QuestionForm

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    if request.method == 'POST' and form.validate_on_submit():
        question = Question(subject=form.subject.data, content=form.content.data, create_date=datetime.now())
        db.session.add(question)
        db.session.commit()
        return redirect(url_for('main.index'))
    return render_template('question/question_form.html', form=form)
if 문의 request.method는 create 함수로 요청된 전송 방식을 의미한다. 그리고 form.validate_on_submit 함수는 전송된 폼 데이터의 정합성을 점검한다. 즉, QuestionForm 클래스의 각 속성에 지정한 DataRequired() 같은 점검 항목에 이상이 없는지 확인한다. 즉, 위 코드에 추가한 내용은 POST 요청이고 폼 데이터에 이상이 없을 경우 질문을 저장한 뒤 main.index 페이지로 이동하라는 내용이다.

코드를 보면 폼으로부터 전달받은 "제목"에 해당하는 데이터는 form.subject.data로 얻고 있다. form.content.data도 마찬가지이다.

방금 추가한 코드의 핵심은 데이터 전송 방식이 POST인지 GET인지에 따라서 달리 처리하는 부분이다. 질문 목록에서 <질문 등록하기> 버튼을 누르거나 질문 등록 화면에서 <저장하기> 버튼을 누르면 똑같이 localhost:5000/question/create/ 페이지를 요청하므로 create 함수가 이 요청을 받는다. 다만 create 함수에서 요청 방식을 구분해서 처리한다. 즉, <질문 등록하기> 버튼을 누르는 것은 GET 방식 요청이므로 질문 등록 화면을 보여 주고, <저장하기>버튼을 누르면 POST 방식 요청이므로 데이터베이스에 질문을 저장한다.

그런데 여기까지 작성하고 <저장하기> 버튼을 눌러도 제대로 동작하지 않는다. 이 문제는 잠시 후에 해결하기로 하고 먼저 폼에 부트스트랩을 적용해 보자.

CSRF 문제를 해결해야 저장이 가능하다. 이것은 뒤에서 자세히 알아보자.

폼에 부트스트랩 적용하기

앞서 화면을 깔끔하게 만들어 주는 부트스트랩을 도입했는데, {{ form.subject() }}와 같은 코드는 폼이 HTML을 자동으로 생성하므로 부트스트랩을 적용할 수 없다. 하지만 템플릿을 조금 수정하면 부트스트랩을 어느정도 적용할 수 있다. form.subject나 form.content에 부트스트랩 클래스 class="form-control"을 적용해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
{{ form.subject.label }}
{{ form.subject(class="form-control") }}

{{ form.content.label }}
{{ form.content(class="form-control") }}
(... 생략 ...)
이와같이 수정하면 다음처럼 부트스트랩 클래스가 적용된 질문등록 화면을 볼 수 있다.



수작업으로 폼 작성하기
앞에서 {{ form.subject() }}처럼 폼을 생성하는 HTML 코드를 자동으로 생성하도록 했다. 하지만 이 방식은 폼을 빠르게 만드는 데는 도움이 되지만 내가 원하는 디자인을 적용하기가 어렵다. 이러한 단점을 보완하고자 이번에는 HTML을 직접 작성하는 방식으로 질문 등록 기능을 완성해 보자.

폼을 자동으로 만드는 코드는 디자인과 프로그램 영역이 혼재되므로 웹 디자이너와 개발자의 역할 분리도 모호해진다.

question_form.html 파일을 열고 form 엘리먼트의 내용을 다음처럼 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
(... 생략 ...)
    <form method="post" class="my-3">
        <div class="mb-3">
            <label for="subject">제목</label>
            <input type="text" class="form-control" name="subject" id="subject">
        </div>
        <div class="mb-3">
            <label for="content">내용</label>
            <textarea class="form-control" name="content" id="content" rows="10"></textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
{{ form.subject() }}와 같이 자동으로 생성되는 HTML 대신 제목과 내용에 해당되는 HTML코드를 직접 작성하였다. 이렇게 수정하면 다음과 같은 질문등록 화면을 볼 수 있다.




HTML 코드를 자동으로 생성하는 방식과 수동으로 작성하는 방식을 모두 실습했다. 어떤 방식이 옳은지 정답은 없으므로 프로젝트 성격에 적합한 방식을 골라 사용하면 된다. 다만 이 책에서는 HTML을 직접 작성하는 방식으로 화면을 구성할 것이다.

질문 등록 완성하기
앞선 실습에서 데이터를 데이터베이스에 저장하는 기능을 추가했지만, 질문 등록 화면에서 <저장하기>를 눌러도 화면에는 아무런 변화가 없었다. 이번 실습에서 그 이유를 알아보고 보완해서 질문 등록 기능을 완성해 보자.

오류 내용을 표시해 원인 알아내기
질문 등록 화면에서 <저장하기>를 눌러도 화면에 아무런 변화가 없으니 무엇이 잘못됐는지 알기 어렵다. 이러한 점을 보완하고자 오류 내용을 표시하도록 질문 등록 템플릿을 다음처럼 수정해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
    <form method="post" class="post-form my-3">
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field, errors in form.errors.items() %}
            <strong>{{ form[field].label }}</strong>
            <ul>
                {% for error in errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="form-group">
(... 생략 ...)
오류를 표시할 수 있는 영역을 위와 같이 추가했다. create함수에서 form.validate_on_submit() 코드가 실패(false 반환)하면 폼에는 오류 내용이 자동으로 등록된다. 등록된 오류는 form.errors 속성을 사용하여 위와 같이 표시할 수 있다. form.errors.items 의 field는 subject나 content와 같은 입력 폼의 필드를 의미한다.

이렇게 수정하고 질문등록화면에 아무런 값도 입력하지 않고 <저장하기> 버튼을 클릭해 보자. 아마도 다음과 같이 오류를 확인할 수 있는 화면을 볼수 있을 것이다.




제목과 내용 필드에 발생한 오류 메시지는 값을 입력하라는 뜻으로 쉽게 이해할 수 있다. 그런데 "CSRF Token" 오류는 무엇일까? 앞서 언급했듯 CSRF는 보안 관련 항목으로, form 엘리먼트를 통해 전송된 데이터가 실제 웹 사이트에서 만들어진 데이터인지 검증하는 데 필요한 CSRF 토큰이 빠졌다는 의미다.

CSRF 토큰 오류 처리하기
form 태그 바로 밑에 {{ form.csrf_token }} 코드를 삽입하여 CSRF 토큰 오류에서 탈출해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
(... 생략 ...)
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post" class="my-3">
        {{ form.csrf_token }}
        (... 생략 ...)
    </form>
(... 생략 ...)
이제 코드를 저장하고 질문 등록 페이지의 각 필드를 채운 후 <저장하기>를 눌러 질문을 등록해 보자. 질문 목록 화면으로 이동하고 방금 등록한 질문이 보이면 성공한 것이다.



입력한 값 유지하고 오류 메시지 한글로 바꾸기
이제 질문 등록 기능이 제대로 동작한다. 그런데 질문을 등록할 때 제목은 입력하고 내용은 입력하지 않으면 오류 메시지가 나타나면서 입력한 내용(제목)이 사라진다. 그래서 다시 입력해야 하는 불편함이 있다.

이 문제를 해결해 보자.

입력한 값 유지하기

폼을 전송했을 때 오류가 있더라도 이미 입력한 값을 유지하도록 질문 폼 템플릿을 다음처럼 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
        <div class="mb-3">
            <label for="subject">제목</label>
            <input type="text" class="form-control" name="subject" id="subject"
                value="{{ form.subject.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="content">내용</label>
            <textarea class="form-control" name="content"
                id="content" rows="10">{{ form.content.data or '' }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
(... 생략 ...)
subject 필드의 value값으로 {{ form.subject.data or '' }}를 입력하면 이미 전송한 데이터가 다시 설정된다. {{ form.subject.data or '' }}에서 or ''은 "현재 템플릿이 GET 방식으로 요청되는 경우 기존 입력값이 없으므로(None으로 출력) 이를 방지하기 위해서" 사용했다. 즉, 이렇게 하면 form.subject.data에 값이 없을 때 None이 아니라 ''이 출력된다. content필드에도 마찬가지 방법이 적용되었다.

이제 제목에만 값을 입력하고 <저장하기>를 눌러 보자. 그러면 내용도 입력하라는 오류가 표시되지만, 제목에 입력한 값이 더이상 사라지지 않는다.



오류 메시지 한글로 바꾸기
이번에는 필수 항목을 입력하지 않았을 때 발생하는 오류 메시지를 우리말로 바꾸어 보자. forms.py 파일을 열어 DataRequired에 한글 메시지를 설정하자.

[파일명: projects/myproject/pybo/forms.py]

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms.validators import DataRequired

class QuestionForm(FlaskForm):
    subject = StringField('제목', validators=[DataRequired('제목은 필수입력 항목입니다.')])
    content = TextAreaField('내용', validators=[DataRequired('내용은 필수입력 항목입니다.')])
이제 필수 입력 항목을 빠뜨리고 질문을 등록하면 오류 메시지가 한글로 나타난다.














 환경을 이용하면 하나의 PC에 서로 다른 버전의 파이썬과 라이브러리를 쉽게 설치해 사용할 수 있다. 물론 이 책에서는 "파이보"라는 하나의 프로젝트만 진행할 것이므로 가상 환경이 필수는 아니다. 
하지만 앞으로 웹 프로그래밍을 계속하고 싶다면 가상 환경의 개념을 익히고 실제로 사용해 보는 것이 좋다.

파이썬 가상 환경 사용해 보기
파이썬 가상 환경에 플라스크를 설치하기 위해 먼저 내 컴퓨터에 파이썬 가상 환경부터 만들어 보자.

가상 환경 디렉터리 생성하기
윈도우에서 명령 프롬프트를 실행하고 다음 명령어를 입력해 C:\venvs라는 디렉터리를 만들자.

C:\Users\pahkey> cd \
C:\> mkdir venvs
C:\> cd venvs
맥(Mac) 사용자의 경우에는 홈 디렉터리(예:/Users/pahkey) 밑에 venvs 디렉터리를 생성하자.

venvs 디렉터리는 파이썬 가상 환경의 루트 디렉터리로 사용할 것이다. 만약 또 다른 가상 환경을 추가하고 싶다면 이 디렉터리 아래에 설치하면 된다. 쉽게 말해 모든 가상 환경은 이 디렉터리 안에 만들어진다고 생각하면 된다. 
루트 디렉터리를 반드시 C:\venvs로 해야 하는 것은 아니지만 실습 편의를 위해 이대로 지정하자.

가상 환경 만들기
파이썬 가상 환경을 만들어 주는 다음 명령어를 입력해 실행하자.

C:\venvs> python -m venv myproject

명령에서 python -m venv는 파이썬 모듈 중 venv라는 모듈을 사용한다는 의미다. 그 뒤의 myproject는 여러분이 생성할 가상 환경의 이름이다. 가상환경의 이름을 반드시 myproject로 지을 필요는 없다. 
만약 가상 환경의 이름을 awesomesite와 같이 지정했다면 책에 등장하는 myproject라는 가상 환경 이름을 awesomesite로 대체하여 읽으면 된다.

하지만 실습 진행의 편의를 위해 가상 환경 이름을 동일하게 하기를 권장한다.

명령을 잘 수행했다면 C:\venvs 디렉터리 아래에 myproject라는 디렉터리가 생성되었을 것이다. 이 디렉터리를 가상 환경이라 생각하면 된다. 그런데 가상 환경을 만들었다 해서 바로 가상 환경을 사용할 수는 없다. 
가상환경을 사용하려면 가상 환경에 진입해야 한다.

가상 환경에 진입하기
가상 환경에 진입하려면 우리가 생성한 myproject 가상 환경에 있는 Scripts 디렉터리의 activate라는 명령을 수행해야 한다. 다음 명령을 입력해 myproject 가상 환경에 진입해 보자.

C:\venvs> cd C:\venvs\myproject\Scripts
C:\venvs\myproject\Scripts> activate
(myproject) C:\venvs\myproject\Scripts>
그러면 C:\ 왼쪽에 (myproject)라는 프롬프트를 확인할 수 있다. 이 프롬프트는 앞에서 만든 가상 환경의 이름으로 현재 여러분이 진입한 가상 환경을 의미한다. 이로써 현재 어떤 가상 환경에 진입한 상태인지 알 수 있다.

가상 환경에서 벗어나기

만약 현재 진입한 가상 환경에서 벗어나려면 deactivate라는 명령을 실행하면 된다. 이 명령은 어느 위치에서 실행해도 상관없다.

(myproject) C:\venvs\myproject\Scripts> deactivate
C:\venvs\myproject\Scripts>
가상 환경에서 잘 벗어났다면 C:\ 왼쪽에 있던 (myproject)라는 프롬프트가 사라졌을 것이다. 지금까지 가상 환경의 개념과 실습을 진행해 보았다. 
가상 환경이라는 개념이 조금은 생소하겠지만 익혀두면 여러분의 웹 프로그래밍 경험에 도움이 될 것이다.

점프 투 플라스크
맥 OS에서 가상환경 진입하기
venvs 디렉터리(예:/Users/pahkey/venvs)에서 다음의 명령을 수행하면 가상환경으로 진입할수 있다.

pahkey@mymac venvs % cd myproject/bin
pahkey@mymac bin % source activate
(myproject) pahkey@mymac bin %
현재 진입한 가상 환경에서 벗어나려면 deactivate라는 명령을 실행하면 된다.

(myproject) pahkey@mymac bin % deactivate
pahkey@mymac bin %
플라스크 설치
드디어 플라스크를 설치할 차례가 왔다. 앞에서 만든 myproject 가상 환경에 진입하여 플라스크를 설치해 보자.

가상 환경인지 확인하기
명령 프롬프트 왼쪽에 (myproject) 프롬프트가 보이는지 확인하자. 만약 명령 프롬프트 왼쪽에 (myproject) 프롬프트가 보이지 않는다면 바로 이전의 실습을 참고하여 가상 환경에 진입한 상태에서 플라스크 설치를 진행하자.


C:\venvs\myproject\Scripts> activate
(myproject) C:\venvs\myproject\Scripts>
가상 환경에서 플라스크 설치하기
myproject 가상 환경에 진입한 상태에서 pip install Flask 명령을 입력하자. pip은 파이썬 라이브러리를 설치하고 관리해 주는 파이썬 도구다. pip install flask 명령은 pip을 이용해 플라스크를 설치하라는 명령어라고 생각하면 된다. 
다음 화면이 나오면 플라스크가 잘 설치된 것이다.

- pip은 '핍'이라 읽는다.

(myproject) C:\venvs\myproject\Scripts> pip install flask
Collecting Flask
Using cached
(... 생략 ...)
WARNING: You are using pip version 20.1.1; however, version 20.2.2 is available.
You should consider upgrading via the ‘c:\venvs\myproject\scripts\python.exe -m pip
install --upgrade pip’ command.
그런데 마지막에 다음과 같은 경고 문구가 보인다. pip이 최신 버전이 아니라는 내용이다.

pip 최신 버전으로 설치하기
경고 메시지에 따라 다음 명령을 입력해 pip을 최신 버전으로 설치하자.

(myproject) C:\venvs\myproject\Scripts> python -m pip install --upgrade pip
Collecting pip
(... 생략 ...)
Successfully uninstalled pip-20.1.1
Successfully installed pip-20.2.2
마지막 편집일시 : 2022년 8월 9일 5:00 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1-04 플라스크 프로젝트 생성하기
[실습 영상] : https://youtu.be/pfKecwaQYBk

플라스크에서 프로젝트는 하나의 웹 사이트라고 생각하면 된다. 즉, 플라스크 프로젝트를 생성하면 웹 사이트를 한 개 생성하는 것과 같다. 
그리고 플라스크 프로젝트 안에는 보통 한 개의 플라스크 애플리케이션이 존재하는데 플라스크 애플리케이션이 무엇인지는 조금 후에 자세히 알아보자.

프로젝트 디렉터리 생성하기
배치 파일로 myproject 가상 환경에 간단히 진입하기
배치 파일 생성하기
배치 파일 위치를 PATH 환경 변수에 추가하기
PATH 환경 변수 확인하기
배치 파일 실행하여 가상 환경에 진입하기
프로젝트 디렉터리 생성하기
플라스크 프로젝트는 여러 개가 될 수 있으므로 프로젝트를 모아 둘 프로젝트 루트 디렉터리 생성은 필수다. 이 책은 C:\projects 디렉터리를 프로젝트들의 루트 디렉터리로 정하고 진행하겠다.

C:\> mkdir projects
C:\> cd projects
맥 OS는 홈 디렉터리(예:/Users/pahkey) 하위에 projects 디렉터리를 생성하여 진행하자.

그리고 프로젝트 루트 디렉터리 안에서 다음 명령어를 입력해 앞에서 만든 myproject 가상 환경에 진입하자. 가상 환경 진입 명령어가 길어서 좀 불편하겠지만 지금은 이 방법으로 가상 환경에 진입하겠다.

가상 환경 진입 명령어를 간단하게 만드는 팁은 이 절의 마지막에서 설명한다.

C:\projects> C:\venvs\myproject\Scripts\activate
(myproject) C:\projects>
그리고 플라스크 프로젝트를 담을 myproject 디렉터리를 생성하고 이동하자.

(myproject) C:\projects> mkdir myproject
(myproject) C:\projects> cd myproject
(myproject) C:\projects\myproject>
myprojects가 아니고 myproject이므로 디렉터리명에 주의하자.

배치 파일로 myproject 가상 환경에 간단히 진입하기
myproject 가상 환경에 진입하려면 매번 명령 프롬프트를 실행하고 C:\venvs\myproject\Scripts 디렉터리에 있는 activate 명령을 수행해야한다. 이런 일련의 과정을 한번에 수행할 수 있는 배치 파일을 만들어 편리하게 이용해 보자.

배치 파일 생성하기
venvs 디렉터리에 myproject.cmd 파일을 만들고 다음처럼 작성한 후 저장하자.

여러분이 좋아하는 텍스트 편집기를 이용해서 파일을 생성해 보자.
[파일명: C:/venvs/myproject.cmd]

@echo off
cd c:/projects/myproject
c:/venvs/myproject/scripts/activate

윈도우에서 확장자 .cmd가 붙은 파일을 배치(batch) 파일이라고 한다. 배치 파일은 여러 명령어를 한번에 실행해 주는 파일이라고 생각하면 된다. 
myproject.cmd 배치 파일의 내용은 C:/projects/myproject 디렉터리로 이동한 다음, C:/venvs/myproject/activate 명령을 수행하라는 뜻이다.

배치 파일 위치를 PATH 환경 변수에 추가하기
이 배치 파일이 명령 프롬프트 어느 곳에서나 수행될 수 있도록 C:\venvs 디렉터리를 시스템의 환경 변수 PATH에 추가해야 한다. 먼저 <윈도우+R> 키를 입력하여 다음처럼 sysdm.cpl 명령을 입력한 다음 <확인>을 누르자.
그러면 다음과 같은 ‘시스템 속성’ 창이 나타난다. 여기서 <고급> 탭을 선택하고 <환경 변수> 버튼을 누르자.
그러면 다음과 같은 ‘환경 변수’ 창이 나타난다. 여기서 사용자 변수 중 <Path>를 선택하고 <편집> 버튼을 누르자.
그러면 다음과 같은 ‘환경 변수 편집’ 창이 나타난다. 여기서 <새로 만들기(N)> 버튼을 누르자.

그리고 다음 그림처럼 C:\venvs라는 디렉터리를 추가하고 <확인> 버튼을 누르자.
마지막으로 다음 ‘환경 변수’ 창에서 <확인> 버튼을 누르자.

PATH 환경 변수 확인하기
이렇게 하면 환경 변수 PATH에 C:\venvs 디렉터리가 추가되어 myproject.cmd 명령을 어디서든 실행할 수 있다. 명령 프롬프트를 다시 시작하자(그래야 변경된 환경 변수 PATH가 제대로 반영된다). 
그리고 set path 명령을 실행하여 변경된 환경 변수 PATH의 내용을 확인해 보자. C:\venvs라는 디렉터리가 환경 변수 PATH에 포함되어 있으면 된다.

C:\Users\pahkey> set path
Path=C:\Windows\system32; (... 생략 ...) ;C:\venvs
PATHEXT=.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC
배치 파일 실행하여 가상 환경에 진입하기

이제 지금까지 만든 myproject 명령(배치 파일명)을 실행하여 가상 환경에 잘 진입하는지 확인해 보자. 참고로 윈도우에서 확장자가 .cmd인 파일은 확장자까지 입력하지 않아도 된다.

C:\Users\pahkey> myproject
(myproject) C:\projects\myproject>

마지막 편집일시 : 2022년 8월 9일 5:00 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1-05 파이참 설치하고 사용해 보기
[실습 영상] - https://youtu.be/JNFeerizq2k

보통 파이썬을 개발할 때 많이 사용하는 에디터는 비주얼 스튜디오 코드와 파이참(PyCharm)이다. 이 책에서는 파이참으로 플라스크 개발을 진행한다.
중요: 비주얼 스튜디오 코드에 익숙하지 않다면 반드시 파이참을 사용하도록 하자. 비주얼 스튜디오 코드 사용시 FLASK_APP과 같은 환경변수를 제대로 설정하지 못하여 오류가 발생하는 케이스가 많이 발생한다.

파이참 설치하기
파이참 설치 파일 내려받고 설치하기
파이참 실행하기
파이참 인터프리터 설정하기
현재 파이썬 인터프리터 위치 확인하기
파이썬 인터프리터 위치를 가상 환경 위치로 수정하기
파이참 설치하기
파이참 설치 파일 내려받고 설치하기
파이참은 다음 주소에 접속하면 내려받을 수 있다.

윈도우용 파이참 설치파일 주소: https://www.jetbrains.com/ko-kr/pycharm/download/#section=windows

<Professional>과 <Community> 중 무료 버전인 <Community>를 선택하자. 파이참 설치 파일을 내려받은 후 설치를 진행하자. 설치할 때 특별히 주의할 점은 없으므로 끝까지 <Next>를 선택하여 설치하면 된다.

파이참 실행하기
윈도우 시작 버튼을 누르고 프로그램 목록에서 [JetBrains → PyCharm Community Edition]을 선택하면 파이참이 실행된다. 파이참을 처음 실행하는 독자라면 다음과 같은 설정 창이 나타날 것이다. 테마, 플러그인 등의 옵션은 기본값으로 선택하고 넘어가자.
필자는 책에 담을 화면을 갈무리하고자 다음과 같이 바탕이 흰색인 Light테마를 설정했다.
이어서 다음과 같은 창이 나오면 2번째 메뉴인 <Open>을 선택하여 앞에서 우리가 생성한 플라스크 프로젝트인 C:/projects/myproject를 선택하자.

여기까지 문제없이 진행했다면 다음과 같이 파이참이 정상적으로 실행될 것이다.
처음 프로젝트를 만들면 myproject 디렉터리 안에 main.py 파일이 자동으로 생성될 수 있다. 파일이 있다면 삭제 후 실습을 진행하자.

파이참 인터프리터 설정하기
파이참으로 플라스크 프로젝트를 불러온 다음 가장 먼저 해야 할 일은 플라스크 프로젝트가 바라봐야 할 파이썬 인터프리터 위치를 설정하는 것이다.

현재 파이썬 인터프리터 위치 확인하기
파이참 메뉴에서 [File → Settings]를 눌러 설정 창을 열고 [Project:myproject → Project Interpreter]를 순서대로 눌러 파이썬 인터프리터 위치를 설정할 수 있는 창을 열자. 그런 다음 오른쪽 위에 보이는 Python Interpreter를 보자. 
아마도 파이썬을 설치한 디렉터리로 설정되어 있을 것이다.

파이썬 인터프리터 위치를 가상 환경 위치로 수정하기
하지만 지금은 가상 환경을 사용하므로 파이썬 인터프리터 위치를 가상 환경 위치로 수정해 주어야 한다. 다음처럼 Python Interpreter 오른쪽에 보이는 톱니바퀴 모양 아이콘을 누른 다음 <Add>를 누르자.
톱니바퀴 모양 아이콘이 가려져 있으므로 그림 참고 시 주의

다음처럼 파이썬 인터프리터 위치를 설정할 수 있는 Add Python Interpreter 창이 나타난다. 여기서 <Existing environment>를 누른 다음 Interpreter 오른쪽에 보이는 <…>을 누르고 C:\venvs\myproject\Scripts\python.exe를 선택한 후 를 누른다.

나머지 창도 <OK>를 눌러 설정을 마치면 파이참이 myproject 가상 환경에 있는 파이썬 인터프리터를 인식하기 시작한다.

마지막 편집일시 : 2022년 8월 9일 5:00 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1-06 안녕하세요, 파이보!
[완성 소스] : github.com/pahkey/jump2flask/tree/1-06
[실습 영상] : https://youtu.be/MqFBZbUxjbc

드디어 파이보 프로젝트를 진행할 준비가 되었다. 이번에는 웹 브라우저에 ‘Hello, Pybo!’를 출력해 주는 첫 번째 플라스크 애플리케이션을 만들어 보자.

애플리케이션 파일 만들기
플라스크 서버 실행하기
플라스크 애플리케이션 설정하기
개발 서버를 디버깅 가능하도록 실행하기

myproject.cmd
애플리케이션 파일 만들기
파이참에서 myproject 디렉터리에 pybo.py 파일을 생성하고 다음과 같이 코드를 작성하자. 지금은 코드의 의미를 잘 몰라도 괜찮다. 일단 그대로 따라 해 보자.

[파일명: projects\myproject\pybo.py]

from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_pybo():
    return 'Hello, Pybo!'

app = Flask(__name__)은 플라스크 애플리케이션을 생성하는 코드다. 이 코드에서 __name__이라는 변수에는 모듈명이 담긴다. 즉, 이 파일이 실행되면 pybo.py라는 모듈이 실행되는 것이므로 __name__ 변수에는 "pybo" 라는 문자열이 담긴다. @app.route는 URL과 플라스크 코드를 매핑하는 플라스크의 데코레이터다. 즉, / URL이 요청되면 플라스크는 hello_pybo 함수를 실행시킨다.

데코레이터(decorator)란 기존 함수를 변경하지 않고 추가 기능을 덧붙일 수 있도록 해주는 함수를 의미한다.

점프 투 플라스크
[중요] 파일명과 소스코드
앞으로 소스코드는 항상 다음과 같은 규칙으로 표시된다.

파일명은 projects 디렉터리부터 시작하는 경로로 표시한다.
파일의 내용은 파일명 바로 아래에 표시한다.
[파일명: projects\myproject\pybo.py]

(... 생략 ...)

@app.route('/')
def hello_pybo():
    return 'Hello, Pybo!'  # Hello Pybo! 를 출력
소스코드에서 생략된 부분은 위와 같이 (... 생략 ...) 으로 표시한다. 그리고 소스코드에서 신규로 추가되거나 변경된 부분은 노란색 배경으로 표시한다.

플라스크 서버 실행하기
이제 가상 환경에서 flask run 명령을 실행해 플라스크 로컬 서버를 실행하자.

(myproject) c:\projects\myproject>flask run
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
Usage: flask run [OPTIONS]

Error: Could not locate a Flask application. You did not provide the "FLASK_APP" environment variable, and a "wsgi.py" or "app.py" module was not found in the current directory.
그런데 로컬 서버를 실행하면 "플라스크 애플리케이션을 찾을 수 없다"는 오류가 발생한다. 오류 메시지를 조금 더 자세히 보면 "FLASK_APP 환경 변수가 없다"라고 표시되어 있다. 
즉, 플라스크 서버를 실행하려면 반드시 FLASK_APP 환경 변수에 플라스크 애플리케이션을 설정해야 한다.

점프 투 플라스크
FLASK_APP 환경 변수의 기본값
플라스크는 FLASK_APP 환경 변수가 지정되지 않은 경우 자동으로 app.py 파일을 기본 애플리케이션으로 인식한다. 따라서 앞의 pybo.py 파일을 app.py로 만들었다면 FLASK_APP 환경 변수를 별도로 지정하지 않아도 된다. 
하지만 우리는 FLASK_APP 환경 변수의 값을 수정하여 이 문제를 해결할 것이다.

플라스크 애플리케이션 설정하기
myproject 디렉터리에서 set FLASK_APP=pybo 명령을 실행하여 환경 변수 FLASK_APP에 pybo라는 값을 설정하자. 환경 변수에 설정한 pybo는 앞에서 작성한 pybo.py 파일을 의미한다.

(myproject) c:\projects\myproject>set FLASK_APP=pybo
그리고 플라스크 서버를 다시 실행하자.

(myproject) c:\projects\myproject>flask run
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Serving Flask app 'pybo'
 * Debug mode: off
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
이번에는 오류 없이 잘 수행된다. 그런데 여전히 뭔가 미심쩍은 경고 메시지가 보인다. 이 경고 메시지가 나타난 이유는 플라스크 서버가 개발 모드로 실행되었기 때문이다.

운영 환경에서는 flask run으로 실행하는 개발서버가 아닌 WSGI 서버로 실행해야 한다. WSGI 서버로 플라스크를 구동하는 방법은 뒤에서 자세하게 다룬다.

개발 서버를 디버깅 가능하도록 실행하기

우선 <Ctrl+C> 를 눌러 구동 중인 플라스크 서버를 중지하자. 그리고 set FLASK_DEBUG=true 명령을 실행해 디버깅이 가능하도록 설정하자.

(myproject) c:\projects\myproject>set FLASK_DEBUG=true
그리고 다시 플라스크 개발 서버를 실행하자.

(myproject) c:\projects\myproject>flask run
 WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Serving Flask app 'pybo'
 * Debug mode: on
 * Running on http://127.0.0.1:5000 (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 286-954-098

그러면 디버깅 모드가 활성화되어 플라스크 개발 서버가 실행된다. 서버를 실행하고 마지막 문구를 보면 플라스크 서버가 127.0.0.1:5000로 실행되었음을 알 수 있다. 웹 브라우저를 열고 해당 주소에 접속해 보자.
127.0.0.1:5000 대신 localhost:5000라고 입력해도 같은 화면을 볼 수 있다. 127.0.0.1과 localhost는 현재 컴퓨터를 가리키는 아이피 주소다.

myproject/pybo.py 파일에 작성한 hello_pybo 함수가 실행되어 "Hello, Pybo!"가 출력된다.

축하한다! 여러분의 첫 번째 플라스크 웹 프로그램이 완성되었다.

점프 투 플라스크
디버그 모드 활성화
디버그 모드는 오류가 발생하면 디버깅 결과 메시지를 웹 브라우저에 출력해 준다. 또한 서버 실행중에 프로그램을 변경하면 서버가 자동으로 다시 시작하여 변경된 내용을 적용해 준다.

myproject.cmd

지금까지 설정한 대로라면 앞으로 플라스크 서버를 실행할때 다음처럼 환경변수를 설정하는 명령어를 매번 입력해야 한다.

(myproject) c:\projects\myproject> set FLASK_APP=pybo
(myproject) c:\projects\myproject> set FLASK_DEBUG=true
(myproject) c:\projects\myproject> flask run
하지만 myproject.cmd 파일에 이 명령어를 미리 추가해 놓으면 매번 환경 변수를 입력할 필요가 없을 것이다.

myproject.cmd 파일을 다음과 같이 수정하자.

[파일명: C:/venvs/myproject.cmd]

@echo off
cd c:/projects/myproject
set FLASK_APP=pybo
set FLASK_DEBUG=true
c:/venvs/myproject/scripts/activate
이제 myproject.cmd 파일로 가상 환경에 진입할 때 FLASK_APP과 FLASK_DEBUG 환경 변수가 자동으로 설정되므로 편리하게 실습할 수 있다.

마지막 편집일시 : 2022년 8월 9일 4:59 오후

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2장 플라스크 개발 기초 공사! 
2-01 플라스크 기초 다지기

현재 파이보 프로젝트는 projects/myproject 디렉터리 아래에 pybo.py 파일만 생성한 상태다. 그런데 이보다 규모를 갖춘 플라스크 프로젝트를 만들고자 한다면 프로젝트 구조를 잘 만들어야 한다. 
그런데 플라스크는 "프로젝트의 구조를 어떻게 하라"와 같은 규칙이 없다. 그래서 프로젝트를 구성할 때 고민을 좀 해야 한다.

플라스크 프로젝트 구조
데이터베이스를 처리하는 models.py 파일
서버로 전송된 폼을 처리하는 forms.py 파일
화면을 구성하는 views 디렉터리
CSS, 자바스크립트, 이미지 파일을 저장하는 static 디렉터리
HTML 파일을 저장하는 templates 디렉터리
파이보 프로젝트를 설정하는 config.py 파일
플라스크 프로젝트 구조
앞으로 만들 파이보 프로젝트의 전체 구조는 다음과 같다. 지금은 구상하는 단계이므로 눈으로만 살펴보고 넘어가자.

├── pybo/
│      ├─ __init__.py
│      ├─ models.py
│      ├─ forms.py
│      ├─ views/
│      │   └─ main_views.py
│      ├─ static/
│      │   └─ style.css
│      └─ templates/
│            └─ index.html
└── config.py

1장에서 작성한 pybo.py 파일은 pybo 패키지로 변경할 수 있다. 이 구조에서 보듯 pybo 디렉터리 안에 있는 __init__.py 파일이 pybo.py 파일의 역할을 대신할 것이다.
pybo.py 파일을 pybo/__init__.py 파일로 대신하는 부분은 다음 장에서 자세히 다루도록 한다.
pybo 패키지 안에 구성해야 하는 파일과 디렉터리에 대해서 간단히 알아보자.

데이터베이스를 처리하는 models.py 파일
파이보 프로젝트는 ORM(object relational mapping)을 지원하는 파이썬 데이터베이스 도구인 SQLAlchemy를 사용한다. SQLAlchemy는 모델 기반으로 데이터베이스를 처리한다. 
지금은 모델 기반으로 데이터베이스를 처리한다는 말이 이해되지 않겠지만, 이후 프로젝트를 진행하면 잘 알 수 있을 것이다. 아무튼 지금 여러분이 알아야 할 내용은 파이보 프로젝트에는 "모델 클래스들을 정의할 models.py 파일이 필요하다"는 것이다.

서버로 전송된 폼을 처리하는 forms.py 파일
파이보 프로젝트는 웹 브라우저에서 서버로 전송된 폼을 처리할 때 WTForms라는 라이브러리를 사용한다. WTForms 역시 모델 기반으로 폼을 처리한다. 그래서 폼 클래스를 정의할 forms.py 파일이 필요하다.

화면을 구성하는 views 디렉터리

pybo.py 파일에 작성했던 hello_pybo 함수의 역할은 화면 구성이었다. views 디렉터리에는 바로 이런 함수들로 구성된 뷰 파일들을 저장한다. 파이보 프로젝트에는 기능에 따라 main_views.py, question_views.py, answer_views.py 등의 뷰 파일을 만들 것이다.

CSS, 자바스크립트, 이미지 파일을 저장하는 static 디렉터리
static 디렉터리는 파이보 프로젝트의 스타일시트(.css), 자바스크립트(.js) 그리고 이미지 파일(.jpg, .png) 등을 저장한다.

HTML 파일을 저장하는 templates 디렉터리
templates 디렉터리에는 파이보의 질문 목록, 질문 상세 등의 HTML 파일을 저장한다. 파이보 프로젝트는 question_list.html, question_detail.html과 같은 템플릿 파일을 만들어 사용할 것이다.

파이보 프로젝트를 설정하는 config.py 파일
config.py 파일은 파이보 프로젝트의 환경을 설정한다. 파이보 프로젝트의 환경변수, 데이터베이스 등의 설정을 이 파일에 저장한다.

마지막 편집일시 : 2022년 4월 13일 3:38 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-02 플라스크 애플리케이션 팩토리
[완성 소스] : github.com/pahkey/jump2flask/tree/2-02
[실습 영상] : https://youtu.be/fQuqpduKtSw

1장에서 플라스크 앱을 간단히 알아보았다. 실제로 플라스크 앱은 다음 코드에서 보듯 Flask 클래스로 만든 객체를 말한다.
app = Flask(__name__)

플라스크는 app 객체를 사용해 여러 가지 설정을 진행한다. 그런데 이와 같은 방식으로 app 객체를 전역으로 사용하면 프로젝트 규모가 커질수록 문제가 발생할 확률이 높아진다. 순환 참조(circular import) 오류가 대표적이다.
순환 참조란 A 모듈이 B 모듈을 참조하고 B 모듈이 다시 A 모듈을 참조하는 경우를 말한다.
app 객체를 전역으로 사용할 때 발생하는 문제를 예방하려면 어떻게 해야 할까? 플라스크 공식 홈페이지에서는 "애플리케이션 팩토리(application factory)를 사용하라"고 권한다.
이번 장에서는 애플리케이션 팩토리에 대해서 알아보자.

pybo.py를 __init__.py 파일로 변경하기
애플리케이션 팩토리
pybo.py를 __init__.py 파일로 변경하기
앞에서 만든 myproject/pybo.py 파일을 myproject/pybo/__init__.py 파일로 바꾸어 보자. 먼저 명령 프롬프트에서 다음 명령으로 myproject/pybo 디렉터리를 만든다.

(myproject) c:\projects\myproject> mkdir pybo
그리고 move 명령어로 pybo.py 파일을 pybo/__init__.py 파일로 이동하자.

(myproject) c:\projects\myproject> move pybo.py pybo/__init__.py
         1개 파일을 이동했습니다.

그리고 플라스크 서버를 실행해 보자.

(myproject) c:\projects\myproject>flask run
 * Serving Flask app "pybo" (lazy loading)
 * Environment: development
 * Debug mode: on
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 202-513-618
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
[중요]!! flask run 명령은 반드시 프로젝트 홈 디렉터리(C:/projects/myproject)에서 실행해야한다. 다른 곳에서 실행하면 실행은 되지만 정상으로 동작하지 않는다. 앞으로도 flask run으로 플라스크 서버를 실행할 때는 위치를 꼭 확인하자.

파일명을 바꾸어도 플라스크 서버가 잘 실행된다. 우리는 플라스크 기본 앱을 FLASK_APP=pybo로 설정했다. 따라서 이전에 pybo는 프로젝트 루트에 있는 pybo.py 파일을 가리켰지만, 이번에는 pybo 모듈 즉 pybo/__init__.py 파일을 가리킨다.
pybo.py 와 pybo/__init__.py는 동일한 pybo 모듈이다.
따라서 pybo.py 파일을 pybo/__init__.py 파일로 바꾸어도 오류없이 잘 동작한다.

애플리케이션 팩토리
__init__.py 파일을 열고 create_app 함수를 선언하는 방식으로 코드를 수정하자.

[파일명: projects\myproject\pybo\__init__.py]
from flask import Flask

def create_app():
    app = Flask(__name__)

    @app.route('/')
    def hello_pybo():
        return 'Hello, Pybo!'

    return app

create_app 함수가 app 객체를 생성해 반환하도록 코드를 수정했다. 이때 app 객체가 함수 안에서 사용되므로 hello_pybo 함수를 create_app 함수 안에 포함했다. 바로 여기서 사용된 create_app 함수가 바로 애플리케이션 팩토리다.
함수명으로 create_app 대신 다른 이름을 사용하면 정상으로 동작하지 않는다. create_app은 플라스크 내부에서 정의된 함수명이다.
코드를 수정한 후 플라스크 서버를 다시 시작하면 오류 없이 잘 실행된다.

마지막 편집일시 : 2022년 8월 9일 4:59 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2-03 블루프린트로 라우팅 함수 관리하기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-03
[실습 영상] : https://youtu.be/TgKNZMRS5jc

앞에서 진행한 pybo/__init__.py 파일 내용을 보면 create_app 함수안에 hello_pybo 함수가 포함되어 있다. hello_pybo 함수는 / URL과 매핑되는 함수인데, 이러한 URL 매핑을 @app.route('/')라는 애너테이션이 만들어 준다. 
이때 @app.route와 같은 애너테이션으로 URL을 매핑하는 함수를 라우팅 함수라고 한다.
그런데 하나 생각해 볼 점이 있다. 지금까지 작성한 대로라면 새로운 URL 매핑이 필요할 때마다 라우팅 함수를 create_app 함수 안에 계속 추가해야 한다. 이렇게 라우팅 함수가 계속 추가된다면 create_app 함수는 엄청나게 크고 복잡한 함수가 될 것이다.
큰일이다!
하지만 걱정하지 말자. 블루프린트(Blueprint)를 사용하면 이 문제를 해결할 수 있다.
플라스크의 블루프린트를 이용하면 라우팅 함수를 체계적으로 관리할 수 있다. 블루프린트(blueprint)는 보통 객체지향 프로그래밍에서 "청사진"을 뜻하는 용어인데 플라스크에서는 URL과 함수의 매핑을 관리하기 위해 사용하는 도구(클래스)이다.

블루프린트에 대해서 자세히 알아보자.

블루프린트 생성
블루프린트 등록
블루프린트에 라우팅 함수 추가
블루프린트 동작 확인

블루프린트 생성
create_app 함수 안에 포함된 hello_pybo 함수 대신 블루프린트를 사용할 수 있도록 수정해 보자.

먼저 pybo 디렉터리 아래에 views 디렉터리를 만들자.

(myproject) c:\projects\myproject> cd pybo
(myproject) c:\projects\myproject\pybo> mkdir views
그리고 views 디렉터리에 main_views.py 파일을 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/views/main_views.py]
from flask import Blueprint

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/')
def hello_pybo():
    return 'Hello, Pybo!'

이 코드는 pybo/__init__.py 파일의 create_app 함수 안에 있던 hello_pybo 함수를 main_views.py 파일에 그대로 옮긴 것이다. 
단, 애너테이션이 @app.route에서 @bp.route로 변경되었다. 이 변화에 주목하자. @bp.route에서 bp 객체는 다음처럼 생성되었다.

bp = Blueprint('main', __name__, url_prefix='/')
bp 객체 생성시 사용된 __name__은 모듈명인 "main_views"가 인수로 전달된다. 첫번째 인수로 전달한 "main"은 블루프린트의 "별칭"이다. 이 별칭은 나중에 자주 사용할 url_for 함수에서 사용된다. 
그리고 url_prefix는 라우팅 함수의 애너테이션 URL 앞에 기본으로 붙일 접두어 URL을 의미한다. 
예를 들어 main_views.py 파일의 URL 프리픽스에 url_prefix='/' 대신 url_prefix='/main'이라고 입력했다면 hello_pybo 함수를 호출하는 URL은 localhost:5000/이 아니라 localhost:5000/main/이 된다.

URL 프리픽스는 나중에 좀 더 자세히 알아보자.

블루프린트 등록
이제 플라스크 앱에 작성한 블루프린트를 등록해 보자. pybo/__init__.py 파일을 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/__init__.py]
from flask import Flask

def create_app():
    app = Flask(__name__)

    from .views import main_views
    app.register_blueprint(main_views.bp)

    return app

main_views.py 파일에 생성한 블루프린트 객체 bp를 app.register_blueprint(main_views.bp)로 등록했다. 그리고 create_app 함수에 있던 hello_pybo 함수는 더이상 필요하지 않으므로 제거하자.
그리고 http://localhost:5000 페이지를 호출해 보자.

블루프린트에 등록한 hello_pybo 함수가 잘 동작하는 것을 확인할 수 있다.

블루프린트에 라우팅 함수 추가
블루프린트가 잘 동작하는지 확인하기 위해 라우팅 함수를 조금 바꾸어보자. main_views.py 파일을 열어 hello_pybo 함수의 URL 매핑을 /에서 /hello로 바꾸고, index 함수를 추가해 / URL로 매핑해 보자.

[파일명: projects/myproject/pybo/views/main_views.py]

from flask import Blueprint

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/hello')
def hello_pybo():    return 'Hello, Pybo!'

@bp.route('/')
def index():
    return 'Pybo index'

블루프린트 동작 확인
로컬 서버를 실행한 후 웹 브라우저를 열고 localhost:5000과 localhost:5000/hello에 접속해 보자.

localhost:5000에 접속하면 / URL에 매핑된 index 함수가 호출되어 "Pybo index"가 출력되고, localhost:5000/hello에 접속하면 /hello URL에 매핑된 hello_pybo 함수가 호출되어 "Hello, Pybo!"가 출력된다. 
이제 라우팅 함수가 추가되더라도 main_views.py 파일에 함수를 추가하면 되기 때문에 create_app 함수가 뚱뚱해질 일을 걱정할 필요는 없다.

마지막 편집일시 : 2022년 8월 9일 4:58 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2-04 모델로 데이터 처리하기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-04
[실습 영상] : https://youtu.be/tDm8u69P5pg

웹 서비스는 데이터를 처리할 때 대부분 데이터베이스를 사용한다.
SQL 쿼리(query)라는 구조화된 질의를 작성하고 실행하는 등의 복잡한 과정이 필요 
이때 ORM(object relational mapping)을 이용하면 파이썬 문법만으로도 데이터베이스를 다룰 수 있음
즉, ORM을 이용하면 개발자가 쿼리를 직접 작성하지 않아도 데이터베이스의 데이터를 처리할 수 있음
ORM은 데이터베이스에 데이터를 저장하는 테이블을 파이썬 클래스로 만들어 관리하는 기술로 이해해도 좋다.

[question 테이블 구성 예]

id	subject	content
1	안녕하세요	가입 인사드립니다 ^^
2	질문 있습니다	ORM이 궁금합니다
...	...	...
표에서 id는 각 데이터를 구분하는 고윳값이다.
이렇게 구성된 question 테이블에 새로운 데이터를 삽입하는 쿼리는 보통 다음처럼 작성한다.

[쿼리를 이용한 새 데이터 삽입 예]
insert into question (subject, content) values ('안녕하세요', '가입 인사드립니다 ^^');
insert into question (subject, content) values ('질문 있습니다', 'ORM이 궁금합니다');
하지만 ORM을 사용하면 쿼리 대신 파이썬 코드로 다음처럼 작성할 수 있다.

[ORM을 이용한 새 데이터 삽입 예]
question1 = Question(subject=’안녕하세요’, content='가입 인사드립니다 ^^')
db.session.add(question1)
question2 = Question(subject=’질문 있습니다’, content='ORM이 궁금합니다')
db.session.add(question2)

Question : 파이썬 클래스, 데이터를 관리하는 데 사용하는 ORM 클래스 : 모델

ORM을 이용하면 데이터베이스 종류에 상관 없이 일관된 코드를 유지할 수 있어서 프로그램을 유지·보수하기가 편리하다. 
또한 내부에서 안전한 SQL 쿼리를 자동으로 생성해 주므로 개발자가 달라도 통일된 쿼리를 작성할 수 있고 오류 발생률도 줄일 수 있다.

플라스크 ORM 라이브러리 사용하기
파이썬 ORM 라이브러리 중 가장 많이 사용하는 SQLAlchemy 사용
파이썬 모델을 이용해 테이블을 생성하고 컬럼을 추가하는 등의 작업을 할 수 있게 해주는 Flask-Migrate 라이브러리 사용


ORM 라이브러리 설치하기
Flask-Migrate 라이브러리를 설치하면 SQLAlchemy도 함께 설치되므로 myproject 가상 환경에서 다음 명령을 수행하여 Flask-Migrate 라이브러리를 설치하자.

(myproject) c:\projects\myproject>pip install flask-migrate
Collecting Flask-Migrate
(... 생략 ...)

설정 파일 추가
파이보에 ORM을 적용 - 데이터베이스 설정이 필요

[파일명: projects/myproject/config.py]
import os

BASE_DIR = os.path.dirname(__file__)

SQLALCHEMY_DATABASE_URI = 'sqlite:///{}'.format(os.path.join(BASE_DIR, 'pybo.db'))
SQLALCHEMY_TRACK_MODIFICATIONS = False

[파일명: projects/myproject/pybo/__init__.py]
from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy

import config

db = SQLAlchemy()
migrate = Migrate()

def create_app():
    app = Flask(__name__)
    app.config.from_object(config)

    # ORM
    db.init_app(app)
    migrate.init_app(app, db)

    # 블루프린트
    from .views import main_views
    app.register_blueprint(main_views.bp)

    return app



데이터베이스 초기화하기

이제 ORM을 사용할 준비가 되었으므로 flask db init 명령으로 데이터베이스를 초기화하자.

(myproject) c:\projects\myproject>flask db init
Creating directory c:\projects\myproject\migrations ...  done
Creating directory c:\projects\myproject\migrations\versions ...  done
Generating c:\projects\myproject\migrations\alembic.ini ...  done
Generating c:\projects\myproject\migrations\env.py ...  done
Generating c:\projects\myproject\migrations\README ...  done
Generating c:\projects\myproject\migrations\script.py.mako ...  done
Please edit configuration/connection/logging settings in 'c:\\projects\\myproject\\migrations\\alembic.ini' before proceeding.
flask db init 명령은 데이터베이스를 관리하는 초기 파일들을 다음처럼 migrations 디렉터리에 자동으로 생성한다.



이때 생성되는 파일들은 Flask-Migrate 라이브러리가 내부적으로 사용하는 파일들이기 때문에 이 파일들에 대해서 알 필요는 없다.

데이터베이스를 초기화하는 flask db init 명령은 최초 한 번만 수행하면 된다.

데이터베이스 관리 명령어 정리하기
앞으로 모델을 추가하거나 변경할 때는 flask db migrate 명령과 flask db upgrade 명령만 사용할 것이다. 즉, 앞으로 데이터베이스 관리를 위해 여러분이 반드시 알아야 할 명령어는 다음 2가지이다.

[표 2-2 데이터베이스 관리 명령어]

명령어	설명
flask db migrate	모델을 새로 생성하거나 변경할 때 사용 (실행하면 작업파일이 생성된다.)
flask db upgrade	모델의 변경 내용을 실제 데이터베이스에 적용할 때 사용 (위에서 생성된 작업파일을 실행하여 데이터베이스를 변경한다.)
이 밖에도 여러 명령이 있지만 특별한 경우가 아니라면 이 2가지 명령어를 주로 사용할 것이다. 명령어 종류를 확인하고 싶다면 명령 프롬프트에서 flask db 명령을 입력해 보자.

모델 만들기

이제 파이보에서 사용할 모델을 만들어 보자. 파이보는 질문 답변 게시판이므로 질문과 답변에 해당하는 모델이 있어야 한다.

모델은 데이터를 다룰 목적으로 만든 파이썬 클래스다.

모델 속성 구상하기
질문과 답변 모델에는 어떤 속성이 있어야 할까?

잠시 생각해 보자.

질문 모델에는 다음 속성이 필요할 것이다.

[질문 모델 속성]

속성명	설명
id	질문 데이터의 고유 번호
subject	질문 제목
content	질문 내용
create_date	질문 작성일시
그리고 답변 모델은 다음과 같은 속성이 필요하다.

[답변 모델 속성]

속성명	설명
id	답변 데이터의 고유 번호
question_id	질문 데이터의 고유 번호(어떤 질문에 달린 답변인지 알아야 하므로 질문 데이터의 고유 번호가 필요하다)
content	답변 내용
create_date	답변 작성일시
질문 모델 생성하기

이렇게 구상한 속성을 바탕으로 모델을 정의해 보자. 먼저 pybo 디렉터리에 모델을 정의하기 위한 models.py 파일을 생성하고 질문 모델인 Question 클래스를 다음과 같이 작성해 보자.

models.py 파일에는 모델 클래스들을 정의하여 사용할 것이다.

[파일명: projects/myproject/pybo/models.py]

from pybo import db

class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
Question과 같은 모델 클래스는 db.Model 클래스를 상속하여 만들어야 한다. 이 때 사용한 db 객체는 __init__.py 파일에서 생성한 SQLAlchemy 클래스의 객체이다. Question 모델은 고유 번호(id), 제목(subject), 내용(content), 작성일시(create_date) 속성으로 구성했으며, 각 속성은 db.Column으로 생성했다. db.Column에 어떤 값들을 전달했는지 살펴보면서 각 속성의 특징을 확인해 보자.

db.Column() 괄호 안의 첫 번째 인수는 데이터 타입을 의미한다. 데이터 타입은 속성에 저장할 데이터의 종류를 결정한다. db.Integer는 고유 번호와 같은 숫자값에 사용하고, db.String은 제목처럼 글자 수가 제한된 텍스트에 사용한다. 글 내용처럼 글자 수를 제한할 수 없는 텍스트는 db.Text를 사용한다. 작성일시는 날짜와 시각에 해당하는 db.DateTime을 사용했다.

db.Column에는 데이터 타입 외에 다음과 같은 속성을 추가로 설정할수 있다.

primary_key

id 속성에 설정한 primary_key는 id 속성을 기본 키(Primary Key)로 만든다. 기본 키는 데이터베이스에서 중복된 값을 가질 수 없게 만드는 설정이다. id는 모델에서 각 데이터를 구분하는 유일한 값으로 중복되면 안 되므로 기본키로 지정했다.

데이터베이스에서는 id와 같은 특징을 가진 속성을 기본 키(Primary Key)라고 한다. 플라스크는 데이터 타입이 db.Integer이고 기본키로 설정한 속성은 값이 자동으로 증가하는 특징도 있어서 데이터를 저장할 때 값을 세팅하지 않아도 1씩 자동으로 증가되어 저장된다.

nullable


nullable은 속성에 값을 저장할 때 빈값을 허용할지의 여부이다. nullable을 따로 설정하지 않으면 해당 속성은 기본으로 빈값을 허용한다. 따라서 속성에 빈값을 허용하지 않으려면 nullable=False로 설정해야 한다.

답변 모델 생성하기
이어서 답변 모델에 해당하는 Answer 클래스도 만들어 보자.

[파일명: projects/myproject/pybo/models.py]

from pybo import db

class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)

class Answer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
    question = db.relationship('Question', backref=db.backref('answer_set'))
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
답변 모델에서 id와 content, create_date 속성은 질문 모델의 id, content, create_date와 의미와 목적이 같다. 다른 속성은 question_id와 question인데 두 속성이 왜 필요하고 어떤 의미를 갖는지 알아보자.

question_id

question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
question_id 속성은 답변을 질문과 연결하기 위해 추가한 속성이다. 답변은 어떤 질문에 대한 답변인지 알아야 하므로 질문의 id 속성이 필요하다. 그리고 모델을 서로 연결할 때에는 위와 같이 db.ForeignKey를 사용해야 한다.

데이터베이스에서는 기존 모델과 연결된 속성을 외부 키(foreign key)라고 한다.

db.ForeignKey의 첫 번째 파라미터 'question.id'는 question 테이블의 id 컬럼을 의미한다. (question 객체의 속성 id로 착각하지 말자.) 즉, Answer 모델의 question_id 속성은 question 테이블의 id 컬럼과 연결된다는 뜻이다.

Question 모델을 통해 테이블이 생성되면 테이블명은 question이 된다.

db.ForeignKey의 두 번째 파라미터 ondelete는 삭제 연동 설정이다. 즉, ondelete='CASCADE'는 질문을 삭제하면 해당 질문에 달린 답변도 함께 삭제된다는 의미이다.


CASCADE 옵션은 데이터베이스 설정이다. 따라서 질문을 데이터베이스 툴에서 쿼리로 삭제할 때만 질문에 달린 답변들이 삭제된다.

question

question = db.relationship('Question', backref=db.backref('answer_set'))
그 다음 question 속성은 답변 모델에서 질문 모델을 참조하기 위해 추가했다. 위와 같이 db.relationship으로 question 속성을 생성하면 답변 모델에서 연결된 질문 모델의 제목을 answer.question.subject처럼 참조할 수 있다.

db.relationship의 첫 번째 파라미터는 참조할 모델명이고 두 번째 backref 파라미터는 역참조 설정이다. 역참조란 쉽게 말해 질문에서 답변을 거꾸로 참조하는 것을 의미한다. 한 질문에는 여러 개의 답변이 달릴 수 있는데 역참조는 이 질문에 달린 답변들을 참조할 수 있게 한다. 예를 들어 어떤 질문에 해당하는 객체가 a_question이라면 a_question.answer_set와 같은 코드로 해당 질문에 달린 답변들을 참조할 수 있다.

SQLAlchemy에서 제공하는 속성은 위에서 소개한 것 외에도 많이 있다. 자세한 내용은 다음의 URL을 참고하자.

https://docs.sqlalchemy.org/en/13/core/type_basics.html
지금까지 설명한 것들을 머리로만 이해하려고 하면 어려울 것이다. 곧이어 실습을 진행할 것이니 대략적인 개념만 숙지하고 넘어가도록 하자.

점프 투 플라스크
파이썬 코드를 이용하여 질문 데이터 삭제 시 연관된 답변 데이터를 모두 삭제하는 방법
위에서 "쿼리를 이용하여 질문 데이터를 삭제할 경우 답변도 함께 삭제된다"고 했는데 이는 정확히 말하면 데이터베이스 도구에서 쿼리를 이용하여 삭제하는 경우에 해당한다. 만약 a_question.delete() 처럼 파이썬 코드로 질문 데이터를 삭제하면 해당 질문과 연결된 답변 데이터는 삭제되지 않고 답변 데이터의 question_id 컬럼만 빈값으로 업데이트된다. 만약 파이썬 코드로 질문 데이터를 삭제할 때 연결된 답변 모두를 삭제하기 바란다면 다음처럼 db.backref 설정에 cascade='all, delete-orphan'를 추가해야 한다.

question = db.relationship('Question', backref=db.backref('answer_set', cascade='all, delete-orphan'))
모델을 이용해 테이블 자동으로 생성하기

모델을 구상하고 생성했으므로 플라스크의 migrate 기능을 이용해 데이터베이스 테이블을 생성해 보자.

모델 import
앞에서 작성한 모델을 플라스크의 migrate 기능이 인식하려면 다음과 같은 import 과정이 필요하다.

[파일명: projects/myproject/pybo/__init__.py]

(... 생략 ...)

    # ORM
    db.init_app(app)
    migrate.init_app(app, db)
    from . import models

(... 생략 ...)
리비전 파일 생성하기
그리고 명령 프롬프트에서 flask db migrate 명령을 수행하자.

(myproject) c:\projects\myproject> flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected added table ‘question’
INFO [alembic.autogenerate.compare] Detected added table ‘answer’
Generating c:\projects\myproject\migrations\versions\18634a293520_.py ... done
이 명령을 수행하면 18634a293520_.py처럼 데이터베이스 변경 작업을 위한 리비전 파일이 생성된다. 리비전(revision)이란 생성된 18634a293520_.py 파일에서 .py 확장자를 제외한 18634a293520_와 같은 버전 번호를 가리킨다. 리비전은 flask db migrate 명령을 수행할 때 무작위로 만들어진다.



리비전 파일 실행하기
이어서 flask db upgrade 명령으로 만들어진 리비전 파일을 실행하자. (리비전 파일 내에는 테이블 생성을 위한 쿼리문들이 저장되어 있다.)


(myproject) c:\projects\myproject> flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade -> 18634a293520, empty message
이 과정에서 데이터베이스에 모델 이름과 똑같은 question과 answer라는 이름의 테이블이 생성된다. 지금까지 잘 따라왔다면 projects/myproject 디렉터리에 pybo.db 파일이 생성되었을 것이다. pybo.db가 바로 SQLite 데이터베이스의 데이터 파일이다.



생성된 테이블 살펴보기
pybo.db 데이터 파일에 정말로 question과 answer 테이블이 생성되었는지 확인해 보자. 이를 위해 SQLite의 GUI 도구인 DB Browser for SQLite를 사용해 보자.

DB Browser for SQLite 설치하기
https://sqlitebrowser.org/dl 에 접속한 다음 DB Browser for SQLite(이하 DB 브라우저) 설치 파일(standard installer)을 내려받아 설치를 진행하자.

자신의 운영체제에 맞는 설치 파일을 내려받아야하며, 설치 중 바로 가기(shortcuts)를 생성하는 옵션을 추가해야 쉽게 실행할 수 있다.



DB 브라우저에서 pybo.db 열기
윈도우 바탕화면이나 프로그램 메뉴에서 방금 설치한 DB 브라우저를 실행하고 메뉴에서 [파일 → 데이터베이스 열기]를 선택한다. 그리고 앞선 실습에서 생성한 projects/myproject/pybo.db 데이터베이스 파일을 선택하고 <열기>를 누른다.




테이블 목록을 보면 question, answer 테이블이 생성되었음을 확인할 수 있다.

alembic_version 테이블은 Flask-Migrate 라이브러리가 데이터베이스를 변경·관리하려고 사용하는 테이블이므로 신경 쓰지 않아도 된다.

모델 사용하기
모델도 만들었고 모델을 기반으로 테이블도 생성했으니 이제 모델을 사용할 차례다.

"플라스크 셸"을 사용해 모델 사용법을 간단히 익혀보자.

플라스크 셸 실행하기
플라스크 셸은 명령 프롬프트에서 flask shell 명령으로 실행한다.

(myproject) c:\projects\myproject>flask shell
Python 3.8.5 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32
App: pybo [development]
Instance: C:\projects\myproject\instance
>>> 
플라스크 셸은 플라스크를 실행하는 데 필요한 환경이 자동으로 설정되어 실행되므로 일반 파이썬 셸과는 다르다.

질문 저장하기

다음처럼 Question 모델 객체를 하나 생성하자.

>>> from pybo.models import Question, Answer
>>> from datetime import datetime
>>> q = Question(subject='pybo가 무엇인가요?', content='pybo에 대해서 알고 싶습니다.', create_date=datetime.now())
Question 모델의 create_date 속성은 DateTime 유형이므로 datetime.now 함수로 현재 일시를 대입했다. 하지만 객체 q를 만들었다고 해서 데이터베이스에 질문 데이터가 저장되는 것은 아니다. 데이터베이스에 데이터를 저장하려면 다음처럼 SQLAlchemy의 db 객체를 사용해야 한다.

>>> from pybo import db
>>> db.session.add(q)
>>> db.session.commit()
코드에서 보듯 신규 데이터를 저장할 때는 db.session의 add 함수를 사용한 다음 commit 함수까지 실행해야 한다. db.session은 데이터베이스와 연결된 세션, 즉 접속된 상태를 의미한다. 데이터베이스를 처리하려면 이 세션이 필요하다. 그리고 세션을 통해서 데이터를 저장, 수정, 삭제 작업을 한 다음에는 반드시 db.session.commit()으로 커밋을 해주어야 한다. 커밋을 해야 비로서 데이터베이스에 데이터가 저장된다.

데이터가 잘 생성되었는지 확인해 보자.

>>> q.id
1
id는 Question 모델의 기본 키다. id는 앞에서 모델을 생성할 때 설정했던대로 데이터를 생성할 때 속성값이 자동으로 1씩 증가한다. 정말 그런지 두 번째 질문 데이터를 생성한 후 id를 확인해 보자.

>>> q = Question(subject='플라스크 모델 질문입니다.', content='id는 자동으로 생성되나요?', create_date=datetime.now())
>>> db.session.add(q)
>>> db.session.commit()
>>> q.id
2
결과를 보면 두 번째 질문 데이터의 id는 예상대로 2가 출력됐다.

점프 투 플라스크
커밋(commit)과 롤백(rollback)
커밋은 취소할 수 없다는 점에 유의하자. 커밋은 일종의 "결정사인" 역할을 한다고 생각하면 이해하기 쉽다. 그래서 수행한 작업을 취소하려면 커밋 이전에 진행해야 한다. 이때 작업을 취소하고 싶으면 db.session.rollback()으로 되돌리기(롤백)를 실행하면 된다.

데이터 조회하기
이번에는 데이터베이스에 저장된 데이터를 조회해 보자.


>>> Question.query.all()
[<Question 1>, <Question 2>]
Question.query.all()로 데이터베이스에 저장된 질문을 전부 조회했다. 결과에서 보이는 숫자 1과 2는 Question 객체의 id 속성값이다.

이번에는 filter 함수를 이용해 첫 번째 질문만 조회해 보자.

>>> Question.query.filter(Question.id==1).all()
[<Question 1>]
filter 함수는 인자로 전달한 조건에 맞는 데이터를 찾아서 반환한다. 여기서는 기본 키인 id를 이용했으므로 값을 1개만 반환한다.

id는 유일한 값이므로 filter 함수 대신 get 함수를 이용해 조회할 수도 있다.

>>> Question.query.get(1)
<Question 1>
다만 get 함수의 리턴은 단 1건만 가능하므로 리스트가 아닌 Question 객체가 리턴된다.

이번에는 filter와 like로 제목에 "플라스크"라는 문자열이 포함된 질문을 조회해 보자.

>>> Question.query.filter(Question.subject.like('%플라스크%')).all()
[<Question 2>]
"플라스크"라는 문자열이 포함된 두 번째 질문이 조회되었다. filter 함수에 전달한 Question.subject.like('%플라스크%') 코드의 의미는 Question 모델 subject 속성에 "플라스크"라는 문자열이 포함되는가?"이다. 이때 like 함수에 전달한 문자열에 붙은 % 표기는 다음과 같은 의미를 갖는다.

플라스크%: "플라스크"로 시작하는 문자열
%플라스크: "플라스크"로 끝나는 문자열
%플라스크%: "플라스크"를 포함하는 문자열
대소 문자 구분하지 않고 문자열을 찾으려면 like 함수 대신 ilike 함수를 사용한다.

데이터를 조회하는 다양한 사용법은 SQLAlchemy공식 문서를 참조하자.

SQLAlchemy 공식 문서: https://docs.sqlalchemy.org/en/13/orm/query.html
데이터 수정하기
이번에는 질문 데이터를 수정해 보자. 데이터를 수정할 때는 단순히 대입 연산자를 사용하면 된다.

>>> q = Question.query.get(2)
>>> q
<Question 2>
>>> q.subject = 'Flask Model Question'
>>> db.session.commit()
두 번째 질문을 조회한 다음 subject 속성을 수정했다. 앞에서 설명했듯이 데이터를 변경한 후에는 반드시 커밋을 수행해야 데이터베이스에 반영된다.

데이터 삭제하기
이어서 데이터를 삭제하는 것도 실습해 보자. 여기서는 첫 번째 질문을 삭제하자.

>>> q = Question.query.get(1)
>>> db.session.delete(q)
>>> db.session.commit()
첫 번째 질문을 조회한 다음 delete 함수를 이용해 삭제했다. 삭제도 역시 커밋이 필요하다.

이어서 실제로 데이터베이스에서 첫 번째 질문이 삭제되었는지 확인해 보자.

>>> Question.query.all()
[<Question 2>]
첫 번째 질문이 삭제되어서 두 번째 질문만 남아 있는 것을 확인할수 있다.

답변 데이터 저장하기
이번에는 답변(Answer)을 생성하고 저장해 보자.

>>> from datetime import datetime
>>> from pybo.models import Question, Answer
>>> from pybo import db
>>> q = Question.query.get(2)
>>> a = Answer(question=q, content='네 자동으로 생성됩니다.', create_date=datetime.now())
>>> db.session.add(a)
>>> db.session.commit()
답변을 생성하려면 연결할 질문이 필요하므로 우선 질문을 조회했다. id가 2인 질문을 조회하여 q 객체에 저장했다. 그런 다음 Answer 모델의 question 속성에 방금 조회한 q 객체를 대입해 답변을 생성했다.

Answer 모델에는 어떤 질문에 해당하는 답변인지 연결할 목적으로 question_id 속성이 있다. Answer 모델의 객체를 생성할 때 question에 q를 대입하면 question_id에 값을 지정하지 않아도 자동으로 입력되어 저장된다. 따라서 question_id에 값을 설정할 필요가 없다.

Answer도 Question 모델과 마찬가지로 id 속성이 기본 키이므로 값이 자동으로 생성된다. 다음 명령으로 id값을 확인해 보고 이 값을 이용해 데이터도 조회해 보자.

>>> a.id
1
>>> a = Answer.query.get(1)
>>> a
<Answer 1>
답변에 연결된 질문 찾기 vs 질문에 달린 답변 찾기
Answer 모델의 question 속성을 이용하면 "답변에 연결된 질문"을 조회할 수 있다.

>>> a.question
<Question 2>
답변에 연결된 질문 찾기는 Answer 모델에 question 속성이 정의되어 있어서 매우 쉽다. 그런데 반대의 경우도 가능할까? 즉, 질문에서 답변을 찾을수 있을까?

Question 모델과 Answer 모델은 현재 연결된 상태이고, Answer 모델의 question 속성에 역참조 설정 backref=db.backref('answer_set')이 적용되어 있다. 그러므로 이를 사용하면 질문에 연결된 답변들을 쉽게 가져올 수 있다.

>>> q.answer_set
[<Answer 1>]
지금 여러분은 역참조의 유용함을 별로 느끼지 못할 것이다. 하지만 이 기능은 개발자에게 큰 편의를 가져다주는 신통방통한 녀석이다. 앞으로도 자주 사용할 예정이니 꼭 기억해 두자.

이제 플라스크 셸을 종료하자.

플라스크 셸에서 빠져 나오려면 <Ctrl+Z>를 누르고 <Enter>를 입력한다. 또는 quit()를 입력한다.

마지막 편집일시 : 2022년 11월 1일 3:18 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2-05 질문 목록과 질문 상세 기능 만들기
[완성 소스] : github.com/pahkey/jump2flask/tree/2-05
[실습 영상] : https://youtu.be/5dffM-U06-w

이번 장에서는 파이보의 핵심 기능인 질문 목록과 질문 상세 기능을 구현해 보자.

질문 목록 만들기
게시판 질문 목록 출력하기
질문 목록 템플릿 작성하기
플라스크에서 자주 사용하는 템플릿 태그
질문 상세 기능 만들기
라우팅 함수
질문 상세 템플릿 작성하기
404 오류 페이지 표시하기
블루프린트로 기능 분리하기
질문 목록, 질문 상세 기능 분리하기
url_for로 리다이렉트 기능 추가하기
하드 코딩된 URL에 url_for 함수 이용하기
질문 목록 만들기
플라스크 서버를 실행하고 웹 브라우저에서 localhost:5000에 접속해 보자. 지금까지 실습을 잘 따라 했다면 화면에 "Pybo index"라는 문구가 출력될 것이다.

게시판 질문 목록 출력하기
이 화면 대신 게시판 질문 목록이 출력되도록 main_views.py 파일을 수정해 보자. index 함수가 문자열을 반환하던 부분을 질문 목록을 출력하도록 변경해 보자.

[파일명: projects/myproject/pybo/views/main_views.py]

from flask import Blueprint, render_template
from pybo.models import Question

(...생략...)

@bp.route('/')
def index():
    question_list = Question.query.order_by(Question.create_date.desc())
    return render_template('question/question_list.html', question_list=question_list)

질문 목록 데이터는 question_list = Question.query.order_by(Question.create_date.desc()) 로 얻을 수 있다. order_by는 조회 결과를 정렬하는 함수이다. 
order_by(Question.create_date.desc()) 의 의미는 조회된 데이터를 작성일시 기준으로 역순으로 정렬하라는 의미이다. 
역순이 아닌 작성일시 순으로 조회하기 위해서는 order_by(Question.create_date.asc()) 또는 asc() 를 생략하여 order_by(Question.create_date)와 같이 사용하면 된다.

render_template 함수는 템플릿 파일을 화면으로 렌더링 하는 함수이다. 조회한 질문 목록 데이터를 render_template 함수의 파라미터로 전달하면 템플릿에서 해당 데이터로 화면을 구성할수 있다. 
여기서 사용한 question/question_list.html 파일을 템플릿 파일이라고 부른다.

템플릿 파일은 쉽게 말해 파이썬 문법을 사용할 수 있는 HTML 파일이다. 템플릿 파일은 HTML 파일과 비슷 하지만 플라스크의 특별한 태그를 사용할 수 있다. 템플릿 파일은 잠시 후 자세히 다룬다.

질문 목록 템플릿 작성하기

이제 render_template 함수에서 사용할 question/question_list.html 템플릿 파일을 작성해야 한다. 그런데 이 파일은 어디에 저장해야 할까? 
바로 플라스크가 앱으로 지정한 모듈 아래에 templates라는 디렉터리에 저장하면 된다. 
그러면 별다른 설정을 하지 않아도 temptates 디렉터리를 템플릿 디렉터리로 인식한다. 다음 명령으로 pybo 앱 디렉터리 아래에 templates 디렉터리를 생성하자.

(myproject) c:\projects\myproject> cd pybo
(myproject) c:\projects\myproject\pybo> mkdir templates

템플릿 디렉터리가 준비되었으므로 이제 해당 디렉터리에 템플릿 파일을 만들어 보자. render_template 함수에 지정한 템플릿 파일명은 question/question_list.html이므로 다음의 위치에 템플릿 파일을 생성하자.

그리고 다음과 같은 내용으로 코드를 작성하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

<!-- 질문 목록 -->
{% if question_list %}
    <ul>
    {% for question in question_list %}
        <li><a href="/detail/{{ question.id }}/">{{ question.subject }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>질문이 없습니다.</p>
{% endif %}
템플릿 파일에 사용한 {% if question_list %}와 같은 특이한 표현이 눈에띌 것이다. {% 와 %}로 둘러싸인 문장을 템플릿 태그라고 한다. 이 태그가 파이썬 코드와 연결된다. question_list.html 파일에 사용한 템플릿 태그들을 잠시 살펴보자.

{% if question_list %}
위 코드는 render_template 함수에서 전달받은 질문 목록 데이터 question_list가 있는지 검사한다.

{% for question in question_list %}
위 코드는 question_list에 저장된 데이터를 하나씩 꺼내 question 객체에 대입한다. 파이썬의 for~in 문을 떠올리면 쉽게 이해할 수 있을 것이다.

{{ question.id }}
위 코드는 바로 앞의 for 문에서 얻은 question 객체의 id를 출력한다. {{ question.subject }} 코드도 같은 맥락으로 이해할 수 있다. 템플릿 태그는 파이썬에 입문한 독자라면 충분히 이해할 수 있을 것이다.

이제 로컬 서버를 실행하고 http://localhost:5000으로 접속하면 다음과 같은 화면이 보인다.
플라스크 셸에서 등록한 질문 1건이 조회된 모습이다.


질문 상세 기능 만들기
앞선 실습에서 만든 질문 목록 페이지에서 질문 링크를 눌러 보면 다음과 같은 오류 메시지가 표시된다.

이 오류는 주소 표시줄에 보이는 http://localhost:5000/detail/2/ 페이지의 URL을 정의하지 않아 발생한 것이다. 이 문제를 해결해 질문 제목과 내용이 표시되도록 해보자.

라우팅 함수
질문 목록에서 링크를 누르면 다음과 같은 질문 상세 URL을 요청한다.

http://localhost:5000/detail/2/
이 URL은 "Question 모델 데이터 중 id값이 2인 데이터를 조회하라"는 의미다. 이와 같은 요청 URL에 대응할 수 있도록 main_views.py 파일에 라우팅 함수를 추가하자.

[파일명: projects/myproject/pybo/views/main_views.py]

(...생략...)

@bp.route('/detail/<int:question_id>/')
def detail(question_id):
    question = Question.query.get(question_id)
    return render_template('question/question_detail.html', question=question)

detail 함수의 매개변수 question_id에는 URL 매핑 규칙에 사용한 <int:question_id>가 전달된다. 
즉, http://localhost:5000/detail/[[MARK]]2[[/MARK]]/ 페이지를 요청하면 main_views.py 파일의 detail 함수가 실행되고, 매개변수 question_id에는 2라는 값이 전달된다.

URL 매핑 규칙에 있는 int는 question_id에 숫자값이 매핑됨을 의미한다.


질문 상세 템플릿 작성하기
이어서 질문 상세 화면에 해당하는 question/question_detail.html 템플릿을 작성하자. templates/question 디렉터리에 question_detail.html 파일을 만들고 다음 코드를 작성하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>
{{ question.subject }}와 {{ question.content }}의 question은 render_template 함수에 전달한 질문 객체이다. 
이제 웹 브라우저에서 http://localhost:5000/detail/2/ 페이지를 다시 요청해 보자. 그러면 question_id가 2인 질문의 제목과 내용이 표시된다.

404 오류 페이지 표시하기

이번에는 웹 브라우저에서 http://localhost:5000/detail/30/ 페이지를 요청해 보자. 그러면 빈 페이지(아무것도 보이지 않는 하얀 화면)가 나타날 것이다.

왜냐하면 detail 함수가 전달받은 question_id가 30이므로 Question.query.get(30)이 호출되는데 question_id가 30인 질문은 없기 때문이다. 
그런데 이처럼 잘못된 URL을 요청받을 때 단순히 빈 페이지를 표시하면 안된다. 이때는 보통 "Not Found (404)"처럼 오류 페이지를 표시해야 한다. 404는 HTTP 주요 응답 코드의 하나이다. 
아래 표에서 HTTP 주요 응답 코드의 종류를 확인하자.

응답 코드	설명
200	성공(OK)
500	서버 오류(Internal Server Error)
404	서버가 요청한 페이지 없음(Not Found)
존재하지 않는 페이지를 요청받으면 빈 페이지 대신 404 오류 페이지를 표시하도록 다음처럼 detail 함수의 일부를 수정해 보자.

[파일명: projects/myproject/pybo/views/main_views.py]

(...생략...)

@bp.route('/detail/<int:question_id>/')
def detail(question_id): 
    question = Question.query.get_or_404(question_id)   
    return render_template('question/question_detail.html', question=question)
기존 코드에서 get 함수 대신 get_or_404 함수를 사용했다. get_or_404 함수는 해당 데이터를 찾을 수 없는 경우에 404 페이지를 출력해 준다. 
이제 웹 브라우저에서 http://localhost:5000/detail/30/ 페이지를 다시 요청하면 404 오류 페이지가 출력된다.

블루프린트로 기능 분리하기
지금까지는 질문 목록과 질문 상세 기능을 main_views.py 파일에 구현했다. 모든 기능을 main_views.py 파일에 구현할 수도 있지만, 각 기능을 블루프린트 파일로 분리해서 관리하면 유지·보수하는 데 유리하다.

질문 목록, 질문 상세 기능 분리하기

pybo/views 디렉터리에 question_views.py 파일을 새로 만들고 질문 목록과 질문 상세 기능을 이동해 보자.

[파일명: projects/myproject/pybo/views/question_views.py]

from flask import Blueprint, render_template
from pybo.models import Question
bp = Blueprint('question', __name__, url_prefix='/question')

@bp.route('/list/')
def _list():
    question_list = Question.query.order_by(Question.create_date.desc())
    return render_template('question/question_list.html', question_list=question_list)

@bp.route('/detail/<int:question_id>/')
def detail(question_id):
    question = Question.query.get_or_404(question_id)
    return render_template('question/question_detail.html', question=question) 

quesiton_views.py 파일에 main_views.py 파일의 내용을 그대로 복사하되, 블루프린트 객체를 생성할 때 question이라는 별칭을 사용하고, url_prefix에는 /question을 사용해 main_views.py 파일의 블루프린트와 구별했다. 
그리고 index 함수명을 _list로 바꾸고 URL 매핑 규칙도 /에서 /list/로 바꿨다.

질문 목록 기능에 해당하는 함수명을 list가 아니라 _list로 지정한 이유는 list가 파이썬의 예약어이기 때문이다.

이제 question_views.py 파일에 등록한 블루프린트를 적용하기 위해 pybo/__init__.py 파일도 수정하자.

[파일명: projects/myproject/pybo/__init__.py]

(...생략...)

def create_app():
    (...생략...)

    # 블루프린트
    from .views import main_views, question_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)

    (...생략...)




======================================================================================
url_for로 리다이렉트 기능 추가하기
question_views.py 파일에 질문 목록과 질문 상세 기능을 구현했으므로 main_views.py 파일에서는 해당 기능을 제거하자.

[파일명: projects/myproject/pybo/views/main_views.py]

from flask import Blueprint, url_for
from werkzeug.utils import redirect

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/hello')
def hello_pybo():
    return 'Hello, Pybo!'

@bp.route('/')
def index():
    return redirect(url_for('question._list'))

detail 함수는 제거하고 index 함수는 question._list에 해당하는 URL로 리다이렉트(redirect)하도록 코드를 수정했다. redirect 함수는 입력받은 URL로 리다이렉트하고, url_for 함수는 라우팅 함수명으로 URL을 역으로 찾는 함수이다.

redirect(URL) - URL로 페이지를 이동
url_for(라우팅 함수명) - 라우팅 함수에 매핑되어 있는 URL을 리턴
url_for 함수에 전달된 question._list는 question, _list 순서로 해석되어 라우팅 함수를 찾는다. question은 등록된 블루프린트 별칭, _list는 블루프린트에 등록된 함수명이다. 
따라서 question._list는 question이라는 별칭으로 등록한 question_views.py 파일의 _list 함수를 의미한다. 
그리고 _list 함수에 등록된 URL 매핑 규칙은 @bp.route('/list/')이므로 url_for('question._list')는 bp의 프리픽스 URL인 /question/과 /list/가 더해진 /question/list/ URL을 반환한다.

이제 http://localhost:5000에 접속하면 리다이렉트 기능 덕분에 localhost:5000/question/list/ 페이지가 호출될 것이다. 확인해 보자.

하드 코딩된 URL에 url_for 함수 이용하기
앞서 url_for 함수를 이용하면 라우팅 함수명으로 URL을 찾아준다고 했다. 이 기능을 이용해 질문 목록에서 질문 상세를 호출하는 링크도 url_for를 사용하도록 해보자.

[파일명: C:/projects/myproject/pybo/templates/question/question_list.html]

<!-- 질문 목록 -->
{% if question_list %}
    <ul>
    {% for question in question_list %}
        <li><a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a></li>
    {% endfor %}
    </ul>
{% else %}
    <p>질문이 없습니다.</p>
{% endif %}
기존에는 상세 페이지로 연결하는 링크가 /detail/{{ question.id }}/ 처럼 하드 코딩되어 있었다. 이 부분을 url_for 함수를 이용해 question.detail 라우팅 함수로 URL을 찾도록 변경했다. 
이때 question.detail 함수는 question_id 매개변수가 필요하므로 question_id를 전달해야 한다.

이제 질문 목록에서 제목을 누르면 상세 페이지로 잘 이동할 것이다.

점프 투 플라스크
url_for 함수를 사용하면 유지·보수하기 쉬워진다
템플릿에서 URL을 사용할 때 다음과 같이 url_for를 사용하지 않으면 어떻게 될까?

<a href="/question/detail/{{ question.id }}">{{question.subject}}</a>
이렇게 URL을 하드 코딩하면 유지·보수하는 데 불리하다. 예를 들어 다음처럼 URL 구성 방식 자체가 변경되면 이런 코드는 쉽게 대응하기 어렵다.

localhost:5000/detail/question/2
localhost:5000/detail/2/question
실제 프로젝트에서 URL 리팩토링은 빈번하게 발생한다.

이와 같이 URL 구성 방식을 자주 변경하면 템플릿에서 사용한 모든 URL을 일일이 찾아가며 수정해야 할 것이다. 이런 부담을 줄이고 싶다면 url_for 함수를 사용하기를 추천한다.

마지막 편집일시 : 2022년 11월 1일 3:20 오후
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-06 답변 등록 기능 만들기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-06
[실습 영상] : https://youtu.be/767Sl_tv0ks
앞 장에서 우리는 질문을 조회하는 기능을 만들었다. 이번에는 질문에 답변을 등록하고 보여 주는 기능을 만들어 보자.

답변 저장하기
답변 등록 버튼 만들기
답변 블루프린트 만들기
bp.route 애너테이션
create 함수
답변 블루프린트 등록하기
답변 표시하기
답변 저장하기
질문 상세 화면에 답변을 입력하기 위한 텍스트 창(textarea)과 <답변등록> 버튼을 생성하고, 이 버튼을 누르면 텍스트 창에 입력된 답변이 저장되도록 구현해 보자.

답변 등록 버튼 만들기
질문 상세 템플릿에 답변 저장을 위한 form, textarea, input 엘리먼트를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>
<form action="{{ url_for('answer.create', question_id=question.id) }}" method="post">
    <textarea name="content" id="content" rows="15"></textarea>
    <input type="submit" value="답변등록">
</form>
답변 저장 URL은 form 태그의 action 속성에 url_for('answer.create', question_id=question.id)로 지정했다. 이후 <답변등록> 버튼을 누르면 POST 방식으로 이 URL이 호출(submit)될 것이다.

코드를 추가한 후 웹 브라우저에서 질문 상세 페이지를 요청해 보자. 그러면 다음처럼 "answer.create에 해당하는 URL을 찾을 수 없다"는 오류 메시지가 화면에 나타날 것이다.



이 오류를 해결하려면 "answer" 별칭에 해당하는 답변 블루프린트 파일을 작성하고 create 라우팅 함수를 만들어야 한다.

답변 블루프린트 만들기

앞에서 질문을 관리하는 블루프린트를 만들었듯이, 답변을 관리하는 블루프린트를 만들어 보자. views 디렉터리에 answer_views.py 파일을 만들고 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime

from flask import Blueprint, url_for, request
from werkzeug.utils import redirect

from pybo import db
from pybo.models import Question, Answer

bp = Blueprint('answer', __name__, url_prefix='/answer')


@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    question = Question.query.get_or_404(question_id)
    content = request.form['content']
    answer = Answer(content=content, create_date=datetime.now())
    question.answer_set.append(answer)
    db.session.commit()
    return redirect(url_for('question.detail', question_id=question_id))
bp.route 애너테이션
create 함수의 매개변수 question_id는 URL 매핑 규칙을 통해 전달된다. 만약 http://locahost:5000/answer/create/[[MARK]]2[[/MARK]]/ 페이지를 요청받으면 question_id에는 2가 넘어온다. 그리고 @bp.route의 methods 속성에는 'POST'를 지정했다. 답변을 저장하는 질문 상세 템플릿의 form 엘리먼트가 POST 방식이므로 같은 값을 지정해야 한다. 만약 @bp.route에 똑같은 폼 방식을 지정하지 않으면 다음과 같은 오류가 발생하므로 주의하자.



methods 속성은 웹 브라우저에서 요청하는 GET 또는 POST와 같은 폼 방식을 의미한다.

create 함수
템플릿의 form 엘리먼트를 통해 전달된 데이터들은 create 함수에서 request 객체로 얻을 수 있다. request.form['content'] 코드는 POST 폼 방식으로 전송된 데이터 항목 중 name 속성이 content인 값을 의미한다. 그리고 question.answer_set은 "질문에 달린 답변들"을 의미한다. 앞에서 Question과 Answer 모델이 연결되어 있어 backref에 설정한 answer_set를 사용할 수 있다고 설명했던 내용을 기억하자. 그리고 답변을 생성한 후 화면을 상세 화면으로 이동하도록 redirect 함수를 사용했다.

점프 투 플라스크
답변을 저장하는 방법은 한 가지만 있을까?
아니다. 다음처럼 Answer 모델을 직접 사용해도 답변을 저장할 수 있다. 이번 실습 코드와 다음 코드 중 어떤 것을 사용해도 결과는 같다.


[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime

from flask import Blueprint, url_for, request
from werkzeug.utils import redirect

from pybo import db
from pybo.models import Question, Answer

bp = Blueprint('answer', __name__, url_prefix='/answer')


@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    question = Question.query.get_or_404(question_id)
    content = request.form['content']
    answer = Answer(question=question, content=content, create_date=datetime.now())
    db.session.add(answer)
    db.session.commit()
    return redirect(url_for('question.detail', question_id=question_id))
점프 투 플라스크
request 객체는 무엇일까?
request 객체는 플라스크에서 생성 과정 없이 사용할 수 있는 기본 객체다. 플라스크는 브라우저의 요청부터 응답까지의 처리 구간에서 request 객체를 사용할 수 있게 해준다. 이 객체를 이용해 브라우저에서 요청한 정보를 확인할 수 있다.

request 객체 외에 g라는 객체도 알아야 하는데 g는 조금 후에 알아보기로 하자.

답변 블루프린트 등록하기
위에서 생성한 답변 블루프린트를 pybo/__init__.py 파일에 등록하자.

[파일명: projects/myproject/pybo/__init__.py]

(...생략...)

def create_app():
    (...생략...)

    # 블루프린트
    from .views import main_views, question_views, answer_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)
    app.register_blueprint(answer_views.bp)

    return app
이제 질문 상세 페이지에 다시 접속해 보자. 그러면 다음처럼 답변을 등록할 수 있는 창과 등록 버튼이 보인다.




화면이 엉성해 보이지만 조금만 참자. 다음 절에서 화면을 깔끔하게 만드는 방법도 설명한다.

텍스트 창에 아무 값이나 입력하고 <답변등록>을 눌러 보자. 하지만 아무런 변화가 없을 것이다. 왜냐하면 우리는 아직 등록한 답변을 표시하는 기능을 추가하지 않았기 때문이다.

답변 표시하기
이번에는 질문에 등록된 답변을 화면에 표시해 보자. 답변은 등록된 질문 밑에 보여야 하므로 질문 상세 템플릿에 다음 코드를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<h1>{{ question.subject }}</h1>
<div>
    {{ question.content }}
</div>
<h5>{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
<div>
    <ul>
    {% for answer in question.answer_set %}
        <li>{{ answer.content }}</li>
    {% endfor %}
    </ul>
</div>
<form action="{{ url_for('answer.create', question_id=question.id) }}" method="post">
    <textarea name="content" id="content" rows="15"></textarea>
    <input type="submit" value="답변등록">
</form>
기존 코드에서 답변을 확인할 수 있는 영역을 추가했다. {{ question.answer_set|length }} 코드는 답변 개수를 의미한다. length는 템플릿 필터인데 객체의 길이를 반환해 준다. 이처럼 템플릿 필터는 | 문자 뒤에 추가해서 사용한다.

점프 투 플라스크
템플릿 내장 필터
템플릿에서 사용할 수 있는 필터는 다음 URL에서 확인할 수 있다

https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters
이와 같이 수정하고 질문 상세 페이지를 새로 고침하면 이제 등록한 답변들이 보인다.



축하한다! 이제부터 여러분은 답변을 저장하고 또 볼 수 있게 되었다.

마지막 편집일시 : 2023년 8월 14일 7:58 오후
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-07 화면 예쁘게 꾸미기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-07
[실습 영상] : https://youtu.be/KsBfPE5q1PU
지금까지 질문과 답변을 등록하고 조회하는 기능을 만들었다. 그런데 그럴싸한 화면이 아니라서 아쉽다. 이번에는 스타일시트를 이용해 웹 페이지에 디자인을 적용하는 방법에 대해서 알아보자.

웹 페이지에 디자인을 적용하려면 CSS를 사용해야 한다. CSS를 파이보에 적용하려면 CSS 파일이 pybo/static 디렉터리에 있어야 한다. 이때 CSS 파일은 플라스크에서 정적(static) 파일로 분류한다. 정적 파일은 주로 이미지(.png, .jpg)나 자바스크립트(.js), 스타일시트(.css)와 같은 파일을 의미한다.

static 디렉터리 만들고 스타일시트 작성하기
질문 상세 화면에 스타일시트 적용하기
static 디렉터리 만들고 스타일시트 작성하기
정적 파일을 저장할 디렉터리는 템플릿 디렉터리와 마찬가지로 플라스크가 앱으로 지정한 모듈 아래에 static이라는 이름으로 생성하면 된다. 우리가 사용한 플라스크 앱은 pybo 모듈이므로 pybo 디렉터리 아래에 static 디렉터리를 생성하자.

(myproject) c:\projects\myproject> cd pybo
(myproject) c:\projects\myproject\pybo> mkdir static
static 디렉터리를 만들었으면 그곳에 style.css 파일을 만들고 다음과 같은 코드를 작성하자.

[파일명: projects/myproject/pybo/static/style.css]

textarea {
    width:100%;
}
input[type=submit] {
    margin-top:10px;
}
style.css 파일은 질문 상세 페이지에 사용할 목적으로 작성했다. 답변을 등록할 때 사용하는 텍스트 창(textarea)의 너비를 100%로 넓히고, <답변등록> 버튼 위에 마진을 10px 추가했다. 여기서 텍스트 창에 지정한 너비 100%란 웹 브라우저 너비를 기준으로 한다. 즉, 웹 브라우저의 너비에 따라서 텍스트 창의 크기가 꽉 차도록 조절된다.

질문 상세 화면에 스타일시트 적용하기
이제 작성한 스타일시트를 질문 상세 화면에 적용해 보자. question_detail.html 파일을 열고 가장 위쪽에 다음의 코드 한 줄을 추가하면 된다.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
<h1>{{ question.subject }}</h1>
(...생략...)
추가한 코드는 static 디렉터리의 style.css 파일을 연결한다는 의미다. 그리고 url_for 함수는 앞에서 배운 URL 추적 함수다. 앞에서는 url_for가 라우팅 함수의 URL을 찾아준다고 했지만 정적 파일의 URL도 찾아준다.


이제 질문상세 화면이 어떻게 변경되었는지 확인해 보자.



텍스트 창이 넓어지고 <답변등록> 버튼 위에 여유 공간이 생겼다.

축하한다! 이제부터 여러분은 조금 그럴싸한 화면을 만들 수 있을 것이다.

마지막 편집일시 : 2022년 8월 10일 9:40 오전

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-08 부트스트랩으로 더 쉽게 화면 꾸미기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-08
[실습 영상] : https://youtu.be/ycMgH8Fo4KU
웹 디자이너 없이 웹 프로그램을 만들다 보면 화면 디자인 작업을 하는 데 얼마나 많은 시간과 고민이 필요한지 알 수 있을 것이다. 이번에 소개하는 부트스트랩(Bootstrap)은 개발자 혼자서도 화면을 괜찮은 수준으로 만들 수 있게 도와주는 도구다. 부트스트랩은 트위터를 개발하면서 만들어졌고 지속적으로 관리되고 있는 오픈소스 프로젝트이다.

파이보에 부트스트랩을 적용해 멋진 모습으로 변신해 보자.

부트스트랩 설치
질문 목록에 부트스트랩 적용하기
질문 상세에 부트스트랩 적용하기
부트스트랩 설치
부트스트랩은 다음 URL에서 다운받아 설치할수 있다.

부트스트랩 다운로드 - https://getbootstrap.com/docs/5.1/getting-started/download/

점프 투 플라스크
부트스트랩 주의사항
부트스트랩은 3.x, 4.x, 5.x 등의 버전이 존재하고 메이저 번호(3, 4, 5)에 따라 그 사용방법이 다르다. 이 책은 부트스트랩 버전 5 기준으로 실습을 진행한다. 다른 부트스트랩 버전을 사용하면 이 책의 예제가 정상 동작하지 않는다.



부트스트랩 다운로드 페이지 접속후 "Download" 버튼을 누르면 다음과 같은 파일이 다운로드 된다.

bootstrap-5.1.3-dist.zip
이 책을 작성하는 시점의 부트스트랩 최신 버전은 5.1.3 이다. 압축파일 안에는 많은 파일들이 있는데 이 중에서 bootstrap.min.css 파일을 카피하여 스태틱 디렉터리에 저장하자.

구분	파일 위치
압축파일내 경로	bootstrap-5.1.3-dist.zip\bootstrap-5.1.3-dist\css\bootstrap.min.css
카피할 경로	projects\myproject\pybo\static\bootstrap.min.css
나중에 진행되는 챕터에서 bootstrap.min.js 파일도 필요하니 bootstrap-5.1.3-dist.zip 파일을 삭제하지 말자.


질문 목록에 부트스트랩 적용하기
질문 목록에 부트스트랩을 적용해 보자. question_list.html 파일 맨 위에 있는 bootstrap.min.css 파일을 연결하는 것을 시작으로 전체를 수정해야 한다.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
<div class="container my-3">
    <table class="table">
        <thead>
        <tr class="table-dark">
            <th>번호</th>
            <th>제목</th>
            <th>작성일시</th>
        </tr>
        </thead>
        <tbody>
        {% if question_list %}
        {% for question in question_list %}
        <tr>
            <td>{{ loop.index }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date }}</td>
        </tr>
        {% endfor %}
        {% else %}
        <tr>
            <td colspan="3">질문이 없습니다.</td>
        </tr>
        {% endif %}
        </tbody>
    </table>
</div>
기존 질문 목록은 ul 엘리먼트로 간단히 표시했지만 여기서는 table 엘리먼트로 표현했다. table 태그와 하위 태그들에 부트스트랩을 적용했는데, 여기에 사용된 class="container my-3", class="table", class="table-dark" 등이 바로 부트스트랩이 제공하는 클래스다.

앞으로 다른 화면을 만들 때도 부트스트랩을 사용할 것이다. 그러나 이 책의 주제가 부트스트랩은 아니므로 간단히 설명한다. 혹시 자세한 내용이 궁금하다면 부트스트랩 공식 문서를 읽어 보기를 권한다.

부트스트랩 공식 문서: * https://getbootstrap.com/docs/5.1/getting-started/introduction/
이제 웹 브라우저에서 http://localhost:5000/question/list에 접속하면 부트스트랩이 적용된 질문 목록 화면을 볼 수 있다.



질문 상세에 부트스트랩 적용하기
질문 상세도 부트스트랩을 적용해 보자.

[파일명: projects/myproject/pybo/templates/question_detail.html]


<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
<div class="container my-3">
    <!-- 질문 -->
    <h2 class="border-bottom py-2">{{ question.subject }}</h2>
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ question.create_date }}
                </div>
            </div>
        </div>
    </div>
    <!-- 답변 목록 -->
    <h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
    {% for answer in question.answer_set %}
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ answer.create_date }}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}
    <!-- 답변 등록 -->
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        <div class="mb-3">
            <textarea name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
    </form>
</div>
이번에는 수정사항이 좀 많다. 부트스트랩으로 화면을 구성하다 보면 가끔은 이렇게 많은 양의 HTML코드를 작성해야 한다. 질문이나 답변은 하나의 뭉치에 해당하므로 부트스트랩의 card 컴포넌트를 사용했다.

부트스트랩 card 컴포넌트 : https://getbootstrap.com/docs/5.1/components/card/

질문 상세 템플릿에 사용한 부트스트랩 클래스를 다음처럼 표로 정리하였다.

부트스트랩 클래스	설명
card, card-body, card-text	부트스트랩 Card 컴포넌트
badge	부트스트랩 Badge 컴포넌트
form-control, form-label	부트스트랩 Form 컴포넌트
border-bottom	아래방향 테두리 선
my-3	상하 마진값 3
py-2	상하 패딩값 2
p-2	상하좌우 패딩값 2
d-flex justify-content-end	컴포넌트의 우측 정렬
bg-light	연회색 배경
text-dark	검은색 글씨
text-start	좌측 정렬
btn btn-primary	부트스트랩 버튼 컴포넌트
그리고 질문 내용과 답변 내용에는 style="white-space: pre-line;" 스타일을 지정해 주었다. 글 내용의 줄 바꿈을 정상적으로 보여주기위해 적용한 스타일이다.

부트스트랩을 적용한 질문 상세 화면은 다음과 같다.



이처럼 부트스트랩을 사용하면 만족스러운 화면을 빠르게 만들 수 있다.

마지막 편집일시 : 2022년 11월 1일 3:22 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-09 표준 HTML과 템플릿 상속 사용해 보기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-09
[실습 영상] : https://youtu.be/RMAv052dcSM
혹시 눈치챘는지 모르겠지만 우리가 지금까지 작성한 질문 목록과 질문 상세 템플릿 파일은 표준 HTML 구조가 아니다. 어떤 운영체제나 브라우저를 사용하더라도 웹 페이지가 동일하게 보이고 정상적으로 동작하게 하려면 반드시 웹 표준을 지키는 HTML 문서를 작성해야 한다.

표준 HTML 구조는 어떻게 생겼을까?
템플릿을 표준 HTML 구조로 바꾸기
템플릿 파일의 기본 틀 작성하기
질문 목록 템플릿 수정하기
질문 상세 템플릿 파일 수정하기
표준 HTML 구조 확인하기
기존 스타일 파일 내용 비우기
표준 HTML 구조는 어떻게 생겼을까?
표준 HTML 문서의 구조는 다음과 같아야 한다.

[표준 HTML 구조의 예]

<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
    <!-- pybo CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Hello, pybo!</title>
</head>
<body>
(... 생략 ...)
</body>
</html>
표준 HTML 문서의 구조는 위와 같이 html, head, body 엘리먼트가 있어야 하고 CSS 파일 링크는 head 엘리먼트 안에 있어야 한다. 또한 head 엘리먼트 안에는 meta, title 엘리먼트 등이 포함되어야 한다.

점프 투 플라스크
**태그와 엘리먼트 **
<table> (... 생략 ...) </table>  <!-- table 엘리먼트 -->
위에서 <table>은 table 태그이고 <table> ~ </table> 처럼 table 태그로 시작해서 table 태그로 닫힌 구간(Block)은 table 엘리먼트이다.

템플릿을 표준 HTML 구조로 바꾸기
앞에서 작성한 질문 목록, 질문 상세 템플릿을 표준 HTML 구조가 되도록 수정해 보자. 그런데 템플릿 파일들을 모두 표준 HTML 구조로 변경하면 body 엘리먼트 바깥 부분(head 엘리먼트 등)은 모두 같은 내용으로 중복될 것이다. 그러면 CSS 파일 이름이 변경되거나 새로운 CSS 파일이 추가될 때마다 모든 템플릿 파일을 일일이 수정해야 한다.

플라스크는 이런 불편함을 해소하기 위한 템플릿 상속(extends) 기능을 제공한다. 여기서는 단순히 템플릿을 표준 HTML 구조로 바꿀 뿐 아니라 템플릿 상속 기능까지 사용할 것이다.

그러면 파일을 하나씩 수정해 보자.


템플릿 파일의 기본 틀 작성하기
우선 템플릿 파일의 기본 틀이 되는 base.html 템플릿을 작성하자. 모든 템플릿에서 공통으로 입력할 내용을 여기에 포함한다고 생각하면 된다.

[파일명: projects/myproject/pybo/templates/base.html]

<!doctype html>
<html lang="ko">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
    <!-- pybo CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <title>Hello, pybo!</title>
</head>
<body>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
</body>
</html>
body 엘리먼트에 {% block content %}와 {% endblock %} 템플릿 태그가 보일 것이다. 바로 이 부분이 base.html 템플릿 파일을 상속한 템플릿에서 구현해야 할 영역이 된다.

질문 목록 템플릿 수정하기
질문 목록을 나타내는 question_list.html 템플릿 파일을 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
    </table>
</div>
{% endblock %}
base.html 템플릿 파일을 상속받고자 {% extends 'base.html' %} 템플릿 태그를 사용했다. 그리고 {% block content %}와 {% endblock %} 사이에 question_list.html에서만 사용할 내용을 작성했다. 그리고 기존에 bootstrap.min.css 파일을 링크했던 첫번째 라인은 더이상 필요없으므로 삭제하자. 왜냐하며 base.html 기본 템플릿에 이미 해당 라인이 포함되어 있기 때문이다.

이제 question_list.html은 base.html을 상속받았으므로 표준 HTML 구조를 갖추게 된다.

질문 상세 템플릿 파일 수정하기

질문 상세를 나타내는 question_detail.html 파일도 마찬가지 방법으로 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

<link rel="stylesheet" href="{{ url_for('static', filename='bootstrap.min.css') }}">
{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    (... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        (... 생략 ...)
    </form>
</div>
{% endblock %}
{% extends 'base.html' %} 템플릿 태그를 맨 위에 추가하고 기존 내용 위 아래로 {% block content %}와 {% endblock %}를 작성했다.

표준 HTML 구조 확인하기
템플릿 상속을 적용한 후 질문 목록, 질문 상세를 조회해 보자. 화면에 보여지는 것은 동일하지만 표준 HTML 구조로 변경된 것을 확인할 수 있다.

브라우저에서 소스보기 기능으로 생성된 HTML을 확인할 수 있다.

[질문 목록 - 브라우저 소스보기 화면]



기존 스타일 파일 내용 비우기
부트스트랩을 사용하게 되었으므로 style.css 파일의 내용을 비우자. 이 파일은 이후 부트스트랩으로 표현할 수 없는 스타일을 위해 사용할 것이므로 파일 자체를 삭제하지 말고 내용만 비워 두자.

[파일명: projects/myproject/pybo/static/style.css]

textarea {
    width:100%;
}

input[type=submit] {
    margin-top:10px;
}
마지막 편집일시 : 2022년 8월 10일 1:10 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2-10 폼 모듈로 데이터 검증 더 쉽게 하기


[완성 소스] : github.com/pahkey/jump2flask/tree/2-10
[실습 영상] : https://youtu.be/gPo1p7mwxMc
웹 프로그램에서 폼(form)은 사용자에게 입력 양식을 편리하게 제공하기 위해 사용한다. 이번에는 플라스크의 폼 모듈을 어떻게 사용하는지 알아보자. 폼 모듈을 사용하면 폼으로 전송되는 데이터의 필수 여부, 길이, 형식 등을 더 쉽게 검증할 수 있다.

플라스크 폼 모듈 설치하기
질문 등록
질문 등록 버튼 만들기
질문 폼 만들기
질문 등록 라우팅 함수 추가하기
질문 등록 템플릿 작성하기
질문 등록 기능 사용해 보기
질문 전송 방식 수정하기
폼 데이터를 저장하는 코드 작성하기
폼에 부트스트랩 적용하기
수작업으로 폼 작성하기
질문 등록 완성하기
오류 내용을 표시해 원인 알아내기
CSRF 토큰 오류 처리하기
입력한 값 유지하고 오류 메시지 한글로 바꾸기
입력한 값 유지하기
오류 메시지 한글로 바꾸기
답변 등록에 폼 사용하기
답변 등록 폼 추가하기
답변 등록 라우팅 함수 수정하기
CSRF 코드와 오류 표시 기능 추가하기
플라스크 폼 모듈 설치하기
플라스크에서 폼을 사용하려면 Flask-WTF 라이브러리를 설치해야 한다. 명령 프롬프트에서 다음 명령으로 Flask-WTF를 설치하자.

(myproject) c:\projects\myproject> pip install flask-wtf
Collecting Flask-WTF
    (... 생략 ...)
그리고 Flask-WTF를 사용하려면 플라스크의 환경변수 SECRET_KEY가 필요하다.

점프 투 플라스크
SECRET_KEY
SECRET_KEY는 CSRF(cross-site request forgery)라는 웹 사이트 취약점 공격을 방지하는 데 사용된다. CSRF는 사용자의 요청을 위조하는 웹 사이트 공격 기법인데 SECRET_KEY를 기반으로 해서 생성되는 CSRF 토큰은 폼으로 전송된 데이터가 실제 웹 페이지에서 작성된 데이터인지를 판단해 주는 가늠자 역할을 한다. 플라스크에서 CSRF 토큰을 어떻게 사용하는지는 잠시 후에 알아보자.

CSRF 토큰은 쉽게 말해 CSRF를 방어하려고 플라스크에서 생성하는 무작위 문자열이다. CSRF 토큰이라는 명칭 때문에 "공격 기술에 사용하는 요소"라고 오해하지 않길 바란다.

먼저 config.py 파일을 열고 마지막 줄에 SECRET_KEY 변수를 추가하자.

[파일명: projects/myproject/config.py]

import os

BASE_DIR = os.path.dirname(__file__)

SQLALCHEMY_DATABASE_URI = 'sqlite:///{}'.format(os.path.join(BASE_DIR, 'pybo.db'))
SQLALCHEMY_TRACK_MODIFICATIONS = False
SECRET_KEY = "dev"
사실 SECRET_KEY = "dev"는 위험한 설정이다. 실제 서비스를 운영할 때에는 "dev"처럼 유추하기 쉬운 문자열을 입력하면 안 된다. 물론 현재는 개발환경이므로 괜찮다. 서비스 운영 환경에서 SECRET_KEY를 설정하는 방법은 뒤에서 자세히 알아보자.

질문 등록

이제 파이보에 질문을 등록할수 있도록 만들어 보자. 참고로 질문 등록은 이번 장 끝까지 진행해야 완벽하게 동작한다. (왜냐하면 맨 마지막에 진행하는 CSRF 설정까지 끝나야만 질문 등록이 정상동작하기 때문이다.)

질문 등록 버튼 만들기
우선 다음처럼 질문 목록 템플릿을 열고 </table> 태그 아래에 질문등록 버튼을 생성하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

(... 생략 ...)
    </table>
    <a href="{{ url_for('question.create') }}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}
질문 폼 만들기
질문 목록 화면에 질문 등록 URL을 추가했으므로 question_views.py 파일에 라우팅 함수 create를 추가해야 한다. 하지만 create 함수를 작성하기 전에 질문 등록시 사용할 QuestionForm을 먼저 만들어 보자.

QuestionForm은 질문을 등록할 때 사용할 플라스크의 폼(Form)이다.

pybo 디렉터리에 forms.py 파일을 새로 만든 다음 QuestionForm을 다음처럼 작성하자.

[파일명: projects/myproject/pybo/forms.py]

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms.validators import DataRequired

class QuestionForm(FlaskForm):
    subject = StringField('제목', validators=[DataRequired()])
    content = TextAreaField('내용', validators=[DataRequired()])
질문을 등록할 때 사용할 QuestionForm을 만들었다. QuestionForm과 같은 플라스크의 폼은 FlaskForm 클래스를 상속하여 만들어야 한다.


QuestionForm의 속성은 "제목"과 "내용"이다. 글자수의 제한이 있는 "제목"의 경우 StringField를 사용하고 글자수의 제한이 없는 "내용"은 TextAreaField를 사용한다. 플라스크에서 사용할 수 있는 폼 속성에 대한 보다 자세한 내용은 다음 URL을 참고하자.

https://wtforms.readthedocs.io/en/2.3.x/fields/#basic-fields
StringField('제목', validators=[DataRequired()]) 에서 첫번째 입력인수인 "제목"은 폼 라벨(Label)이다. 템플릿에서 이 라벨을 이용하여 "제목"이라는 라벨을 출력할 수 있다. 이 부분은 잠시후에 다시 알아보기로 하자. 두번째 입력인수는 validators이다. validators는 검증을 위해 사용되는 도구로 필수 항목인지를 체크하는 DataRequired, 이메일인지를 체크하는 Email, 길이를 체크하는 Length등이 있다. 예를들어 필수값이면서 이메일이어야 하면 validators=[DataRequired(), Email()] 과 같이 사용할 수 있다. 플라스크에서 사용할 수 있는 validators에 대한 보다 자세한 내용은 다음 URL을 참고하자.

https://wtforms.readthedocs.io/en/2.3.x/validators/#built-in-validators
질문 등록 라우팅 함수 추가하기
그리고 question_views.py 파일에 라우팅 함수 create를 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from pybo.forms import QuestionForm

(... 생략 ...)

@bp.route('/create/')
def create():
    form = QuestionForm()
    return render_template('question/question_form.html', form=form)
question_form.html 템플릿에 전달하는 QuestionForm의 객체(form)는 템플릿에서 라벨이나 입력폼 등을 만들때 필요하다.

질문 등록 템플릿 작성하기
이제 질문을 등록하는 템플릿을 만들어 보자. pybo/templates/question 디렉터리에 question_form.html 파일을 만들고 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post" class="my-3">

        {{ form.subject.label }}
        {{ form.subject() }}

        {{ form.content.label }}
        {{ form.content() }}

        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
질문 등록을 위해서는 질문의 제목과 내용이라는 입력항목이 필요하다. 위의 템플릿에서는 질문의 제목과 내용에 해당하는 입력 항목을 form 객체를 사용해서 만들었다. QuestionForm에서 작성한 두개의 필드 subject와 content가 템플릿에서 사용되었다. {{ form.subject.label }} 는 라벨을 표시하고 {{ form.subject() }}는 입력폼을 표시한다.


질문 등록 기능 사용해 보기
웹 브라우저에서 질문 등록 기능을 확인해 보자.

http://localhost:5000/question/list에 접속해 보면 질문 목록 화면에 <질문 등록하기> 버튼이 추가되었다.



여기서 <질문 등록하기> 버튼을 누르면 다음처럼 질문 등록 화면이 나타난다.



QuestonForm 객체가 자동으로 만들어 준 입력 항목(제목과 내용)이 보인다. 각 항목에 값을 입력하고 <저장하기> 버튼을 눌러 보자.

하지만 다음처럼 ‘Method NotAllowed’ 오류 화면이 나타날 것이다.



위와 같은 오류 화면이 나타난 이유는 현재 폼이 POST 방식으로 데이터를 전송하기 때문이다. 다음은 위에서 작성한 질문 등록을 위한 question_form.html 템플릿의 폼 태그이다.


<form method="post" class="my-3">
코드에서 보듯 form 태그의 method 속성이 “post”이므로 폼에 입력한 데이터는 POST 방식로 전송된다. 그런데 현재 create 라우팅 함수에는 별도의 method 속성을 지정하지 않았으므로 기본 처리 방식인 GET 방식만 처리할 수 있다. 즉, POST 방식으로 데이터를 처리하게 하려면 create 함수의 라우팅 정보를 수정해야 한다.

점프 투 플라스크
action 속성을 지정하지 않은 이유
잠깐, 다음으로 진행하기 전에 한 가지 눈여겨 보아야 할 부분이 있다. 그것은 바로 <form method="post"> 처럼 form 태그에 action 속성을 지정하지 않았다는 점이다. 보통 form 태그에는 항상 action 속성을 지정하여 submit 실행시 action에 정의된 URL로 폼을 전송해야 한다. 하지만 여기서는 특별하게 action 속성을 지정하지 않았다. form 태그에 action 속성을 지정하지 않으면 현재 페이지의 URL이 디폴트 action으로 설정된다.

물론 action 속성을 다음처럼 명확하게 지정해도 된다.

<form method="post" action="{{ url_for('question.create') }}">
하지만 이렇게 하면 action 속성을 지정하면 question_form.html 템플릿은 "질문 등록" 에서만 사용 가능하다. 이후에 진행할 "질문 수정" 에서는 이 템플릿을 활용할 수가 없다. 왜냐하면 질문 수정일 경우에는 action 값을 달리해야 하기 때문이다. 동일한 템플릿을 여러 기능에서 함께 사용할 경우에는 이처럼 form의 action 속성을 비워두는 트릭을 종종 사용한다. 우리는 이후에 "질문 수정" 기능을 구현할 때도 question_form.html 템플릿을 사용할 것이므로 action 속성은 비워두도록 하자.

form에 action을 사용하지 않는 이유에 대해서는 질문 수정시에도 다시 한번 설명한다.

질문 전송 방식 수정하기
create 함수가 GET과 POST 방식을 모두 처리할수 있도록 라우팅 애너테이션에 methods 속성을 추가하자.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    return render_template('question/question_form.html', form=form)
그런 다음 질문 등록 화면에서 <저장하기> 버튼을 다시 한번 눌러 보자. 그러면 이제 오류는 발생하지 않을 것이다. 하지만 여전히 아무런 반응 없이 질문 등록 화면만 보인다. 왜냐하면 create 함수에 데이터를 저장하는 코드를 아직 작성하지 않았기 때문이다.


이제 템플릿에서 전송한 폼 데이터를 저장하는 코드를 작성해 보자.

폼 데이터를 저장하는 코드 작성하기
create 함수에 POST 방식으로 요청된 폼 데이터를 데이터베이스에 저장하는 코드를 추가하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from datetime import datetime

from flask import Blueprint, render_template, request, url_for
from werkzeug.utils import redirect

from .. import db
from ..models import Question
from ..forms import QuestionForm

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    if request.method == 'POST' and form.validate_on_submit():
        question = Question(subject=form.subject.data, content=form.content.data, create_date=datetime.now())
        db.session.add(question)
        db.session.commit()
        return redirect(url_for('main.index'))
    return render_template('question/question_form.html', form=form)
if 문의 request.method는 create 함수로 요청된 전송 방식을 의미한다. 그리고 form.validate_on_submit 함수는 전송된 폼 데이터의 정합성을 점검한다. 즉, QuestionForm 클래스의 각 속성에 지정한 DataRequired() 같은 점검 항목에 이상이 없는지 확인한다. 즉, 위 코드에 추가한 내용은 POST 요청이고 폼 데이터에 이상이 없을 경우 질문을 저장한 뒤 main.index 페이지로 이동하라는 내용이다.

코드를 보면 폼으로부터 전달받은 "제목"에 해당하는 데이터는 form.subject.data로 얻고 있다. form.content.data도 마찬가지이다.

방금 추가한 코드의 핵심은 데이터 전송 방식이 POST인지 GET인지에 따라서 달리 처리하는 부분이다. 질문 목록에서 <질문 등록하기> 버튼을 누르거나 질문 등록 화면에서 <저장하기> 버튼을 누르면 똑같이 localhost:5000/question/create/ 페이지를 요청하므로 create 함수가 이 요청을 받는다. 다만 create 함수에서 요청 방식을 구분해서 처리한다. 즉, <질문 등록하기> 버튼을 누르는 것은 GET 방식 요청이므로 질문 등록 화면을 보여 주고, <저장하기>버튼을 누르면 POST 방식 요청이므로 데이터베이스에 질문을 저장한다.

그런데 여기까지 작성하고 <저장하기> 버튼을 눌러도 제대로 동작하지 않는다. 이 문제는 잠시 후에 해결하기로 하고 먼저 폼에 부트스트랩을 적용해 보자.

CSRF 문제를 해결해야 저장이 가능하다. 이것은 뒤에서 자세히 알아보자.

폼에 부트스트랩 적용하기

앞서 화면을 깔끔하게 만들어 주는 부트스트랩을 도입했는데, {{ form.subject() }}와 같은 코드는 폼이 HTML을 자동으로 생성하므로 부트스트랩을 적용할 수 없다. 하지만 템플릿을 조금 수정하면 부트스트랩을 어느정도 적용할 수 있다. form.subject나 form.content에 부트스트랩 클래스 class="form-control"을 적용해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
{{ form.subject.label }}
{{ form.subject(class="form-control") }}

{{ form.content.label }}
{{ form.content(class="form-control") }}
(... 생략 ...)
이와같이 수정하면 다음처럼 부트스트랩 클래스가 적용된 질문등록 화면을 볼 수 있다.



수작업으로 폼 작성하기
앞에서 {{ form.subject() }}처럼 폼을 생성하는 HTML 코드를 자동으로 생성하도록 했다. 하지만 이 방식은 폼을 빠르게 만드는 데는 도움이 되지만 내가 원하는 디자인을 적용하기가 어렵다. 이러한 단점을 보완하고자 이번에는 HTML을 직접 작성하는 방식으로 질문 등록 기능을 완성해 보자.

폼을 자동으로 만드는 코드는 디자인과 프로그램 영역이 혼재되므로 웹 디자이너와 개발자의 역할 분리도 모호해진다.

question_form.html 파일을 열고 form 엘리먼트의 내용을 다음처럼 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
(... 생략 ...)
    <form method="post" class="my-3">
        <div class="mb-3">
            <label for="subject">제목</label>
            <input type="text" class="form-control" name="subject" id="subject">
        </div>
        <div class="mb-3">
            <label for="content">내용</label>
            <textarea class="form-control" name="content" id="content" rows="10"></textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
{{ form.subject() }}와 같이 자동으로 생성되는 HTML 대신 제목과 내용에 해당되는 HTML코드를 직접 작성하였다. 이렇게 수정하면 다음과 같은 질문등록 화면을 볼 수 있다.




HTML 코드를 자동으로 생성하는 방식과 수동으로 작성하는 방식을 모두 실습했다. 어떤 방식이 옳은지 정답은 없으므로 프로젝트 성격에 적합한 방식을 골라 사용하면 된다. 다만 이 책에서는 HTML을 직접 작성하는 방식으로 화면을 구성할 것이다.

질문 등록 완성하기
앞선 실습에서 데이터를 데이터베이스에 저장하는 기능을 추가했지만, 질문 등록 화면에서 <저장하기>를 눌러도 화면에는 아무런 변화가 없었다. 이번 실습에서 그 이유를 알아보고 보완해서 질문 등록 기능을 완성해 보자.

오류 내용을 표시해 원인 알아내기
질문 등록 화면에서 <저장하기>를 눌러도 화면에 아무런 변화가 없으니 무엇이 잘못됐는지 알기 어렵다. 이러한 점을 보완하고자 오류 내용을 표시하도록 질문 등록 템플릿을 다음처럼 수정해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
    <form method="post" class="post-form my-3">
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field, errors in form.errors.items() %}
            <strong>{{ form[field].label }}</strong>
            <ul>
                {% for error in errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="form-group">
(... 생략 ...)
오류를 표시할 수 있는 영역을 위와 같이 추가했다. create함수에서 form.validate_on_submit() 코드가 실패(false 반환)하면 폼에는 오류 내용이 자동으로 등록된다. 등록된 오류는 form.errors 속성을 사용하여 위와 같이 표시할 수 있다. form.errors.items 의 field는 subject나 content와 같은 입력 폼의 필드를 의미한다.

이렇게 수정하고 질문등록화면에 아무런 값도 입력하지 않고 <저장하기> 버튼을 클릭해 보자. 아마도 다음과 같이 오류를 확인할 수 있는 화면을 볼수 있을 것이다.




제목과 내용 필드에 발생한 오류 메시지는 값을 입력하라는 뜻으로 쉽게 이해할 수 있다. 그런데 "CSRF Token" 오류는 무엇일까? 앞서 언급했듯 CSRF는 보안 관련 항목으로, form 엘리먼트를 통해 전송된 데이터가 실제 웹 사이트에서 만들어진 데이터인지 검증하는 데 필요한 CSRF 토큰이 빠졌다는 의미다.

CSRF 토큰 오류 처리하기
form 태그 바로 밑에 {{ form.csrf_token }} 코드를 삽입하여 CSRF 토큰 오류에서 탈출해 보자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

{% extends 'base.html' %}
{% block content %}
<!-- 질문 등록 -->
(... 생략 ...)
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post" class="my-3">
        {{ form.csrf_token }}
        (... 생략 ...)
    </form>
(... 생략 ...)
이제 코드를 저장하고 질문 등록 페이지의 각 필드를 채운 후 <저장하기>를 눌러 질문을 등록해 보자. 질문 목록 화면으로 이동하고 방금 등록한 질문이 보이면 성공한 것이다.



입력한 값 유지하고 오류 메시지 한글로 바꾸기
이제 질문 등록 기능이 제대로 동작한다. 그런데 질문을 등록할 때 제목은 입력하고 내용은 입력하지 않으면 오류 메시지가 나타나면서 입력한 내용(제목)이 사라진다. 그래서 다시 입력해야 하는 불편함이 있다.

이 문제를 해결해 보자.

입력한 값 유지하기

폼을 전송했을 때 오류가 있더라도 이미 입력한 값을 유지하도록 질문 폼 템플릿을 다음처럼 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_form.html]

(... 생략 ...)
        <div class="mb-3">
            <label for="subject">제목</label>
            <input type="text" class="form-control" name="subject" id="subject"
                value="{{ form.subject.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="content">내용</label>
            <textarea class="form-control" name="content"
                id="content" rows="10">{{ form.content.data or '' }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
(... 생략 ...)
subject 필드의 value값으로 {{ form.subject.data or '' }}를 입력하면 이미 전송한 데이터가 다시 설정된다. {{ form.subject.data or '' }}에서 or ''은 "현재 템플릿이 GET 방식으로 요청되는 경우 기존 입력값이 없으므로(None으로 출력) 이를 방지하기 위해서" 사용했다. 즉, 이렇게 하면 form.subject.data에 값이 없을 때 None이 아니라 ''이 출력된다. content필드에도 마찬가지 방법이 적용되었다.

이제 제목에만 값을 입력하고 <저장하기>를 눌러 보자. 그러면 내용도 입력하라는 오류가 표시되지만, 제목에 입력한 값이 더이상 사라지지 않는다.



오류 메시지 한글로 바꾸기
이번에는 필수 항목을 입력하지 않았을 때 발생하는 오류 메시지를 우리말로 바꾸어 보자. forms.py 파일을 열어 DataRequired에 한글 메시지를 설정하자.

[파일명: projects/myproject/pybo/forms.py]

from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField
from wtforms.validators import DataRequired

class QuestionForm(FlaskForm):
    subject = StringField('제목', validators=[DataRequired('제목은 필수입력 항목입니다.')])
    content = TextAreaField('내용', validators=[DataRequired('내용은 필수입력 항목입니다.')])
이제 필수 입력 항목을 빠뜨리고 질문을 등록하면 오류 메시지가 한글로 나타난다.




답변 등록에 폼 사용하기
지금까지 폼을 이용하여 질문 등록을 만들어 봤다. 이제 각 질문에 답변을 달 수 있는 기능도 폼을 사용하여 만들어 보자. 코드 설명은 대부분 질문 등록 때와 중복되므로 간단히 설명한다.

빠르게 진행해 보자.

답변 등록 폼 추가하기
답변을 등록할 때도 플라스크 폼을 사용해 보자. 먼저 답변 등록을 할 때 사용할 AnswerForm을 forms.py 파일에 추가하자.

[파일명: projects/myproject/pybo/forms.py]

(... 생략 ...)

class AnswerForm(FlaskForm):
    content = TextAreaField('내용', validators=[DataRequired('내용은 필수입력 항목입니다.')])
답변에는 content 필드만 필요하다.

답변 등록 라우팅 함수 수정하기
그리고 answer_views.py 파일에서 create 함수가 AnswerForm을 사용하도록 변경하자. 원리는 질문 등록할 때와 같다.

[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime
from flask import Blueprint, url_for, request, render_template
from werkzeug.utils import redirect

from .. import db
from ..forms import AnswerForm
from ..models import Question, Answer

bp = Blueprint('answer', __name__, url_prefix='/answer')


@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    form = AnswerForm()
    question = Question.query.get_or_404(question_id)
    if form.validate_on_submit():
        content = request.form['content']
        answer = Answer(content=content, create_date=datetime.now())
        question.answer_set.append(answer)
        db.session.commit()
        return redirect(url_for('question.detail', question_id=question_id))
    return render_template('question/question_detail.html', question=question, form=form)
답변 등록은 POST요청만 있으므로 GET, POST 분기처리는 필요없다.

CSRF 코드와 오류 표시 기능 추가하기
이어서 CSRF 토큰과 오류 표시 기능을 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        {{ form.csrf_token }}
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field, errors in form.errors.items() %}
            <strong>{{ form[field].label }}</strong>
            <ul>
                {% for error in errors %}
                <li>{{ error }}</li>
                {% endfor %}
            </ul>
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="mb-3">
            <textarea name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
(... 생략 ...)
질문 상세 템플릿에 폼이 추가되었으므로 question_views.py 파일의 detail 함수도 폼을 사용하도록 수정해야 한다. 이 과정이 없으면 템플릿에서 form 객체를 읽지 못해 오류가 난다.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
from ..forms import QuestionForm, AnswerForm
(... 생략 ...)

@bp.route('/detail/<int:question_id>/')
def detail(question_id):
    form = AnswerForm()
    question = Question.query.get_or_404(question_id)
    return render_template('question/question_detail.html', question=question, form=form)

(... 생략 ...)
이제 답변 등록 기능을 테스트해 보자. 답변을 등록해 보고 내용 없이 등록하여 오류메시지도 확인해 보자.

마지막 편집일시 : 2022년 8월 10일 3:05 오후

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-01 내비게이션바
[완성 소스] : github.com/pahkey/jump2flask/tree/3-01
[실습 영상] : https://youtu.be/gn9biT-3MQo

지금까지 만든 파이보의 기능(질문 등록·조회, 답변 등록·조회)을 사용해 봤다면 편의 기능이 없어서 이런저런 불편함을 느꼈을 것이다. 그중에서 메인 페이지로 돌아갈 수 있는 장치가 없다는 것이 가장 불편할 것이다. 
여기서는 이런 불편함을 해소하기 위해 내비게이션 바를 만들어 볼 것이다.

내비게이션 바 추가하기
질문 목록 화면에서 상단 내비게이션 바 확인하기
부트스트랩이 제공하는 햄버거 메뉴 버튼 확인하기
부트스트랩에 필요한 파일 추가하기 - 부트스트랩 자바스크립트 파일
include 기능으로 내비게이션 바 추가해 보기

내비게이션 바 추가하기
내비게이션 바는 모든 페이지에서 보여야 하므로 base.html 템플릿 파일을 열어 <body> 태그 바로 아래에 추가하자. 
내비게이션 바에는 메인 페이지로 이동해 주는 "Pybo" 로고(클래스값 navbar-brand)를 가장 왼쪽에 배치하고, 오른쪽에는 "계정생성"과 "로그인" 링크를 추가하자.

내비게이션 바는 모든 화면 위쪽에 고정되어 있는 부트스트랩 컴포넌트이다.

부트스트랩 내비게이션바 공식 문서: https://getbootstrap.com/docs/5.1/components/navbar
[파일명: projects/myproject/pybo/templates/base.html]

<!doctype html>
<html lang="ko">
<head>
    (... 생략 ...)
</head>
<body>
<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        <button class="navbar-toggler" type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="#">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
</body>
</html>
질문 목록 화면에서 상단 내비게이션 바 확인하기
이제 질문 목록 페이지를 요청하면 맨 위에 멋진 내비게이션 바가 보일 것이다. 또한 내비게이션 바의 "Pybo" 로고를 누르면 메인 페이지로 돌아갈 수 있다. "Pybo" 로고를 눌러서 잘 동작하는지 확인해 보자.

내비게이션 바는 모든 화면이 상속하는 base.html 파일에 추가된 것이므로 질문 목록, 질문 상세, 질문 등록 화면 모두에 나타날 것이다. 한번 확인해 보자.
부트스트랩이 제공하는 햄버거 메뉴 버튼 확인하기
그런데 부트스트랩 내비게이션 바에는 재미있는 기능이 하나 숨어 있다. 아무 페이지나 접속해서(여기서는 질문 목록에 접속했다) 웹 브라우저의 너비를 줄여 보자. 그러면 어느 순간 햄버거 메뉴 버튼이 생긴다. 그리고 "계정생성"과 "로그인" 링크는 사라진다.
혹시 햄버거 메뉴 버튼을 눌렀는데 아무 변화가 없더라도 당황하지 말자. 아직은 제대로 동작하지 않는 것이 정상이다.

이렇게 부트스트랩은 크기가 작은 기기를 고려한 "반응형 웹"까지 적용되어있다. 그런데 햄버거 메뉴 버튼을 클릭해도 아무런 변화가 없을 것이다. 그 이유는 부트스트랩 자바스크립트 파일(bootstrap.min.js)이 base.html 파일에 포함되지 않았기 때문이다.

부트스트랩에 필요한 파일 추가하기 - 부트스트랩 자바스크립트 파일
부트스트랩 자바스크립트 파일은 bootstrap-5.1.3-dist.zip 압축 파일에 있다. 이 파일을 찾아 다음과 같은 위치에 복사해 붙여 넣자.

부트스트랩 자바스크립트 파일 위치: bootstrap-5.1.3-dist.zip/bootstrap-5.1.3-dist/js/bootstrap.min.js
붙여 넣을 위치: projects/myproject/pybo/static/bootstrap.min.js

이제 base.html 파일을 다음과 같이 수정한 다음 햄버거메뉴 버튼을 누르면 숨어 있는 링크가 표시된다.

[파일명: projects/myproject/pybo/templates/base.html]

(... 생략 ...)
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
<!-- Bootstrap JS -->
<script src="{{ url_for('static', filename='bootstrap.min.js') }}"></script>
</body>
</html>

include 기능으로 내비게이션 바 추가해 보기
이번에는 조금 더 나은 방법으로 내비게이션 바를 템플릿에 추가해 볼 것이다. 플라스크에는 템플릿 특정 위치에 HTML을 삽입해 주는 include 기능이 있다. 이번에는 include 기능으로 내비게이션 바를 base.html 파일 템플릿에 추가해 보자.

templates/navbar.html 파일을 생성하고 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        <button class="navbar-toggler" type="button"
                data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent"
                aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="#">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
navbar.html 파일의 코드는 base.html 파일에 작성했던 내비게이션 바를 위한 HTML을 그대로 복사한 것이다. 내비게이션 바와 관련된 코드를 분리했다고 생각하면 된다.

이제 include 기능을 이용해 위에서 만든 navbar.html 파일을 base.html 파일에 삽입해 보자.

[파일명: projects/myproject/pybo/templates/base.html]

<!doctype html>
<html lang="ko">
<head>
    (... 생략 ...)
</head>
<body>
<!-- 네비게이션바 -->
{% include "navbar.html" %}
<!-- 기본 템플릿 안에 삽입될 내용 Start -->
{% block content %}
{% endblock %}
<!-- 기본 템플릿 안에 삽입될 내용 End -->
<!-- Bootstrap JS -->
<script src="{{ url_for('static', filename='bootstrap.min.js') }}"></script>
</body>
</html>
기존의 nav 엘리먼트는 모두 삭제한다.

내비게이션바가 이전과 동일하게 잘 동작할 것이다.

이렇게 include 기능은 템플릿의 특정 영역을 중복, 반복해서 사용할 경우에 유용하다. 즉, 중복, 반복하는 템플릿의 특정 영역을 따로 템플릿 파일로 만들고, include 기능으로 그 템플릿을 포함한다. 
navbar.html 파일은 base.html 파일에서 1번만 사용되지만 따로 파일로 관리해야 이후 유지·보수하는 데 유리하므로 분리했다.

마지막 편집일시 : 2022년 8월 11일 8:44 오전

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-02 게시판 페이징

[완성 소스] : github.com/pahkey/jump2flask/tree/3-02
[실습 영상] : https://youtu.be/1JiqgV0gBcw

지금까지 만든 파이보의 질문 목록은 페이징(paging) 기능이 없었다. 페이징 기능이 없으면 어떻게 될까? 만약 게시물이 300개 작성되면 질문 목록 화면에 게시물이 300개 그대로 표시될 것이다. 
이런 경우 한 화면에 표시할 게시물이 많아져서 스크롤 바를 내려야 하는 등의 불편함이 생기므로 페이징 기능은 필수다.

이번에는 페이징 기능을 추가해 보자.

임시 질문 데이터 300개 생성하기
페이징 구현하기
템플릿에 페이징 적용해 보기
질문 목록 출력 코드 수정하기
페이지 이동 기능 추가로 페이징 기능 완성하기
임시 질문 데이터 300개 생성하기
페이징을 구현하기 전에 페이징을 테스트할 정도로 데이터를 충분히 생성하자. 여기서는 테스트 데이터를 300개 생성한다. 테스트 데이터를 대량으로 만드는 가장 좋은 방법은 플라스크 셸을 이용하는 것이다.

다음처럼 플라스크 셸을 실행하자.

(myproject) c:\projects\myproject>flask shell
Python 3.8.2 (tags/v3.8.2:7b3ab59, Feb 25 2020, 22:45:29) [MSC v.1916 32 bit (Intel)] on win32
App: pybo [development]
Instance: C:\projects\myproject\instance
>>> 
이어서 질문 데이터를 생성하기 위한 모듈을 임포트하자.

>>> from pybo import db
>>> from pybo.models import Question
>>> from datetime import datetime
for 문을 이용하여 다음처럼 테스트 데이터를 300개 생성하자.

>>> for i in range(300):
...     q = Question(subject='테스트 데이터입니다:[%03d]' % i, content='내용무', create_date=datetime.now())
...     db.session.add(q)
...
>>>  quit()
>>>
db.session.commit()은 데이터를 모두 추가한 이후 마지막에 1번만 실행하면 된다.

이제 플라스크 셸을 종료하고 로컬 서버를 실행한 다음 브라우저에서 질문 목록을 보자.

플라스크 셸로 등록한 테스트 데이터가 보일 것이다. 그리고 300개 이상의 데이터가 한 페이지 보여지는 것을 확인할 수 있다. 이러한 이유로 페이징은 반드시 필요하다.





















페이징 구현하기
views/question_views.py 파일을 열어 _list 함수에 다음처럼 페이징을 적용하자. 페이징은 paginate 함수를 사용하여 쉽게 구현할 수 있다.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
@bp.route('/list/')
def _list():
    page = request.args.get('page', type=int, default=1)  # 페이지
    question_list = Question.query.order_by(Question.create_date.desc())
    question_list = question_list.paginate(page=page, per_page=10)
    return render_template('question/question_list.html', question_list=question_list)

Flask-SQLAlchemy 3.0 부터 paginate() 함수가 키워드로만 인자를 보낼 수 있도록 변경되어 question_list = question_list.paginate(page, per_page=10) 대신 question_list = question_list.paginate(page=page, per_page=10) 처럼 사용해야 한다.

_list 함수에 추가한 내용을 가볍게 살펴보자. page = request.args.get('page', type=int, default=1)는 다음과 같은 GET 방식으로 요청한 URL에서 page값을 가져올 때 사용한다. (type=int는 page 파라미터가 정수임을 의미한다.)

http://localhost:5000/question/list/?page=5
만약 다음과 같이 URL에 page값이 없으면 default=1을 적용해 기본값 1이 설정된다.

http://localhost:5000/question/list
이어서 question_list = question_list.paginate(page=page, per_page=10)는 조회한 데이터 question_list에 paginate 함수로 페이징을 적용한다. 이 함수의 1번째 인수로 전달된 page는 현재 조회할 페이지의 번호를 의미하고, 2번째 인수 per_page로 전달된 10은 페이지마다 보여 줄 게시물이 10건임을 의미한다.

만약 URL이 http://localhost:5000/question/list/?page=5와 같다면 질문 목록 5번째 페이지부터 한 페이지에 10건의 게시물을 보여 줄 것이다.

이렇게 paginate 함수를 적용하면 Pagination 객체가 리턴되어 다음과 같은 속성들을 사용할 수 있게 된다.

항목	설명	값의 예
items	현재 페이지에 해당하는 게시물 리스트	[<Question 282>,<Question 283>, ...]
total	게시물 전체 개수	302
per_page	페이지당 보여 줄 게시물 개수	10
page	현재 페이지 번호	2
iter_pages	페이지 범위	[1, 2, 3, 4, 5, None, 30, 31]
prev_num / next_num	이전 페이지 번호 / 다음 페이지 번호	현재 페이지가 3인 경우, 2 / 4
has_prev / has_next	이전 페이지 존재 여부 / 다음 페이지 존재 여부	True / False
paginate 함수를 사용하면 별다른 수고없이 위의 속성들을 사용할 수 있어 페이징 처리가 아주 쉬워진다.


템플릿에 페이징 적용해 보기
이제 Pagination 객체의 속성들을 사용하여 템플릿에서 어떻게 페이징을 처리하는지 알아보자.

질문 목록 출력 코드 수정하기
먼저 템플릿에서 사용하는 question_list가 Pagination 객체로 변경되었으므로 목록을 출력하는 부분을 다음과 같이 수정해야 한다.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        {% for question in question_list.items %}
        (... 생략 ...)
    </table>
    <a href="{{ url_for('question.create') }}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}
원래 코드인 {% for question in question_list %}를 {% for question in question_list.items %} 처럼 .items 를 추가하여 수정해 주었다. Pagination객체는 현재 조회된 목록데이터를 가져오기 위해서는 items 함수를 호출해야 한다.

이제 질문 목록 페이지에 접속하면 이제 질문 데이터 300건이 한꺼번에 표시되지 않고 페이징 기능으로 한 페이지에 10건씩 출력되는 것을 확인할 수 있다.



앞에서 설명했지만 만약 /question/list로 기본 페이지 요청을 하면 디폴트 값에 의해 첫 번째 페이지가 나타난다.

페이지 이동 기능 추가로 페이징 기능 완성하기

이번에는 페이지 이동 기능을 추가해 보자. question_list.html 템플릿의 </table> 바로 아래에 다음과 같이 코드를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

(... 생략 ...)
    </table>
    <!-- 페이징처리 시작 -->
    <ul class="pagination justify-content-center">
        <!-- 이전페이지 -->
        {% if question_list.has_prev %}
        <li class="page-item">
            <a class="page-link" href="?page={{ question_list.prev_num }}">이전</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="javascript:void(0)">이전</a>
        </li>
        {% endif %}
        <!-- 페이지번호 -->
        {% for page_num in question_list.iter_pages() %}
        {% if page_num %}
        {% if page_num != question_list.page %}
        <li class="page-item">
            <a class="page-link" href="?page={{ page_num }}">{{ page_num }}</a>
        </li>
        {% else %}
        <li class="page-item active" aria-current="page">
            <a class="page-link" href="javascript:void(0)">{{ page_num }}</a>
        </li>
        {% endif %}
        {% else %}
        <li class="disabled">
            <a class="page-link" href="javascript:void(0)">...</a>
        </li>
        {% endif %}
        {% endfor %}
        <!-- 다음페이지 -->
        {% if question_list.has_next %}
        <li class="page-item">
            <a class="page-link" href="?page={{ question_list.next_num }}">다음</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="javascript:void(0)">다음</a>
        </li>
        {% endif %}
    </ul>
    <!-- 페이징처리 끝 -->
    <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}
상당히 많은 양의 HTML코드가 추가되었지만 어렵지 않으니 찬찬히 살펴보자.

이전 페이지가 있는 경우에는 "이전" 링크가 활성화되게 하였고 이전 페이지가 없는 경우에는 "이전" 링크가 비활성화되도록 하였다. (다음페이지의 경우도 마찬가지 방법으로 적용되었다.) 그리고 페이지 리스트를 루프 돌면서 해당 페이지로 이동할 수 있는 링크를 생성하였다. 이때 현재 페이지와 같을 경우에는 active클래스를 적용하여 강조표시도 해 주었다.

위 템플릿에 사용된 주요 페이징 기능을 표로 정리해 보았다.

페이징 기능	코드
이전 페이지가 있는지 체크	{% if question_list.has_prev %}
이전 페이지 번호	{{ question_list.prev_num }}
다음 페이지가 있는지 체크	{% if question_list.has_next %}
다음 페이지 번호	{{ question_list.next_num }}
페이지 리스트 루프	{% for page_num in question_list.iter_pages() %}
현재 페이지와 같은지 체크	{% if page_num != question_list.page %}
그리고 페이지 리스트를 보기 좋게 표시하기 위해 부트스트랩의 pagination 컴포넌트를 이용하였다. 템플릿에 사용한 pagination, page-item, page-link 등이 부트스트랩 pagination 컴포넌트의 클래스이다.

부트스트랩 pagination - https://getbootstrap.com/docs/5.1/components/pagination/



축하한다! 페이징 기능이 완성되었다. 페이징은 사실 구현하기가 무척 어려운 기술이다. 플라스크의 paginate 함수가 없었다면 아마 이렇게 쉽게 해내기는 힘들었을 것이다.

점프 투 플라스크
생략 기능까지 완벽한 플라스크의 paginate 함수
위 코드를 보면 iter_pages 함수로 페이지가 나열될 때 페이지 번호(page_num)가 없는 경우 ‘...’을 표시한다. 이는 보여 줄 페이지 번호가 지나치게 많은 경우 현재 페이지 위주로 보여 주는 기술이다.

질문 제목의 숫자가 왜 뒤섞여 있나요?

앞에서 대량으로 만든 질문 데이터 제목에 대괄호와 함께 0~299 사이의 숫자를 부여했다. 혹시 페이지를 넘기면서 숫자를 확인했다면 "숫자가 마구 섞여 있는 경우"가 있다는 것을 확인했을 것이다. 이런 현상이 나타난 이유는 데이터가 아주 빠른 속도로 저장되어 같은 시간이 입력되었기 때문이다. 현재 질문 목록은 작성일시의 역순으로 정렬되므로 데이터가 생성된 시간이 같다면 뒤죽박죽으로 섞인 것처럼 보일 수 있다. 페이징 기능을 테스트하느라 게시물 데이터를 동시에 저장하느라 발생한 일이니 참고만 하고 넘어가자.

마지막 편집일시 : 2022년 10월 27일 10:25 오후
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-03 템플릿 필터 직접 만들어 보기


[완성 소스] : github.com/pahkey/jump2flask/tree/3-03
[실습 영상] : https://youtu.be/UMvEu59WDa8
이번 장에서는 템플릿 필터를 직접 만드는 방법에 대해서 알아보자. 템플릿 필터는 이미 전체 답변 개수를 구할 때 경험한 적이 있다. {{ question.answer_set|length }}와 같이 템플릿에서 사용한 객체에 파이프라인 문자 |를 붙여 필터 기능을 수행한다.

{{ question.answer_set|length }}의 length는 전체 답변 개수를 구할 때 사용한 템플릿 필터이다.

질문 목록 화면의 작성일시를 살펴보자. 작성일시의 날짯값은 datetime 객체이다. 현재 질문 목록 템플릿에서는 datetime 객체를 문자열로 표시했으므로 2020-06-15 14:03:26.769051과 같은 값으로 표시된다. 그러나 대부분의 게시판 서비스에서는 시간을 이런 식으로 표시하지 않는다.



템플릿 필터를 사용하면 이런 출력 문자열을 다듬을 수 있다.

템플릿 필터 만들기
앱에 필터 등록하기
필터 사용해 보기
질문 상세 화면에 필터 적용하기
템플릿 필터 만들기
먼저 datetime 객체를 보기 편한 문자열로 만들수 있는 템플릿 필터를 만들어보자. 다음처럼 pybo/filter.py 파일을 생성하자.

[파일명: projects/myproject/pybo/filter.py]

def format_datetime(value, fmt='%Y년 %m월 %d일 %p %I:%M'):
    return value.strftime(fmt)
filter.py 파일을 pybo디렉터리가 있는곳에 생성하고 위와 같이 format_datetime 함수를 만들었다. format_datetime 함수는 전달받은 datetime 객체(value)를 날짜포맷형식(fmt)에 맞게 변환하여 리턴하는 함수이다. 만약 fmt가 전달되지 않을 경우 디폴트 값인 '%Y년 %m월 %d일 %p %I:%M'이 사용된다.

[필터에 사용한 날짜 포맷 코드]

항목	설명
%Y	년
%m	월
%d	일
%p	AM, PM (오전, 오후의 구분)
%I	시간 (0~12 시로 표현)
%M	분
점프 투 플라스크
UnicodeEncodeError

만약 format_datetime 함수 실행시 UnicodeEncodeError 오류가 발생한다면 filter.py 파일을 다음과 같이 수정하자.

import locale
locale.setlocale(locale.LC_ALL, '')

def format_datetime(value, fmt='%Y년 %m월 %d일 %p %I:%M'):
    return value.strftime(fmt)
앱에 필터 등록하기
필터를 템플릿에서 사용하려면 pybo/__init__.py 파일의 create_app 함수를 다음처럼 수정해야 한다.

[파일명: projects/myproject/pybo/__init__.py]

(... 생략 ...)
def create_app():
   (... 생략 ...)

    # 블루프린트
    from .views import main_views, question_views, answer_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)
    app.register_blueprint(answer_views.bp)

    # 필터
    from .filter import format_datetime
    app.jinja_env.filters['datetime'] = format_datetime

    return app
format_datetime 함수를 임포트한 다음 app.jinja_env.filters['datetime']와 같이 datetime이라는 이름으로 필터를 등록해 주었다.

필터 사용해 보기
이제 필터를 사용할 차례이다. 먼저 질문 목록 템플릿에 작성한 필터를 적용해 보자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        <tr>
            <td>{{ loop.index }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date|datetime }}</td>
        </tr>
        (... 생략 ...)
    </table>
    (... 생략 ...)
</div>
{% endblock %}
{{ question.create_date|datetime }}과 같이 파이프라인 문자와 함께 datetime 필터를 적용했다. datetime 필터가 적용되었으므로 format_datetime 필터 함수가 실행된다. 이때 format_datetime의 매개변수 value에 question.create_date가 전달된다.


질문 목록 페이지로 이동해 보면 필터가 적용된 작성일시를 확인할 수 있다.



질문 상세 화면에 필터 적용하기
이어서 질문 상세 템플릿에도 같은 필터를 적용하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <!-- 질문 -->
    <h2 class="border-bottom py-2">{{ question.subject }}</h2>
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ question.create_date|datetime }}
                </div>
            </div>
        </div>
    </div>
    <!-- 답변 목록 -->
    <h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
    {% for answer in question.answer_set %}
    <div class="card my-3">
        <div class="card-body">
            <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
            <div class="d-flex justify-content-end">
                <div class="badge bg-light text-dark p-2">
                    {{ answer.create_date|datetime }}
                </div>
            </div>
        </div>
    </div>
    {% endfor %}
(... 생략 ...)
질문 생성일시인 question.create_date와 답변 생성일시인 answer.create_date에 datetime 필터를 적용했다.

질문 상세 페이지로 이동해 보면 필터가 적용된 화면을 확인할 수 있다.



여기서는 템플릿 필터를 직접 작성하고, 이 필터를 템플릿에 적용하는 방법을 알아보았다. 물론 플라스크는 이미 만들어진 템플릿 필터가 많으므로 그냥 사용해도 되지만 가끔은 나한테 필요한 필터가 없는 경우도 있다. 그런 경우에는 이 과정에 따라 필터를 직접 만들어 적용하면 된다.

플라스크 필터 공식 문서: https://jinja.palletsprojects.com/en/2.11.x/templates/#builtin-filters
마지막 편집일시 : 2022년 8월 11일 10:39 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-04 게시물에 일련번호 추가하기


[완성 소스] : github.com/pahkey/jump2flask/tree/3-04
[실습 영상] : https://youtu.be/519TCvFMaXU
게시물 번호 문제
게시물 번호 공식 만들기
게시물 번호 공식을 질문 목록 템플릿에 적용하기
게시물 번호 문제
계속해서 파이보 서비스를 개선해 보자. 현재 파이보 질문 목록 화면을 유심히 보면 페이지마다 게시물 번호가 항상 1부터 시작되는 문제가 있다. 페이지를 이리저리 이동해 봐도 게시물 번호는 1부터 시작한다. 이 문제를 해결해 보자.



두번째 페이지로 이동하더라도 여전히 게시물 번호가 1부터 시작된다.



게시물 번호 공식 만들기
만약 질문 게시물이 12개라면 1페이지에는 12번째~3번째 게시물이, 2페이지에는 2번째~1번째 게시물이 역순으로 표시되어야 한다. 질문 게시물의 번호를 역순으로 정렬하려면 다음과 같은 공식을 적용해야 한다.

번호 = 전체 게시물 개수 - (현재 페이지 - 1) * 페이지당 게시물 개수 - 나열 인덱스
항목	설명
번호	최종 표시될 게시물 번호
전체 게시물 개수	데이터베이스에 저장된 게시물 전체 개수
현재 페이지	페이징에서 현재 선택한 페이지
페이지당 게시물 개수	한 페이지당 보여줄 게시물의 개수
나열 인덱스	for 문 안의 게시물 순서
나열 인덱스는 현재 페이지에서 표시할 수 있는 게시물의 인덱스이므로 10개를 표시하는 페이지에서는 0~9, 2개를 표시하는 페이지에서는 0~1로 반복된다.

공식이 조금 복잡하니 질문 게시물이 12개인 상황을 예로 들어 설명해 보자. 현재 페이지가 1이면 현재 페이지 - 1은 0이다. 그래서 번호는 전체 게시물 개수 12에서 나열 인덱스 0~9를 뺀 12~3이 된다. 현재 페이지가 2이면 현재 페이지 - 1은 1이다. 페이지당 게시물 개수는 10이므로 12에서 10을 뺀 값 2에 나열 인덱스 0~1을 다시 빼므로 번호는 2~1이다.

게시물 번호 공식을 질문 목록 템플릿에 적용하기
이제 게시를 번호 공식을 다음처럼 질문 목록 템플릿에 적용해 보자. 다음 코드의 1번째 td 엘리먼트에 이 공식을 그대로 적용했다.


[파일명: projects/myproject/pybo/templates/question/question_list.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        <tr>
            <td>{{ question_list.total - ((question_list.page-1) * question_list.per_page) - loop.index0 }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
            </td>
            <td>{{ question.create_date|datetime }}</td>
        </tr>
        (... 생략 ...)
    </table>
    (... 생략 ...)
</div>
{% endblock %}
다음 표는 템플릿에 사용한 공식의 상세 정보이다. 코드를 따라 입력하고 이해가 잘 되지 않으면 참고하자.

항목	설명
question_list.total	전체 게시물 개수
question_list.page	현재 페이지
question_list.per_page	페이지당 게시물 개수
loop.index0	나열 인덱스(0부터 시작)
이제 게시물 번호가 우리가 의도한 대로 출력된다.



성공이다! 페이지를 이리저리 이동하며 게시물 번호를 확인해 보자.

마지막 편집일시 : 2022년 8월 11일 11:07 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-05 질문에 달린 답변 개수 표시하기


[완성 소스] : github.com/pahkey/jump2flask/tree/3-05
[실습 영상] : https://youtu.be/THrofFYl5WY
이제 질문 목록에서 "해당 질문에 달린 답변 개수"를 표시해 보자. 코드의 분량은 많지 않지만 "게시판 서비스를 더욱 서비스답게 만들어 주는 기능"이다.

답변 개수는 다음처럼 게시물 제목 바로 오른쪽에 표시하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <table class="table">
        (... 생략 ...)
        <tr>
            <td>{{ question_list.total - ((question_list.page-1) * question_list.per_page) - loop.index0 }}</td>
            <td>
                <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
                {% if question.answer_set|length > 0 %}
                <span class="text-danger small mx-2">{{ question.answer_set|length }}</span>
                {% endif %}
            </td>
            <td>{{ question.create_date|datetime }}</td>
        </tr>
        (... 생략 ...)
    </table>
    (... 생략 ...)
</div>
{% endblock %}
{% if question.answer_set|length > 0 %}로 답변이 있는 경우를 검사하고, {{ question.answer_set|length }}로 답변 개수를 표시했다.

이제 질문 목록 페이지로 이동하면 답변이 있는 질문은 제목 오른쪽에 빨간색 숫자가 표시될 것이다.



마지막 편집일시 : 2022년 8월 11일 11:20 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-06 회원가입


[완성 소스] : github.com/pahkey/jump2flask/tree/3-06
[실습 영상] : https://youtu.be/iCsHsnPoSyw
이번에는 파이보에 회원가입 기능을 구현해 보자. 회원가입을 만들어 보았다면 웹 프로그래밍은 거의 마스터했다고 할 수 있다. 그만큼 회원가입 기능은 웹 사이트에서 핵심 중의 핵심이라 할 수 있다.

회원 모델
회원가입 폼
회원가입 구현하기
블루프린트
블루프린트 등록
회원가입 템플릿
오류 표시하기
회원가입 링크
회원 데이터 확인
회원 모델
지금까지는 질문, 답변 모델만 사용했다면 이제 회원 정보를 위한 모델이 필요하다. 회원 정보 모델에는 최소한 다음과 같은 속성이 필요하다.

속성	설명
username	사용자 이름(ID)
password	비밀번호
email	이메일
pybo/models.py 파일을 열어 앞에서 정의한 속성을 바탕으로 User 모델을 작성하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
id는 자동으로 증가하는 User 모델의 기본 키이다. username, password, email에는 null값을 허용하지 않도록 nullable=False로 설정했다. 또 username, email에는 unique=True를 지정했다. unique=True는 "같은 값을 저장할 수 없다"를 뜻한다. 이렇게 해야 username과 email이 중복되어 저장되지 않는다.

User 모델을 새로 작성했으니 flask db migrate 명령으로 리비전 파일을 생성하자.

(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added table 'user'
Generating c:\projects\myproject\migrations\versions\333358e4c885_.py ...  done
이어서 flask db upgrade 명령으로 생성된 리비전 파일(예: 333358e4c885_.py)로 데이터베이스를 변경하자. 명령이 아무 문제 없이 잘 수행되는지 반드시 확인하자.

(myproject) c:\projects\myproject>flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 2cfa792a602e -> 333358e4c885, empty message
회원가입 폼
이어서 회원가입을 위한 폼을 작성하자. 다음처럼 FlaskForm을 상속하는 UserCreateForm을 만들자.

[파일명: projects/myproject/pybo/forms.py]


from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, PasswordField, EmailField
from wtforms.validators import DataRequired, Length, EqualTo, Email

(... 생략 ...)

class UserCreateForm(FlaskForm):
    username = StringField('사용자이름', validators=[DataRequired(), Length(min=3, max=25)])
    password1 = PasswordField('비밀번호', validators=[
        DataRequired(), EqualTo('password2', '비밀번호가 일치하지 않습니다')])
    password2 = PasswordField('비밀번호확인', validators=[DataRequired()])
    email = EmailField('이메일', validators=[DataRequired(), Email()])
계정생성을 위한 폼의 클래스명은 UserCreateForm이다. username은 필수항목이고 길이가 3-25 사이여야 한다는 검증조건을 설정했다. Length는 폼 유효성 검증시 문자열의 길이가 최소길이(min)와 최대길이(max) 사이에 해당하는지를 검증한다.

password1과 password2는 "비밀번호"와 "비밀번호확인"에 대한 필드이다. 로그인 할때는 비밀번호가 한번만 필요하지만 계정생성시에는 입력한 비밀번호가 정확한지 확인하기 위해 2개의 필드가 필요하다. password1과 password2 속성은 PasswordField로 생성되었다. StringField와 비슷하지만 템플릿에서 자동변환으로 사용시 <input type="password"> 태그로 변환되는 차이점이 있다. password1 속성과 password2 속성은 모두 필수값이어야 하고 두개의 값이 일치해야 하는 EqualTo 검증이 추가되었다. password1 속성에 지정된 EqualTo('password2') 는 password1과 password2의 값이 일치해야 함을 의미한다.

그리고 email 속성은 EmailField로 생성되었다. EmailField 역시 StringField와 동일하지만 템플릿 자동변환으로 사용시 <input type="email"> 태그로 변환된다. email 속성에는 필수값 검증조건에 더하여 Email() 검증조건이 추가되었다. Email() 검증조건은 해당 속성의 값이 이메일형식과 일치하는지를 검증한다.

그리고 Email() 검증을 사용하기 위해서는 다음처럼 email-validator를 설치해야 한다.

(myproject) c:\projects\myproject>pip install email_validator
Collecting email_validator
(... 생략 ...)
회원가입 구현하기
이제 계정모델과 계정폼이 준비되었으니 회원가입을 위한 블루프린트를 만들어보자. 회원가입은 메인(main_views.py), 질문(question_views.py), 답변(answer_views.py) 어디에도 해당되지 않으므로 회원가입과 로그인/로그아웃을 담당할 auth_views.py 파일을 신규로 생성하자.

블루프린트
views/auth_views.py 파일을 새로 만들어 다음처럼 코드를 작성하자.

[파일명: projects/myproject/pybo/views/auth_views.py]

from flask import Blueprint, url_for, render_template, flash, request
from werkzeug.security import generate_password_hash
from werkzeug.utils import redirect

from pybo import db
from pybo.forms import UserCreateForm
from pybo.models import User

bp = Blueprint('auth', __name__, url_prefix='/auth')


@bp.route('/signup/', methods=('GET', 'POST'))
def signup():
    form = UserCreateForm()
    if request.method == 'POST' and form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            user = User(username=form.username.data,
                        password=generate_password_hash(form.password1.data),
                        email=form.email.data)
            db.session.add(user)
            db.session.commit()
            return redirect(url_for('main.index'))
        else:
            flash('이미 존재하는 사용자입니다.')
    return render_template('auth/signup.html', form=form)
우선 /auth/로 시작하는 URL이 호출되면 auth_views.py 파일의 함수들이 호출될 수 있도록 블루프린트 객체 bp를 생성했다. 그리고 회원가입을 위한 signup 함수를 생성했다. signup 함수는 POST 방식에는 계정을 저장하고 GET 방식에는 계정 등록 화면을 출력한다.


코드를 자세히 보면 계정 등록을 할 때 username으로 데이터를 조회해서 "이미 등록된 사용자"인지를 확인한다. 만약 이미 등록된 사용자라면 flash('이미 존재하는 사용자입니다.')로 오류를 발생시킨다.

flash는 필드 자체 오류가 아닌 프로그램 논리 오류를 발생시키는 함수이다. flash로 발생시킨 오류를 템플릿에 표시하는 방법도 곧 알아볼 것이다.

그리고 비밀번호는 폼으로 전달받은 값을 그대로 저장하지 않고 generate_password_hash 함수로 암호화하여 저장했다.

generate_password_hash 함수로 암호화한 데이터는 복호화할 수 없다. 그래서 로그인할 때 입력받은 비밀번호는 암호화하여 저장된 비밀번호와 비교해야 한다.

블루프린트 등록
새로 만든 블루프린트를 사용하려면 pybo/__init__.py 파일에 등록해야 한다.

[파일명: projects/myproject/pybo/__init__.py]

(... 생략 ...)

def create_app():
    (... 생략 ...)

    # 블루프린트
    from .views import main_views, question_views, answer_views, auth_views
    app.register_blueprint(main_views.bp)
    app.register_blueprint(question_views.bp)
    app.register_blueprint(answer_views.bp)
    app.register_blueprint(auth_views.bp)

    (... 생략 ...)

    return app
회원가입 템플릿
이어서 회원가입 템플릿을 작성하자. signup.html 파일은 templates 디렉터리 아래에 auth 디렉터리를 추가한 후 다음처럼 작성하자.

[파일명: projects/myproject/pybo/templates/auth/signup.html]


{% extends "base.html" %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">계정생성</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password1">비밀번호</label>
            <input type="password" class="form-control" name="password1" id="password1"
                   value="{{ form.password1.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password2">비밀번호 확인</label>
            <input type="password" class="form-control" name="password2" id="password2"
                   value="{{ form.password2.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="email">이메일</label>
            <input type="text" class="form-control" name="email" id="email"
                   value="{{ form.email.data or '' }}">
        </div>
        <button type="submit" class="btn btn-primary">생성하기</button>
    </form>
</div>
{% endblock %}
회원가입을 위한 "사용자 이름", "비밀번호", "비밀번호 확인", "이메일"에 해당되는 input 엘리먼트를 추가했다. <생성하기> 버튼을 누르면 폼 데이터가 POST 방식으로 /auth/signup/ URL로 요청된다.

form 태그에 action 속성이 지정되지 않은 경우에는 현재의 URL, 즉, 브라우저에 현재 표시된 URL로 폼이 전송된다. 따라서 현재 브라우저에 표시되는 URL은 /auth/signup/ 이므로 버튼을 누르면 POST 방식으로 /auth/signup/ 이 호출된다.

그리고 회원가입을 할 때 발생할 수 있는 오류를 표시하도록 {% include "form_errors.html" %}를 사용했다.

오류 표시하기
form_errors.html 템플릿 파일은 다음과 같이 "필드에서 발생한 오류를 표시하는 부분"과 "flash를 거치면서 발생한 오류를 표시하는 부분"으로 구성된다. 필드 오류는 폼 validators 검증에 실패한 경우 표시되고, flash 오류는 flash('이미 존재하는 사용자입니다.')와 같은 로직에 의해 표시된다.

[파일명: projects/myproject/pybo/templates/form_errors.html]

<!-- 필드오류 -->
{% if form.errors %}
<div class="alert alert-danger" role="alert">
    {% for field, errors in form.errors.items() %}
    <strong>{{ form[field].label }}</strong>
    <ul>
        {% for error in errors %}
        <li>{{ error }}</li>
        {% endfor %}
    </ul>
    {% endfor %}
</div>
{% endif %}
<!-- flash 오류 -->
{% for message in get_flashed_messages() %}
<div class="alert alert-danger" role="alert">
    {{ message }}
</div>
{% endfor %}
회원가입 링크
이제 회원가입 화면으로 이동할 수 있는 링크를 내비게이션 바에 추가하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        (... 생략 ...)
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.signup') }}">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="#">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
이제 내비게이션 바의 ‘계정생성’ 링크를 누르면 다음과 같은 회원가입 화면이 나온다.




입력값 중에서 "비밀번호"와 "비밀번호 확인"을 서로 다르게 입력하고 <생성하기>를 누르면 validator 오류가 발생하여 화면에 다음과 같은 오류 메시지가 나타날 것이다.



이처럼 우리가 만든 회원가입 기능에는 필숫값 검증, 이메일 규칙 검증 등이 적용되어 있다. 올바른 입력값으로 회원가입을 완료하면 메인 페이지로 리다이렉트될 것이다.

회원 데이터 확인
플라스크 셸에서 회원가입을 통해 생성된 계정 정보를 확인해 보자.

(myproject) c:\projects\myproject>flask shell
>>> from pybo.models import User
>>> User.query.all()
[<User 1>]
>>> User.query.first().username
'pahkey'
축하한다. 이제 파이보에 회원가입 기능이 추가되었다.

마지막 편집일시 : 2022년 8월 14일 11:25 오후
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-07 로그인과 로그아웃


[완성 소스] : github.com/pahkey/jump2flask/tree/3-07
[실습 영상] : https://youtu.be/QwMW-wt7CK8
파이보는 여러 사람이 사용하는 게시판 서비스다. 그러므로 로그인, 로그아웃은 필수 기능이다.

로그인 정보가 있어야 질문한 사람, 답변한 사람이 누구인지 알수 있다.

로그인
로그인 폼
로그인 라우팅 함수
로그인 템플릿
로그인 링크
로그아웃
로그인 여부 확인
로그인 로그아웃 표시하기
로그아웃 라우팅 함수
로그아웃 링크
로그인
로그인 폼
다음과 같이 로그인시 사용할 UserLoginForm을 만들자.

[파일명: projects/myproject/pybo/forms.py]

(... 생략 ...)

class UserLoginForm(FlaskForm):
    username = StringField('사용자이름', validators=[DataRequired(), Length(min=3, max=25)])
    password = PasswordField('비밀번호', validators=[DataRequired()])
username, password 필드를 추가하고 각각 필수 입력 항목으로 지정해 주었다. 또한 username의 길이는 3~25자로 제한했다.

로그인 라우팅 함수
그리고 로그인을 수행할 라우팅 함수를 다음처럼 작성하자.

[파일명: projects/myproject/pybo/views/auth_views.py]

from flask import Blueprint, url_for, render_template, flash, request, session
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import redirect

from pybo import db
from pybo.forms import UserCreateForm, UserLoginForm

(... 생략 ...)

@bp.route('/login/', methods=('GET', 'POST'))
def login():
    form = UserLoginForm()
    if request.method == 'POST' and form.validate_on_submit():
        error = None
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            error = "존재하지 않는 사용자입니다."
        elif not check_password_hash(user.password, form.password.data):
            error = "비밀번호가 올바르지 않습니다."
        if error is None:
            session.clear()
            session['user_id'] = user.id
            return redirect(url_for('main.index'))
        flash(error)
    return render_template('auth/login.html', form=form)
/login/ URL과 매핑되는 login 함수를 생성했다. login 함수는 signup 함수와 비슷하게 동작한다. POST 방식에는 로그인을 수행하고, GET 요청에는 로그인 화면을 보여준다.


POST 요청에 의해 로그인 하는 과정을 알아보자. 우선 폼 입력으로 받은 username으로 데이터베이스에 해당 사용자가 있는지를 검사한다. 만약 사용자가 없으면 "존재하지 않는 사용자입니다."라는 오류를 발생시킨다. 사용자가 존재한다면 폼 입력으로 받은 password와 check_password_hash 함수를 사용하여 데이터베이스의 비밀번호와 일치하는지를 비교한다.

데이터베이스에 저장된 비밀번호는 암호화되었으므로 입력된 비밀번호와 바로 비교할 수 없다. 입력 비밀번호는 반드시 check_password_hash 함수로 암호화한 후 데이터베이스의 값과 비교해야 한다.

사용자도 존재하고 비밀번호도 일치한다면 플라스크 세션(session)에 사용자 정보를 저장한다. 세션 키에 'user_id'라는 문자열을 저장하고 키에 해당하는 값은 데이터베이스에서 조회한 사용자의 id 값을 저장했다.

세션에 대해 잠시 생각해 보자. session은 request와 마찬가지로 플라스크가 자체적으로 생성하여 제공하는 객체이다. 브라우저가 플라스크 서버에 요청을 보내면 request 객체는 요청할 때마다 새로운 객체가 생성된다. 하지만 session은 request와 달리 한번 생성하면 그 값을 계속 유지하는 특징이 있다.

세션은 서버에 브라우저별로 생성되는 메모리 공간이라고 할수 있다.

따라서 세션에 사용자의 id 값을 저장하면 다양한 URL 요청에 이 세션에 저장된 값을 읽을 수 있다. 예를 들어 세션 정보를 확인하여 현재 요청한 주체가 로그인한 사용자인지 아닌지를 판별할 수 있다

점프 투 플라스크
쿠키와 세션 이해하기
웹 프로그램은 [웹 브라우저 요청 → 서버 응답] 순서로 실행되며, 서버 응답이 완료되면 웹 브라우저와 서버 사이의 네트워크 연결은 끊어진다. 하지만 수 많은 브라우저가 서버에 요청할 때마다 매번 새로운 세션이 생성되는 것이 아니라 동일한 브라우저의 요청에서 서버는 동일한 세션을 사용한다.

그렇다면 서버는 도대체 어떻게 웹 브라우저와 연결 고리(세션)를 맺는걸까?

그 해답은 쿠키(Cookie)에 있다. 쿠키는 서버가 웹 브라우저에 발행하는 값이다. 웹 브라우저가 서버에 어떤 요청을 하면 서버는 쿠키를 생성하여 전송하는 방식으로 응답한다. 그러면 웹 브라우저는 서버에서 받은 쿠키를 저장한다. 이후 서버에 다시 요청을 보낼 때는 저장한 쿠키를 HTTP 헤더에 담아서 전송한다. 그러면 서버는 웹 브라우저가 보낸 쿠키를 이전에 발행했던 쿠키값과 비교하여 같은 웹 브라우저에서 요청한 것인지 아닌지를 구분할 수 있다. 이때 세션은 바로 쿠키 1개당 생성되는 서버의 메모리 공간이라고 할 수 있다.


로그인 템플릿
이어서 로그인 템플릿을 만들자. 로그인 폼에서 생성한 필드 2개(username, password)를 input 엘리먼트로 만들자.

[파일명: projects/myproject/pybo/templates/auth/login.html]

{% extends "base.html" %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">로그인</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자 이름</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.data or '' }}">
        </div>
        <div class="mb-3">
            <label for="password">비밀번호</label>
            <input type="password" class="form-control" name="password" id="password"
                   value="{{ form.password.data or '' }}">
        </div>
        <button type="submit" class="btn btn-primary">로그인</button>
    </form>
</div>
{% endblock %}
템플릿에서 <로그인> 버튼을 누르면 form 엘리먼트가 POST 방식으로 현재 웹 브라우저의 주소 창에 표시된 URL인 /auth/login/로 요청될 것이다.

로그인 링크
이제 로그인할 수 있는 모든 준비를 마쳤으므로 내비게이션 바에 로그인 링크를 추가하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        (... 생략 ...)
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            (... 생략 ...)
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.signup') }}">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.login') }}">로그인</a>
                </li>
            </ul>
        </div>
    </div>
</nav>
내비게이션 바의 "로그인" 링크를 누르면 /auth/login으로 이동하며, 다음과 같은 로그인 화면이 나타난다.



만약 데이터베이스에 없는 username 또는 password를 입력하면 다음처럼 오류 메시지가 나타난다.




username과 password를 제대로 입력하면 로그인을 수행한 다음 메인 화면으로 이동한다.

로그인에 성공했다. 축하한다!

로그아웃
하지만 로그인한 후에도 내비게이션 바에는 여전히 "로그인" 링크가 남아 있다. 이 링크는 "로그아웃" 링크로 바뀌어야 한다.

반대로 로그아웃 상태에서는 "로그인" 링크로 바뀌어야 한다.

사용자의 로그인 여부는 "session에 저장된 값을 조사"하면 알 수 있다. 단순히 session에 저장된 user_id값 여부로 로그인을 확인할 수도 있지만 여기서는 좀 더 일반적으로 사용할 수 있는 방법에 대해서 알아보자.

로그인 여부 확인
우선 로그인한 사용자 정보를 조회하여 사용할 수 있도록 auth_views.py파일에 load_logged_in_user 함수를 다음처럼 구현해 보자.

[파일명: projects/myproject/pybo/views/auth_views.py]


from flask import Blueprint, url_for, render_template, flash, request, session, g
from werkzeug.security import generate_password_hash, check_password_hash
from werkzeug.utils import redirect

(... 생략 ...)

@bp.before_app_request
def load_logged_in_user():
    user_id = session.get('user_id')
    if user_id is None:
        g.user = None
    else:
        g.user = User.query.get(user_id)
여기서는 @bp.before_app_request 애너테이션을 사용했다. 이 애너테이션이 적용된 함수는 라우팅 함수보다 항상 먼저 실행된다. 즉, 앞으로 load_logged_in_user 함수는 모든 라우팅 함수보다 먼저 실행될 것이다.

@bp.before_app_request를 적용한 함수는 auth_views.py의 라우팅 함수 뿐만 아니라 모든 라우팅 함수보다 항상 먼저 실행된다.

load_logged_in_user 함수에서 사용한 g는 플라스크의 컨텍스트 변수이다. 이 변수는 request 변수와 마찬가지로 [요청 → 응답] 과정에서 유효하다. 코드에서 보듯 session 변수에 user_id값이 있으면 데이터베이스에서 사용자 정보를 조회하여 g.user에 저장한다. 이렇게 하면 이후 사용자 로그인 검사를 할 때 session을 조사할 필요가 없다. g.user에 값이 있는지만 확인하면 된다. g.user에는 User 객체가 저장되어 있으므로 여러 가지 사용자 정보(username, email 등)를 추가로 얻어내는 이점이 있다.

g.user에는 User 객체가 저장된다.

로그인 로그아웃 표시하기
이제 내비게이션 바를 다음과 같이 수정하자. {% if g.user %} 코드를 추가하여 사용자의 로그인 유무를 판별할 것이다.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    <div class="container-fluid">
        <a class="navbar-brand" href="{{ url_for('main.index') }}">Pybo</a>
        (... 생략 ...)
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            {% if g.user %}
            <ul class="navbar-nav">
                <li class="nav-item ">
                    <a class="nav-link" href="#">{{ g.user.username }} (로그아웃)</a>
                </li>
            </ul>
            {% else %}
            <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.signup') }}">계정생성</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="{{ url_for('auth.login') }}">로그인</a>
                </li>
            </ul>
            {% endif %}
        </div>
    </div>
</nav>
"로그아웃" 링크는 곧 구현할 것이므로 여기서는 우선 href 속성값을 ‘#’ 로 해두자.

g.user는 앞 단계에서 구현한 load_logged_in_user 함수로 생성한 사용자 정보값이다. 로그인 했다면 g.user가 만들어진 상태이므로 username을 표시하고 "로그아웃" 링크를 보여 줄 것이다. 반대로 로그인을 하지 않았다면 "로그인"과 "계정생성" 링크를 보여 줄 것이다.




로그아웃 라우팅 함수
그리고 로그아웃을 구현하기 위해 auth_views.py 파일을 열어 /logout/ URL에 매핑되는 logout 함수를 다음과 같이 작성하자.

[파일명: projects/myproject/pybo/views/auth_views.py]

(... 생략 ...)

@bp.route('/logout/')
def logout():
    session.clear()
    return redirect(url_for('main.index'))
logout 함수에는 세션의 모든 값을 삭제할 수 있도록 session.clear()를 추가했다. 따라서 session에 저장된 user_id는 삭제될 것이며, 앞서 작성한 load_logged_in_user 함수에서 session의 값을 읽을 수 없으므로 g.user도 None이 될 것이다.

로그아웃 링크
"로그아웃" 링크가 활성화될 수 있도록 내비게이션바를 수정하자.

[파일명: projects/myproject/pybo/templates/navbar.html]

<!-- 네비게이션바 -->
<nav class="navbar navbar-expand-lg navbar-light bg-light border-bottom">
    (... 생략 ...)
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        {% if g.user %}
        <ul class="navbar-nav">
            <li class="nav-item ">
                <a class="nav-link" href="{{ url_for('auth.logout') }}">{{ g.user.username }} (로그아웃)</a>
            </li>
        </ul>
        {% else %}
        (... 생략 ...)
    </div>
</nav>
이제 로그인, 로그아웃 기능이 잘 실행되는지 확인해 보자.

로그아웃을 누르면 네비게이션 바에는 다시 계정생성, 로그인 링크가 나타날 것이다.

마지막 편집일시 : 2022년 8월 14일 10:59 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-08 모델 수정하기


[완성 소스] : github.com/pahkey/jump2flask/tree/3-08
[실습 영상] : https://youtu.be/6qsz0ACb4rs
회원가입, 로그인, 로그아웃 기능이 완성되어 질문, 답변을 "누가" 작성했는지 알 수 있게 되었다. 이제 기능을 조금씩 다듬어서 파이보를 완벽하게 만들어 보자. 여기서는 Question, Answer 모델을 수정하여 "글쓴이"에 해당하는 user 속성을 추가할 것이다.

SQLite 설정 수정하기
Question 모델에 글쓴이 추가하기
리비전 파일 생성하기
리비전 파일 적용하기
flask db upgrade 명령 오류 해결하기
nullable=True
리비전 오류 확인하기
최종 리비전
현재 리비전
현재 리비전을 최종 리비전으로 변경하기
migrate, upgrade 다시 수행하기
nullable=False
Answer 모델에 글쓴이 추가하기
질문, 답변 등록시 글쓴이 저장하기
답변 등록
질문 등록
login_required
@login_required 데코레이터
@login_required 적용하기
로그아웃 상태에서 답변 등록 불가능하게 만들기
SQLite 설정 수정하기
SQLite 데이터베이스는 ORM을 사용할 때 몇 가지 문제점이 있다. 이것은 SQLite 데이터베이스에만 해당하고 PostgreSQL이나 MySQL 등의 다른 데이터베이스와는 상관없는 내용이다. 앞으로의 진행을 원활하게 하기 위해 SQLite가 발생시킬 수 있는 오류를 먼저 해결하고 넘어가자.

pybo/__init__.py 파일을 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/__init__.py]

from flask import Flask
from flask_migrate import Migrate
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy import MetaData

import config

naming_convention = {
    "ix": 'ix_%(column_0_label)s',
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(column_0_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}
db = SQLAlchemy(metadata=MetaData(naming_convention=naming_convention))
migrate = Migrate()

def create_app():
    app = Flask(__name__)
    app.config.from_object(config)

    # ORM
    db.init_app(app)
    if app.config['SQLALCHEMY_DATABASE_URI'].startswith("sqlite"):
        migrate.init_app(app, db, render_as_batch=True)
    else:
        migrate.init_app(app, db)
    from . import models
    (... 생략 ...)
이와 같이 수정하면 데이터베이스의 프라이머리 키, 유니크 키, 인덱스 키 등의 이름이 변경되므로 flask db migrate 명령과 flask db upgrade 명령으로 데이터베이스를 변경해야 한다.

데이터베이스에서 디폴트 값으로 명명되던 프라이머리 키, 유니크 키 등의 제약조건 이름을 수동으로 설정한 것이다.

(myproject) c:\projects\myproject>flask db migrate
(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
점프 투 플라스크
SQLite 버그패치
SQLite 데이터베이스에서 사용하는 인덱스 등의 제약 조건 이름은 MetaData 클래스를 사용하여 규칙을 정의해야 한다. 만약 이름을 정의하지 않으면 SQLite 데이터베이스는 다음과 같은 제약 조건에 이름이 없다는 오류를 발생시킨다.

ValueError: Constraint must have a name
또 SQLite 데이터베이스는 migrate.init_app(app, db, render_as_batch=True)처럼 render_as_batch 속성을 True로 지정해야 한다. 만약 이 속성이 False라면 다음과 같은 오류가 발생한다.

ERROR [root] Error: No support for ALTER of constraints in SQLite dialectPlease refer to the batch mode feature which allows for SQLite migrations using a copy-and-move strategy.
pybo/__init__.py 파일에서 수정한 내용은 SQLite 데이터베이스를 플라스크 ORM에서 정상으로 사용하기 위한 것이라고 이해하면 된다.


Question 모델에 글쓴이 추가하기
다음과 같이 글쓴이 정보를 Question 모델에 추가하기 위해 user_id, user 속성을 추가하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    user = db.relationship('User', backref=db.backref('question_set'))
(... 생략 ...)
user_id 속성은 User 모델을 Question 모델과 연결하기 위한 속성이고 user 속성은 Question 모델에서 User 모델을 참조하기 위한 속성이다. db.ForeignKey와 db.relationship은 질문과 답변 모델을 연결하는 부분에서 다루었으므로 자세한 설명은 생략한다.

리비전 파일 생성하기
모델을 수정했으므로 flask db migrate 명령을 실행해서 리비전 파일을 생성하자.

(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'question.user_id'
INFO  [alembic.autogenerate.compare] Detected added foreign key (user_id)(id) on table question
Generating c:\projects\myproject\migrations\versions\4c3f98cdbcab_.py ...  done
리비전 파일 적용하기
이어서 flask db upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 8f2a98320302 -> 4c3f98cdbcab, empty message
Traceback (most recent call last):
  ...
sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: _alembic_tmp_question.user_id
[SQL: INSERT INTO _alembic_tmp_question (id, subject, content, create_date) SELECT question.id, question.subject, question.content, question.create_date
FROM question]
(Background on this error at: http://sqlalche.me/e/gkpj)
그런데 오류가 발생했다. 그 이유는 "user_id 속성이 Null을 허용하지 않기 때문"이다. (모델에서 user_id 속성을 만들 때 nullable 설정을 False로 지정했다.) 앞서 실습을 진행하며 데이터베이스에 Question 모델 데이터를 여러 건 저장했던 것이 기억나는가? 그 데이터에는 user_id 속성의 값이 없다. 그런데 변경된 모델은 이를 허용하지 않으므로 오류가 발생한 것이다. 즉, 기존에 이미 저장되어 있던 데이터들 때문에 발생한 오류이다.

flask db upgrade 명령 오류 해결하기

이 문제를 해결하려면 다음과 같은 과정을 거쳐야 한다. 이런 과정은 어떤 모델에 nullable=Flase 인 속성을 추가하고자 할 때 어쩔수 없이 거져야 하는 과정이다.

다음 순서대로 따라 해보자.

user_id의 nullable 설정을 False 대신 True로 바꾸기
user_id를 임의의 값으로 설정하기(여기서는 1로 설정)
flask db migrate 명령, flask db upgrade 명령 다시 실행하기
user_id의 nullable 설정을 다시 False로 변경하기
flask db migrate 명령, flask db upgrade 명령 다시 실행하기
nullable=True
우선 user_id 속성의 nullable=False를 nullable=True로 변경하자. 그리고 user_id 속성의 기본값을 1로 설정하기 위해 server_default='1'을 입력하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=True, server_default='1')
    user = db.relationship('User', backref=db.backref('question_set'))
(... 생략 ...)
여기서 server_default에 지정한 '1'은 최초로 생성한 User 모델 데이터의 id 값을 의미한다. 기존에 저장된 Question 데이터의 user_id값을 설정하기 위해서 server_default='1'이라는 속성을 추가했다.

점프 투 플라스크
server_default와 default의 차이
컬럼 속성의 default 값은 default와 server_default를 사용해서 설정할수 있다. 그런데 server_default와 default에는 어떤 차이가 있을까? server_default를 사용하면 flask db upgrade 명령을 수행할 때 해당 속성을 갖고 있지 않던 기존 데이터에도 기본값이 저장된다. 하지만 default는 새로 생성되는 데이터에만 기본값을 생성해 준다. 따라서 현재처럼 "없던 속성을 만들어야 하는 상황"에서는 default 대신 server_default를 사용해야 한다.

리비전 오류 확인하기
이제 다시 flask db migrate 명령을 수행해 보자.


(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
ERROR [root] Error: Target database is not up to date.
하지면 여전히 오류가 발생한다. 왜냐하면 이전의 migrate 명령은 제대로 수행되었지만 upgrade를 실패하여 정상으로 종료되지 않았기 때문이다. 이 문제를 해결해 보자.

최종 리비전
우선 flask db heads 명령으로 현재 migrate 작업의 최종 리비전을 확인해 보자.

(myproject) c:\projects\myproject>flask db heads
4c3f98cdbcab (head)
현재 리비전
그런 다음 flask db current 명령으로 현재 시점의 리비전을 확인해 보자.

(myproject) c:\projects\myproject>flask db current
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
8f2a98320302
결과를 보면 알겠지만 "현재 시점의 리비전"과 "최종 리비전"이 같지 않다. 2개의 리비전이 다른 이유는 migrate 이후 upgrade를 실패했기 때문이다. 이 때문에 migrate 명령을 수행할 수 없는 것이다. 이 둘이 일치해야 migrate 작업을 진행할 수 있다.

현재 리비전을 최종 리비전으로 변경하기
앞에서 설명했듯 migrate 작업을 계속 진행하려면 flask db stamp heads 명령을 사용하여 현재 리비전을 최종 리비전으로 되돌려야 한다.

(myproject) c:\projects\myproject>flask db stamp heads
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running stamp_revision 8f2a98320302 -> 4c3f98cdbcab
리비전을 변경한 뒤 다시 flask db current 명령을 수행하자.

(myproject) c:\projects\myproject>flask db current
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
4c3f98cdbcab (head)
현재(current) 리비전이 최종(head) 리비전으로 되돌려진 것을 확인할 수 있다.


즉, 이 작업은 마지막에 수행했던 flask db migrate 작업을 취소한 것이다.

migrate, upgrade 다시 수행하기
다시 flask db migrate 명령과 flask db upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.autogenerate.compare] Detected added column 'question.user_id'
INFO  [alembic.autogenerate.compare] Detected added foreign key (user_id)(id) on table question
Generating c:\projects\myproject\migrations\versions\d4b2f566b87c_.py ...  done

(myproject) c:\projects\myproject>flask db upgrade
INFO  [alembic.runtime.migration] Context impl SQLiteImpl.
INFO  [alembic.runtime.migration] Will assume non-transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade 4c3f98cdbcab -> d4b2f566b87c, empty message
오류 없이 잘 수행된다. 이제 데이터베이스에는 Question 모델 데이터 모두 user_id 속성에 '1'이 저장된다.

nullable=False
이제 비로소 Question 모델의 user_id 속성을 nullable=True에서 nullable=False로 변경할수 있다. 그리고 server_default는 필요하지 않으므로 제거하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Question(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    subject = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    user = db.relationship('User', backref=db.backref('question_set'))
(... 생략 ...)
코드를 수정한 뒤 flask db migrate, flask db upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected NOT NULL on column 'question.user_id'
Generating c:\projects\myproject\migrations\versions\ce4336d5bbb6_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade d4b2f566b87c -> ce4336d5bbb6, empty message
지금까지 이미 데이터베이스에 저장된 데이터와 이와 관련된 모델이 변경되었을 때 처리하는 방법을 알아보았다. 여기서는 모델 속성에 nullable=False를 설정하는 방법을 알아보았다. migrate 명령을 사용하다 보면 뭔가 꼬이는 현상이 종종 발생한다. 이럴 때는 현재 데이터베이스의 변경 내역을 세심히 살펴보아야 한다.

Answer 모델에 글쓴이 추가하기

Answer 모델도 같은 방법으로 user_id 속성을 추가하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Answer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
    question = db.relationship('Question', backref=db.backref('answer_set'))
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=True, server_default='1')
    user = db.relationship('User', backref=db.backref('answer_set'))
(... 생략 ...)
user_id 속성에 nullable=True를 설정했다. 실습하면서 nullable=False 지정은 고생길이라는 것을 훤히 알았을 것이므로 nullable=True, server_default='1'이라고 설정하여 기본값을 저장한 다음에 진행하자.

다음처럼 migrate 명령과 upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected added column 'answer.user_id'
INFO [alembic.autogenerate.compare] Detected added foreign key (user_id)(id) on table answer
Generating c:\projects\myproject\migrations\versions\f1503ea99f7c_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade ce4336d5bbb6 -> f1503ea99f7c,empty message
Answer 모델에서 server_default는 제거하고 nullable=False로 변경하자.

[파일명: projects/myproject/pybo/models.py]

(... 생략 ...)
class Answer(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question_id = db.Column(db.Integer, db.ForeignKey('question.id', ondelete='CASCADE'))
    question = db.relationship('Question', backref=db.backref('answer_set'))
    content = db.Column(db.Text(), nullable=False)
    create_date = db.Column(db.DateTime(), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id', ondelete='CASCADE'), nullable=False)
    user = db.relationship('User', backref=db.backref('answer_set'))
(... 생략 ...)
이어서 migrate, upgrade 명령을 순서대로 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected NOT NULL on column 'answer.user_id'
Generating c:\projects\myproject\migrations\versions\0fbf53a8e0af_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade f1503ea99f7c -> 0fbf53a8e0af, empty message
오류없이 잘 처리될 것이다.

질문, 답변 등록시 글쓴이 저장하기
Question, Answer 모델에 글쓴이 속성을 추가했으므로 질문과 답변을 등록할 때 글쓴이 정보를 저장할 수 있다.


답변 등록
먼저 답변 등록시 글쓴이를 저장하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

from datetime import datetime
from flask import Blueprint, url_for, request, render_template, g
from werkzeug.utils import redirect
(... 생략 ...)

@bp.route('/create/<int:question_id>', methods=('POST',))
def create(question_id):
    form = AnswerForm()
    question = Question.query.get_or_404(question_id)
    if form.validate_on_submit():
        content = request.form['content']
        answer = Answer(content=content, create_date=datetime.now(), user=g.user)
        question.answer_set.append(answer)
        db.session.commit()
        return redirect(url_for('question.detail', question_id=question_id))
    return render_template('question/question_detail.html', question=question, form=form)
g.user는 세션에 저장된 사용자 정보 데이터이다.

g.user는 auth_views.py 파일의 @bp.before_app_request 애너테이션에 의해 생성된다.

질문 등록
질문 등록도 마찬가지 방법으로 수정하자.

[파일명: projects/myproject/pybo/views/question_views.py]

from datetime import datetime
from flask import Blueprint, render_template, request, url_for, g
from werkzeug.utils import redirect
(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
def create():
    form = QuestionForm()
    if request.method == 'POST' and form.validate_on_submit():
        question = Question(subject=form.subject.data, content=form.content.data,
                            create_date=datetime.now(), user=g.user)
        db.session.add(question)
        db.session.commit()
        return redirect(url_for('main.index'))
    return render_template('question/question_form.html', form=form)
이제 로그인 후에 질문과 답변을 등록해 보자. 문제 없이 잘 등록될 것이다.

login_required

그런데 로그아웃 상태에서 질문 또는 답변을 등록하면 다음과 같은 오류가 발생한다.

sqlalchemy.exc.IntegrityError
sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: question.user_id
[SQL: INSERT INTO question (subject, content, create_date, user_id) VALUES (?, ?, ?, ?)]
(... 생략 ...)
오류가 발생한 이유는 로그아웃 상태에서는 g.user의 값이 None이기 때문이다. 이 문제를 해결하려면 로그아웃 상태에서는 질문 또는 답변을 작성하려고 할 때 로그인을 먼저 진행할 수 있도록 로그인 페이지로 리다이렉트해야 한다. 그렇게 하려면 모든 질문, 답변 등록 함수의 시작 부분에 세션 값을 체크하여 사용자 정보가 없을 경우 로그인 페이지로 리다이렉트하는 코드를 추가해야 한다. 하지만 이런식으로 코드를 작성하면 코드가 중복되므로 무척 비효율적이다.

그러면 어떻게 해야 할까?

@login_required 데코레이터
auth_views.py 파일에 login_required라는 이름의 데코레이터 함수를 다음과 같이 만들어 보자.

[파일명: projects/myproject/pybo/views/auth_views.py]

import functools

(... 생략 ...)

def login_required(view):
    @functools.wraps(view)
    def wrapped_view(*args, **kwargs):
        if g.user is None:
            _next = request.url if request.method == 'GET' else ''
            return redirect(url_for('auth.login', next=_next))
        return view(*args, **kwargs)
    return wrapped_view
코드에서 보듯 데코레이터 함수는 기존 함수를 감싸는 방법으로 간단히 만들 수 있다. 이제 라우팅 함수에 @login_required 애너테이션을 지정하면 login_required 데코레이터 함수가 먼저 실행될 것이다. login_required 함수는 g.user가 있는지를 조사하여 없으면 로그인 URL로 리다이렉트 하고 g.user가 있으면 원래 함수를 그대로 실행할 것이다.

요청 방식이 GET인 경우에는 로그인 후에 원래 가려던 페이지로 다시 찾아갈수 있도록 로그인 페이지에 next 파라미터를 전달했다. 따라서 로그인 함수도 next 파라미터를 처리하기 위해 다음과 같이 수정해야 한다.

[파일명: projects/myproject/pybo/views/auth_views.py]

(... 생략 ...)
@bp.route('/login/', methods=('GET', 'POST'))
def login():
    form = UserLoginForm()
    if request.method == 'POST' and form.validate_on_submit():
        error = None
        user = User.query.filter_by(username=form.username.data).first()
        if not user:
            error = "존재하지 않는 사용자입니다."
        elif not check_password_hash(user.password, form.password.data):
            error = "비밀번호가 올바르지 않습니다."
        if error is None:
            session.clear()
            session['user_id'] = user.id
            _next = request.args.get('next', '')
            if _next:
                return redirect(_next)
            else:
                return redirect(url_for('main.index'))
        flash(error)
    return render_template('auth/login.html', form=form)
(... 생략 ...)    
로그인시 next 파라미터 값이 있으면 읽어서 로그인 후 해당 페이지로 이동하고 없으면 메인 페이지로 이동하게 했다.


@login_required 적용하기
로그인이 필요한 함수에 @login_required 데코레이터를 적용해 보자.

우선 질문 등록 함수에 적용하자.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
from pybo.views.auth_views import login_required

(... 생략 ...)

@bp.route('/create/', methods=('GET', 'POST'))
@login_required
def create():
    (... 생략 ...)
@login_required 데코레이터는 반드시 함수명 바로 위에 위치해야 한다. @login_required 데코레이터가 @bp.route 데코레이터보다 위에 위치할 경우 정상동작하지 않는다.

이어서 답변을 등록하는 함수에도 적용하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

(... 생략 ...)
from .auth_views import login_required
(... 생략 ...)

@bp.route('/create/<int:question_id>', methods=('POST',))
@login_required
def create(question_id):
    (... 생략 ...)
이제 로그아웃 상태에서 질문 또는 답변 등록을 시도하면 로그인 화면으로 리다이렉트될 것이다.





로그아웃 상태에서 답변 등록 불가능하게 만들기
한가지 더 생각해 봐야 할 것이 있다. 현재 질문 등록은 로그아웃 상태에서는 아예 글을 작성할 수 없어서 만족스럽다. 하지만 답변 등록은 로그아웃 상태에서도 글을 작성할 수 있다. 물론 답변 작성 후 <저장하기>를 누르면 자동으로 로그인 화면으로 이동되므로 큰 문제는 아니지만 작성한 답변이 사라지는 문제가 있다.

작성한 글이 사라지는 문제를 해결하려면 로그아웃 상태에서는 아예 답변 작성을 못하게 막는 것이 좋을 것이다. 답변 작성 템플릿에서 textarea 엘리먼트가 로그인 상태가 아닌 경우 disabled를 지정하여 입력 자체를 하지 못하도록 다음과 같이 수정하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    (... 생략 ...)
    <form action="{{ url_for('answer.create', question_id=question.id) }}" method="post" class="my-3">
        (... 생략 ...)
        <div class="mb-3">
            <textarea {% if not g.user %}disabled{% endif %}
                    name="content" id="content" class="form-control" rows="10"></textarea>
        </div>
        <input type="submit" value="답변등록" class="btn btn-primary">
    </form>
</div>
{% endblock %}
이제 disabled 설정으로 textarea 엘리먼트가 비활성화될 것이다.



마지막 편집일시 : 2022년 8월 17일 8:20 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-09 글쓴이 표시하기


[완성 소스] : github.com/pahkey/jump2flask/tree/3-09
[실습 영상] : https://youtu.be/jdNC0M6L3zI
앞서 질문과 답변 등록시 글쓴이 정보를 저장했다. 게시판의 게시물에는 "글쓴이"를 표시하는 것이 일반적이다. 질문 목록, 질문 상세 화면에 user 속성을 이용하여 글쓴이를 표시해 보자.

질문 목록에 글쓴이 표시하기
질문 상세에 글쓴이 표시하기
질문 목록에 글쓴이 표시하기
글쓴이를 표시하기 위해 테이블에 글쓴이 항목을 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

(... 생략 ...)
<tr class="text-center table-dark">
    <th>번호</th>
    <th style="width:50%">제목</th>
    <th>글쓴이</th>
    <th>작성일시</th>
</tr>
(... 생략 ...)
<th>글쓴이</th>를 추가했다. 그리고 th 엘리먼트를 가운데 정렬하도록 tr 엘리먼트에 text-center 클래스를 추가하고 제목의 너비가 전체에서 50%를 차지하도록 style="width:50%"도 지정해 주었다.

이어서 for 문에도 글쓴이를 적용하자.

[파일명: projects/myproject/pybo/templates/question/question_list.html]

(... 생략 ...)
{% for question in question_list.items %}
<tr class="text-center">
    <td>{{ question_list.total - ((question_list.page-1) * question_list.per_page) - loop.index0 }}</td>
    <td class="text-start">
        <a href="{{ url_for('question.detail', question_id=question.id) }}">{{ question.subject }}</a>
        {% if question.answer_set|length > 0 %}
        <span class="text-danger small mx-2">{{ question.answer_set|length }}</span>
        {% endif %}
    </td>
    <td>{{ question.user.username }}</td>  <!-- 글쓴이 추가 -->
    <td>{{ question.create_date|datetime }}</td>
</tr>
{% endfor %}
(... 생략 ...)
<td>{{ question.user.username }}</td>를 삽입하여 질문의 글쓴이를 표시했다. 그리고 테이블 내용을 가운데 정렬하도록 tr 엘리먼트에 text-center 클래스를 추가하고, 제목을 왼쪽 정렬하도록 text-start 클래스를 추가했다.

질문 목록 화면에 글쓴이가 추가되었다.



질문 상세에 글쓴이 표시하기

질문 상세 화면에도 질문 작성일시 바로 위에 글쓴이를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
<div class="card-body">
    <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
    <div class="d-flex justify-content-end">
        <div class="badge bg-light text-dark p-2 text-start">
            <div class="mb-2">{{ question.user.username }}</div>
            <div>{{ question.create_date|datetime }}</div>
        </div>
    </div>
</div>
(... 생략 ...)
글쓴이와 작성일시를 함께 보여 주도록 부트스트랩을 이용하여 여백과 정렬 등의 디자인도 살짝 변경했다.

답변에도 글쓴이를 추가하자. 질문과 마찬가지로 작성일시 바로 위에 글쓴이를 표시하면 된다.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
<!-- 답변 목록 -->
<h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
{% for answer in question.answer_set %}
<div class="card my-3">
  <div class="card-body">
      <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
      <div class="d-flex justify-content-end">
          <div class="badge bg-light text-dark p-2 text-start">
              <div class="mb-2">{{ answer.user.username }}</div>
              <div>{{ answer.create_date|datetime }}</div>
          </div>
      </div>
  </div>
(... 생략 ...)
질문 상세 화면의 질문과 답변에 글쓴이가 추가되었다.



마지막 편집일시 : 2022년 8월 21일 12:25 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3-10 게시물 수정 & 삭제


[완성 소스] : github.com/pahkey/jump2flask/tree/3-10
[실습 영상] : https://youtu.be/oOqSB0o2y74
이번에는 작성한 게시물을 수정 & 삭제할 수 있는 기능을 추가할 것이다. 실습을 진행하다 보면 "비슷한 기능을 반복해서 구현한다는 느낌"을 받아 조금 지루할 수 있다. 하지만 게시물 수정 & 삭제 기능은 게시물 작성만큼 중요하다. 플라스크 개발 패턴을 연습할 수 있는 좋은 기회이므로 실습을 이해하며 따라가 보자.

수정 일시
질문 수정
질문 수정 버튼
질문 수정 라우팅 함수
오류 표시
질문 수정 확인
질문 삭제
질문 삭제 버튼
자바스크립트
자바스크립트 블록
질문 삭제 라우팅 함수
질문 삭제 확인
답변 수정
답변 수정 버튼
답변 수정 라우팅 함수
답변 수정 템플릿
답변수정 확인
답변 삭제
답변 삭제 버튼
답변 삭제 라우팅 함수
답변 삭제 확인
수정일시 표시하기
수정 일시
질문, 답변을 언제 수정했는지 확인할 수 있도록 Question 모델과 Answer 모델에 modify_date 속성을 추가하자.

[파일명: projects/myproject/pybo/models.py]

from pybo import db

class Question(db.Model):
    (... 생략 ...)
    modify_date = db.Column(db.DateTime(), nullable=True)


class Answer(db.Model):
    (... 생략 ...)
    modify_date = db.Column(db.DateTime(), nullable=True)

(... 생략 ...)
modify_date 속성에는 nullable=True로 null을 허용하도록 했다. 수정일시는 수정이 발생할 경우에만 생성되므로 null을 허용해야 한다.

모델이 변경되었으므로 migrate, upgrade 명령을 수행하자.

(myproject) c:\projects\myproject>flask db migrate
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.autogenerate.compare] Detected added column 'answer.modify_date'
INFO [alembic.autogenerate.compare] Detected added column 'question. modify_date'
Generating c:\projects\myproject\migrations\versions\f4949234d626_.py ... done

(myproject) c:\projects\myproject>flask db upgrade
INFO [alembic.runtime.migration] Context impl SQLiteImpl.
INFO [alembic.runtime.migration] Will assume non-transactional DDL.
INFO [alembic.runtime.migration] Running upgrade 0fbf53a8e0af -> f4949234d626, empty message
질문 수정
작성한 질문을 수정하려면 질문 상세 화면에서 "수정" 버튼을 클릭하여 수정 화면으로 진입해야 한다.

질문 수정 버튼
질문 상세 화면에 다음과 같이 질문 수정 버튼을 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]


(... 생략 ...)
<!-- 질문 -->
<h2 class="border-bottom py-2">{{ question.subject }}</h2>
<div class="card my-3">
    <div class="card-body">
        <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
        <div class="d-flex justify-content-end">
            <div class="badge bg-light text-dark p-2 text-start">
                <div class="mb-2">{{ question.user.username }}</div>
                <div>{{ question.create_date|datetime }}</div>
            </div>
        </div>
        <div class="my-3">
            {% if g.user == question.user %}
            <a href="{{ url_for('question.modify', question_id=question.id) }}"
               class="btn btn-sm btn-outline-secondary">수정</a>
            {% endif %}
        </div>
    </div>
</div>
(... 생략 ...)
질문 수정 버튼은 로그인한 사용자와 글쓴이가 같은 경우에만 보여야 하므로 {% if g.user == question.user %}를 사용했다.

로그인한 사용자와 글쓴이가 다르면 수정 버튼은 보이지 않는다.

질문 수정 라우팅 함수
질문 상세 템플릿에 url_for('question.modify', question_id=question.id) URL이 추가되었으니 다음과 같은 modify 함수를 작성해야 한다.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
from flask import Blueprint, render_template, request, url_for, g, flash

(... 생략 ...)

@bp.route('/modify/<int:question_id>', methods=('GET', 'POST'))
@login_required
def modify(question_id):
    question = Question.query.get_or_404(question_id)
    if g.user != question.user:
        flash('수정권한이 없습니다')
        return redirect(url_for('question.detail', question_id=question_id))
    if request.method == 'POST':  # POST 요청
        form = QuestionForm()
        if form.validate_on_submit():
            form.populate_obj(question)
            question.modify_date = datetime.now()  # 수정일시 저장
            db.session.commit()
            return redirect(url_for('question.detail', question_id=question_id))
    else:  # GET 요청
        form = QuestionForm(obj=question)
    return render_template('question/question_form.html', form=form)
질문 수정은 로그인이 필요하므로 @login_required 애너테이션을 추가했다. 만약 로그인한 사용자와 질문의 작성자가 다르면 수정할 수 없도록 flash 오류를 발생시키는 코드도 추가했다.

flash 함수는 강제로 오류를 발생시키는 함수로, 로직에 오류가 있을 경우 사용한다.

modify 함수가 GET 방식으로 요청되는 경우는 <질문수정> 버튼을 눌렀을 때이다. 이때 수정할 질문에 해당하는 "제목", "내용" 등의 데이터가 화면에 보여야 한다. 데이터베이스에서 조회한 데이터를 템플릿에 적용하는 가장 간단한 방법은 QuestionForm(obj=question)과 같이 조회한 데이터를 obj 매개변수에 전달하여 폼을 생성하는 것이다. 이렇게 하면 QuestionForm의 subject, content 속성에 question 객체의 subject, content 값이 저장되어 화면에도 표시된다.

modify 함수가 POST 방식으로 요청되는 경우는 질문 수정 화면에서 데이터를 수정한 다음 <저장하기> 버튼을 눌렀을 경우이다. form.validate_on_submit 함수에서 QuestionForm을 검증하고 아무 이상이 없으면 변경된 데이터를 저장한다. 데이터 변경을 위해 입력한 form.populate_obj(question)는 form 변수에 들어 있는 데이터(화면에서 입력한 데이터)를 question 객체에 업데이트 하는 역할을 한다.

오류 표시

그리고 flash 에 의해 발생되는 "수정권한이 없습니다"라는 오류가 표시될수 있도록 질문 상세 화면 위쪽에 오류 영역을 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

{% extends 'base.html' %}
{% block content %}
<div class="container my-3">
    <!-- flash 오류 -->
    {% for message in get_flashed_messages() %}
    <div class="alert alert-danger" role="alert">
        {{ message }}
    </div>
    {% endfor %}
    <!-- 질문 -->
    <h2 class="border-bottom py-2">{{ question.subject }}</h2>
(... 생략 ...)
물론 수정은 로그인 한 사용자와 글 작성자가 동일한 경우에만 가능하기 때문에 이 오류가 표시될 일은 없을 것이다. 하지만 비 정상적인 방법으로 질문을 수정할 경우 오류를 보여주어야 하므로 필요한 부분이다.

질문 수정 확인
이제 로그인한 후에 질문을 수정해 보자. 이때 로그인한 사용자와 글쓴이가 같아야 한다. 그렇지 않으면 <수정> 버튼이 보이지 않는다.



질문 삭제
작성한 질문을 삭제하려면 질문 상세 화면에서 "삭제" 버튼을 눌러 삭제해야 한다.

질문 삭제 버튼
이번에는 작성한 글을 삭제할 수 있는 버튼을 다음처럼 추가해 보자.


[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
<!-- 질문 -->
<h2 class="border-bottom py-2">{{ question.subject }}</h2>
<div class="card my-3">
    <div class="card-body">
        (... 생략 ...)
        <div class="my-3">
            {% if g.user == question.user %}
            <a href="{{ url_for('question.modify', question_id=question.id) }}"
               class="btn btn-sm btn-outline-secondary">수정</a>
            <a href="javascript:void(0)" class="delete btn btn-sm btn-outline-secondary"
               data-uri="{{ url_for('question.delete', question_id=question.id) }}">삭제</a>
            {% endif %}
        </div>
    </div>
</div>
(... 생략 ...)
<삭제> 버튼은 <수정> 버튼과는 달리 href 속성값을 "javascript:void(0)"로 설정했다.

href 속성값을 javascript:void(0)로 설정하면 해당 링크를 클릭해도 아무런 동작도 하지 않는다.

그리고 삭제를 실행할 URL을 얻기 위해 data-uri 속성을 추가하고, <삭제> 버튼이 눌리는 이벤트를 확인할 수 있도록 class 속성에 "delete" 항목을 추가해 주었다.

data-uri 속성은 자바스크립트에서 클릭 이벤트 발생시 this.dataset.uri와 같이 사용하여 그 값을 얻을 수 있다.

href에 삭제 URL을 직접 사용하지 않고 이러한 방식을 사용하는 이유는 삭제 버튼을 클릭했을때 "정말로 삭제하시겠습니까?" 와 같은 확인창이 필요하기 때문이다.

자바스크립트
삭제 버튼을 눌렀을때 확인창을 호출하기 위해서는 다음과 같은 자바스크립트 코드가 필요하다.

아래 코드를 아직 추가하지 말자. 지금은 눈으로만 보자.

<script type='text/javascript'>
const delete_elements = document.getElementsByClassName("delete");
Array.from(delete_elements).forEach(function(element) {
    element.addEventListener('click', function() {
        if(confirm("정말로 삭제하시겠습니까?")) {
            location.href = this.dataset.uri;
        };
    });
});
</script>
이 자바스크립트의 의미는 delete라는 클래스를 포함하는 컴포넌트(예:버튼이나 링크)를 클릭하면 "정말로 삭제하시겠습니까?" 라는 질문을 하고 "확인"을 선택했을때 해당 컴포넌트의 data-uri 값으로 URL 호출을 하라는 의미이다. "확인" 대신 "취소"를 선택하면 아무런 일도 발생하지 않을 것이다.


※ delete 클래스는 답변 삭제에도 사용된다.

따라서 이와 같은 스크립트를 추가하면 "삭제" 버튼을 클릭하고 "확인"을 선택하면 data-uri 속성에 해당하는 {% url 'pybo:question_delete' question.id %} URL이 호출될 것이다.

자바스크립트 블록
자바스크립트는 HTML 구조에서 다음과 같이 </body> 태그 바로 위에 삽입하는 것을 추천한다.

<html>
<head>
(... 생략 ...)
</head>
<body>
(... 생략 ...)
<!-- 이곳에 추가 -->
</body>
</html>
왜냐하면 이렇게 해야 화면 렌더링이 완료된 후에 자바스크립트가 실행되기 때문이다. 화면 렌더링이 완료되지 않은 상태에서 자바스크립트를 실행하면 화면의 값을 읽지 못하는 오류가 발생할수도 있고 화면 로딩이 지연되는 문제가 발생할 수도 있다. 따라서 자바스크립트는 </body> 태그 바로 위에 삽입하는 것이 좋다.

자바스크립트를 </body> 태그 바로 위에 삽입하기 위해 다음처럼 base.html을 수정하자.

[파일명: projects/myproject/pybo/templates/base.html]

(... 생략 ...)
<!-- Bootstrap JS -->
<script src="{{ url_for('static', filename='bootstrap.min.js') }}"></script>
<!-- 자바스크립트 Start -->
{% block script %}
{% endblock %}
<!-- 자바스크립트 End -->
</body>
</html>
base.html 을 상속하는 템플릿들에서 content 블록을 구현하게 했던것과 마찬가지 방법으로 script 블록을 구현할수 있도록 했다. </body> 태그 바로 위에 {% block script %}{% endblock %} 블록을 추가했다. 이렇게 하면 이제 base.html을 상속하는 템플릿은 자바스크립트의 삽입 위치를 신경쓸 필요없이 스크립트 블록을 사용하여 자바스크립트를 작성하면 된다.

question_detail.html 하단에 {% block script %}{% endblock %} 블록을 다음처럼 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]


(... 생략 ...)
{% endblock %}
{% block script %}
<script type='text/javascript'>
const delete_elements = document.getElementsByClassName("delete");
Array.from(delete_elements).forEach(function(element) {
    element.addEventListener('click', function() {
        if(confirm("정말로 삭제하시겠습니까?")) {
            location.href = this.dataset.uri;
        };
    });
});
</script>
{% endblock %}
{% block script %}과 {% endblock %} 사이에 질문을 삭제할 수 있는 자바스크립트를 작성하였다.

질문 삭제 라우팅 함수
앞서 질문 상세 템플릿에 작성한 data-uri 속성에 url_for('question.delete', question_id=question.id) URL이 추가되었으므로 질문을 삭제할 수 있도록 라우팅 함수 delete를 추가해야 한다.

[파일명: projects/myproject/pybo/views/question_views.py]

(... 생략 ...)
@bp.route('/delete/<int:question_id>')
@login_required
def delete(question_id):
    question = Question.query.get_or_404(question_id)
    if g.user != question.user:
        flash('삭제권한이 없습니다')
        return redirect(url_for('question.detail', question_id=question_id))
    db.session.delete(question)
    db.session.commit()
    return redirect(url_for('question._list'))
delete 함수 역시 로그인이 필요하므로 @login_required 애너테이션을 적용하고, 로그인한 사용자와 글쓴이가 같은 경우에만 질문을 삭제할 수 있도록 했다.

질문 삭제 확인
이제 질문 작성자와 로그인 사용자가 같으면 질문 상세 화면에 <삭제> 버튼이 나타날 것이다. 버튼을 눌러 기능을 확인해 보자.



답변 수정
이번에는 답변 수정 기능을 추가하자. 질문 수정과 거의 비슷한 방법으로 진행할 것이다. 다만 답변 수정은 답변 등록 템플릿이 따로 없으므로 답변 수정에 사용할 템플릿이 추가로 필요하다. 답변 등록은 질문 상세 화면 아래쪽에 텍스트 입력 창을 추가하여 만든 것이므로 질문 상세 템플릿을 답변 수정용으로 사용하는 데는 적합하지 않다.


답변 수정 기능은 질문 수정과 크게 차이 나지 않으므로 간단히 설명하고 넘어가겠다.

답변 수정 버튼
답변 목록이 출력되는 부분에 답변 수정 버튼을 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
<!-- 답변 목록 -->
<h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
{% for answer in question.answer_set %}
<div class="card my-3">
    <div class="card-body">
        <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
        <div class="d-flex justify-content-end">
            <div class="badge bg-light text-dark p-2 text-start">
                <div class="mb-2">{{ answer.user.username }}</div>
                <div>{{ answer.create_date|datetime }}</div>
            </div>
        </div>
        <div class="my-3">
            {% if g.user == answer.user %}
            <a href="{{ url_for('answer.modify', answer_id=answer.id) }}"
               class="btn btn-sm btn-outline-secondary">수정</a>
            {% endif %}
        </div>
    </div>
</div>
{% endfor %}
(... 생략 ...)
답변 수정 라우팅 함수
url_for('answer.modify', answer_id=answer.id) URL을 추가했으므로 answer_views.py 파일에 modify 함수를 추가하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

(... 생략 ...)
from flask import Blueprint, url_for, request, render_template, g, flash

(... 생략 ...)

@bp.route('/modify/<int:answer_id>', methods=('GET', 'POST'))
@login_required
def modify(answer_id):
    answer = Answer.query.get_or_404(answer_id)
    if g.user != answer.user:
        flash('수정권한이 없습니다')
        return redirect(url_for('question.detail', question_id=answer.question.id))
    if request.method == "POST":
        form = AnswerForm()
        if form.validate_on_submit():
            form.populate_obj(answer)
            answer.modify_date = datetime.now()  # 수정일시 저장
            db.session.commit()
            return redirect(url_for('question.detail', question_id=answer.question.id))
    else:
        form = AnswerForm(obj=answer)
    return render_template('answer/answer_form.html', form=form)
답변 수정 템플릿
답변 수정에 사용할 answer_form.html 파일은 다음처럼 작성하자.

[파일명: projects/myproject/pybo/templates/answer/answer_form.html]


<!-- 답변 수정 -->
{% extends 'base.html' %}
{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">답변 수정</h5>
    <form method="post">
        {{ form.csrf_token }}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="content">답변내용</label>
            <textarea class="form-control" name="content" id="content"
                      rows="10">{{ form.content.data or '' }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}
답변 내용을 확인하고 수정할 수 있는 간단한 템플릿이다.

답변수정 확인
질문과 마찬가지로 답변도 등록한 사용자와 로그인한 사용자가 같아야 <수정> 버튼이 나타난다. 답변을 작성한 뒤 <수정> 버튼을 누르면 답변 수정화면으로 이동한다. 정상적으로 동작하는지 확인해보자.



답변 삭제
이번에는 답변을 삭제하는 기능을 추가해 보자. 답변 삭제도 질문 삭제와 동일한 방법이므로 빠르게 알아보자.

답변 삭제 버튼
질문 상세 템플릿에서 답변을 삭제할 수 있는 버튼을 다음과 같이 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
<!-- 답변 목록 -->
<h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
{% for answer in question.answer_set %}
<div class="card my-3">
    <div class="card-body">
        (... 생략 ...)
        <div class="my-3">
            {% if g.user == answer.user %}
            <a href="{{ url_for('answer.modify', answer_id=answer.id) }}"
               class="btn btn-sm btn-outline-secondary">수정</a>
            <a href="#" class="delete btn btn-sm btn-outline-secondary "
               data-uri="{{ url_for('answer.delete', answer_id=answer.id) }}">삭제</a>
            {% endif %}
        </div>
    </div>
</div>
{% endfor %}
(... 생략 ...)
<수정> 버튼 옆에 <삭제> 버튼을 추가했다. 질문의 <삭제> 버튼과 마찬가지로 <삭제> 버튼에 delete 클래스를 적용했으므로 <삭제> 버튼을 누르면 data-uri 속성에 설정한 url이 실행될 것이다.

답변 삭제 라우팅 함수
url_for('answer.delete', answer_id=answer.id) URL을 추가했으므로 answer_views.py 파일에 delete 함수를 작성하자.

[파일명: projects/myproject/pybo/views/answer_views.py]

(... 생략 ...)
@bp.route('/delete/<int:answer_id>')
@login_required
def delete(answer_id):
    answer = Answer.query.get_or_404(answer_id)
    question_id = answer.question.id
    if g.user != answer.user:
        flash('삭제권한이 없습니다')
    else:
        db.session.delete(answer)
        db.session.commit()
    return redirect(url_for('question.detail', question_id=question_id))
delete 함수 역시 로그인이 필요하므로 @login_required 애너테이션을 추가했다.

답변 삭제 확인
이제 질문 상세 화면에서 답변을 작성한 사용자와 로그인한 사용자가 같으면 <삭제> 버튼이 나타날 것이다. 삭제 기능이 잘 동작하는지 확인해 보자.



수정일시 표시하기
마지막으로 질문 상세 화면에서 수정일시를 확인할 수 있도록 템플릿을 수정해 보자. 질문과 답변에는 이미 작성일시를 표시하고 있다. 작성일시 바로 왼쪽에 수정일시를 추가하자.

[파일명: projects/myproject/pybo/templates/question/question_detail.html]

(... 생략 ...)
<!-- 질문 -->
<h2 class="border-bottom py-2">{{ question.subject }}</h2>
<div class="card my-3">
    <div class="card-body">
        <div class="card-text" style="white-space: pre-line;">{{ question.content }}</div>
        <div class="d-flex justify-content-end">
            {% if question.modify_date %}
            <div class="badge bg-light text-dark p-2 text-start mx-3">
                <div class="mb-2">modified at</div>
                <div>{{ question.modify_date|datetime }}</div>
            </div>
            {% endif %}
            <div class="badge bg-light text-dark p-2 text-start">
                <div class="mb-2">{{ question.user.username }}</div>
                <div>{{ question.create_date|datetime }}</div>
            </div>
        </div>
(... 생략 ...)
<!-- 답변 목록 -->
<h5 class="border-bottom my-3 py-2">{{ question.answer_set|length }}개의 답변이 있습니다.</h5>
{% for answer in question.answer_set %}
<div class="card my-3">
    <div class="card-body">
        <div class="card-text" style="white-space: pre-line;">{{ answer.content }}</div>
        <div class="d-flex justify-content-end">
            {% if answer.modify_date %}
            <div class="badge bg-light text-dark p-2 text-start mx-3">
                <div class="mb-2">modified at</div>
                <div>{{ answer.modify_date|datetime }}</div>
            </div>
            {% endif %}
            <div class="badge bg-light text-dark p-2 text-start">
                <div class="mb-2">{{ answer.user.username }}</div>
                <div>{{ answer.create_date|datetime }}</div>
            </div>
        </div>
(... 생략 ...)
이제 질문이나 답변을 수정하면 다음처럼 수정일시가 표시될 것이다.



마지막 편집일시 : 2022년 8월 16일 9:49 오전
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
https://hyeonql.tistory.com/entry/Flask-Login%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A6%9D%EA%B3%BC-%EC%84%B8%EC%85%98-%EA%B4%80%EB%A6%AC
Flask-Login을 활용한 인증과 세션 관리




MySQL pymySQL
https://github.com/miracle-21/RECA2-2023-TeamProject?tab=readme-ov-file#%F0%9F%94%96-%EC%B5%9C%EC%A2%85-%EA%B2%B0%EA%B3%BC

Web/web dev
Flask-Migrate로 SQLAlchemy 마이그레이션 쉽게 하기
hy30nq 2024. 6. 19. 13:24

https://hyeonql.tistory.com/entry/Flask-Migrate%EB%A1%9C-SQLAlchemy-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EC%89%BD%EA%B2%8C-%ED%95%98%EA%B8%B0

안녕하세요! 오늘은 Flask 애플리케이션에서 SQLAlchemy를 이용해 데이터베이스 마이그레이션을 쉽게 할 수 있도록 도와주는 Flask-Migrate에 대해 소개해드릴게요. 데이터베이스 마이그레이션은 팀 작업을 원활하게 하고, 스키마 변경을 추적하며, 배포 시 용이성을 높여주는 중요한 작업이랍니다.

Flask-Migrate 장점
스키마 변경의 추적
팀 작업 용이
배포 용이성
데이터 손실 방지
초기 설정
먼저 Flask와 필요한 확장들을 설치하고, 간단한 애플리케이션을 설정해볼게요.

from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://root:password@localhost/dbname'
db = SQLAlchemy(app)

class User(db.Model):
  id = db.Column(db.Integer, primary_key=True)
  username = db.Column(db.String(80), unique=True, nullable=True)
  email = db.Column(db.String(120), unique=True, nullable=True)

  def __repr__(self):
    return '<User %r>' % self.username

migrate = Migrate(app, db)
위와 같이 Flask 애플리케이션과 SQLAlchemy, 그리고 Flask-Migrate를 설정해줍니다.

마이그레이션 초기화
이제 마이그레이션을 초기화해볼게요. 터미널에서 아래 명령어를 실행해 주세요.

flask db init
이 명령어를 실행하면 migrations라는 폴더가 생성되고, 이 폴더 내에 마이그레이션 파일들이 저장된답니다.

마이그레이션 파일 생성
모델에 변경 사항이 생기면 아래 명령어를 실행해 새로운 마이그레이션 파일을 생성할 수 있어요.

flask db migrate -m "Initial migration."
여기서 -m 옵션은 마이그레이션 메시지를 추가하는 옵션이에요. 메시지를 통해 어떤 변경이 있었는지 쉽게 알 수 있어요.

마이그레이션 적용
이제 생성된 마이그레이션 파일을 실제 데이터베이스에 적용해볼게요.

flask db upgrade
이 명령어를 실행하면 마이그레이션 파일을 바탕으로 데이터베이스 스키마가 변경된답니다.

롤백
만약 데이터베이스 스키마를 이전 상태로 되돌리고 싶다면, 아래 명령어를 사용해 롤백할 수 있어요.

flask db downgrade <version_hash>
하지만 롤백 시에는 주의사항이 있어요. 테이블 구조는 이전 상태로 돌아가지만, 실제 데이터에 대해서는 롤백이 수행되지 않아요. 데이터 손실이나 불일치가 발생할 수 있기 때문에 주의해야 해요.

결론
Flask-Migrate는 SQLAlchemy와 함께 사용할 때 매우 유용한 도구예요. 스키마 변경을 추적하고, 팀 작업을 원활하게 하며, 배포 시 용이성을 높여주기 때문에, Flask 애플리케이션을 개발할 때 꼭 사용해보세요. 😊


□ quant_py-main : sql_in_python.ipynb
1) pymysql 패키지 이용
import pymysql

con = pymysql.connect(
    user='root',
    passwd='1234',
    host='127.0.0.1',
    db='shop',
    charset='utf8'
)

mycursor = con.cursor()


query = """
    select * from goods;
"""

mycursor.execute(query)
data = mycursor.fetchall()
con.close()

display(data)



con = pymysql.connect(user='root',
                      passwd='1234',
                      host='127.0.0.1',
                      db='shop',
                      charset='utf8')

mycursor = con.cursor()
query = """
    insert into goods (goods_id, goods_name, goods_classify, sell_price, buy_price, register_date)
    values ('0010', '스테이플러', '사무용품', '2000', '1500', '2020-12-30');
"""

mycursor.execute(query)
con.commit()
con.close()






2) pandas
import pandas as pd
from sqlalchemy import create_engine

# engine = create_engine('mysql+pymysql://[사용자명]:[비밀번호]@[호스트:포트]/[사용할 데이터베이스]')
engine = create_engine('mysql+pymysql://root:1234@127.0.0.1:3306/shop')
query = """select * from Goods"""
goods = pd.read_sql(query, con=engine)
engine.dispose()

goods.head()

===============================================================
