출처: https://ccomccomhan.tistory.com/131 [[꼼꼼한 개발자] 꼼코더:티스토리]

간단하고 쉽게/JAVA
[JAVA] - JPA란? 간단하고 쉽게 이해하기(예제코드 완벽정리)
꼼코더 2023. 3. 21. 10:55
  
    반응형    
    
    (adsbygoogle = window.adsbygoogle || []).push({});
  
       
□ 간단 정리
- JPA는 자바의 ORM기술을 쉽게 구현하도록 도와주는 API이다.
- JpaRepository를 상속하는 인터페이스에 메서드 이름만 적어놓으면 알아서 다 처리(구현체 생성, 쿼리문 구현 등)해주는 좋은 ORM이다.
- 메소드 이름은 findby(필드명), deleteby(필드명)처럼 메소드 명칭만 적어주면 개발자는 SQL을 작성하지 않아도 쿼리문을 만들어준다.
- 이때 엔티티라는 클래스를 이용하는데 객체를 이용하여 매핑을 처리하는 것이다.
- 어렵다면 엔티는 == 테이블 or 레코드라고 생각해 보자!
 
자세한 건 아래 글을 읽어 보도록 하자.
 
▷ JPA(Java Persistence API)란?
- 자바에서 객체를 데이터베이스에 저장하고 관리하기 위한 인터페이스와 기능을 제공하는 API.
- JPA를 사용하면 객체와 관계형 데이터베이스 간의 매핑을 손쉽게 처리할 수 있으며 데이터베이스의 CRUD(Create, Read, Update, Delete) 작업을 간편하게 수행할 수 있다.
 
▷ 예제 코드(작성 순서)
1. 엔티티 클래스 정의
- 데이터베이스 테이블과 매핑될 엔티티 클래스를 정의한다.
- 이때, 엔티티 클래스는 @Entity 어노테이션을 이용하여 정의한다.
- 예를 들어, 다음과 같이 User 엔티티 클래스를 정의할 수 있다.

@Entity // 엔티티 클래스임을 선언.
@Table(name = "users") // 해당 엔티티 클래스와 매핑될 데이터베이스 테이블 이름을 지정.
public class User {

    @Id // 엔티티 클래스의 주요 식별자(primary key)임을 선언
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 엔티티의 식별자 값을 자동으로 생성
    private Long id;

    // 해당 엔티티 클래스의 필드가 데이터베이스의 칼럼으로 매핑될 때,
    // 해당 칼럼의 제약 조건을 설정하는 어노테이션입니다. (널허용 = x 등)
    @Column(nullable = false, unique = true) 
    private String username;

    @Column(nullable = false)
    private String password;

    // getters and setters
}
 
 
2. Repository 인터페이스 정의
- 엔티티를 조작하기 위한 Repository 인터페이스를 정의한다.
- 이때, JpaRepository 인터페이스를 상속받아 사용한다.
- JpaRepository 인터페이스를 상속받기에 따로 메서드 구현, 구현체 작성을 하지 않아도 자동으로 생성된다.
  (쉽게 말해 JpaRepository만 상속받으면 따로 구현코드 없이 해당 메서드를 사용할 수 있다)
- 예를 들어, 다음과 같이 UserRepository 인터페이스를 정의할 수 있다.

// 해당 인터페이스가 스프링의 데이터 접근 계층(Data Access Layer)의 컴포넌트임을 선언
// 간단하게 말 하자면 "레파지토리"를 의미
@Repository
// JpaRepository<User, Long> 인터페이스 : 스프링 데이터 JPA에서 제공하는 CRUD 메서드를 상속받아 사용할 수 있는 인터페이스입니다.
public interface UserRepository extends JpaRepository<User, Long> {
	
    // 데이터베이스에서 username 필드 값이 일치하는 User 엔티티 객체를 반환하는 메서드입니다.
    Optional<User> findByUsername(String username);

}
 
3. 엔티티 매니저 팩토리 설정
- application.properties 또는 application.yml 파일을 이용하여 JPA 설정 정보를 지정.
- 예를 들어, 다음과 같이 스프링 부트의 기본 데이터베이스 설정을 이용하여 H2 데이터베이스를 사용하는 JPA 설정을 지정.

# H2 인-메모리 데이터베이스를 사용하기 위한 데이터 소스 설정(application.yml)
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=

# JPA를 사용하기 위한 설정
spring.jpa.hibernate.ddl-auto=create # 애플리케이션 실행 시 엔티티를 대상으로 DDL 실행
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect # H2 데이터베이스 방언 지정
 
4. 서비스 클래스 정의
엔티티를 사용하는 비즈니스 로직을 구현하는 서비스 클래스를 정의.
이때, UserRepository 인터페이스를 주입받아 사용한다.
 
예를 들어, 다음과 같이 UserService 클래스를 정의할 수 있다
 
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    /**
     * 새로운 사용자를 생성하고, 생성된 사용자를 반환.
     * param : user 새로 생성할 사용자 정보
     * return : 생성된 사용자 정보
     */
    public User createUser(User user) {
        return userRepository.save(user);
    }

    /**
     * 주어진 사용자명(username)에 해당하는 사용자 정보를 조회.
     * param : username 조회할 사용자명
     * return 사용자 정보가 존재하는 경우 해당 정보를, 그렇지 않은 경우 null을 반환.
     */
    public Optional<User> findByUsername(String username) {
        return userRepository.findByUsername(username);
    }

    // other methods
}
 
5. 컨트롤러 클래스 정의
- HTTP 요청을 처리하는 컨트롤러 클래스를 정의.
- 이때, UserService 클래스를 주입받아 사용한다.
 
예를 들어, 다음과 같이 UserController 클래스를 정의할 수 있다.

@RestController
@RequestMapping("/users")
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 새로운 사용자를 생성하고, 생성된 사용자 정보를 반환.
     * param : user 생성할 사용자 정보
     * return : 생성된 사용자 정보
     */
    @PostMapping
    public User createUser(@RequestBody User user) {
        return userService.createUser(user);
    }

    /**
     * 주어진 사용자명(username)에 해당하는 사용자 정보를 조회.
     * param : username 조회할 사용자명
     * return : 사용자 정보가 존재하는 경우 해당 정보를, 그렇지 않은 경우 null을 반환.
     */
    @GetMapping("/{username}")
    public User getUser(@PathVariable String username) {
        Optional<User> user = userService.findByUsername(username);
        if (user.isPresent()) {
            return user.get();
        } else {
            throw new UserNotFoundException(username);
        }
    }

    // other methods
}
 
- JPA는 이외에도 다양한 기능을 제공한다.
- JPQL(Java Persistence Query Language)을 사용하여 객체를 검색하고 조작하는 등의 작업을 수행할 수 있다.

============================================================================================================

간단하고 쉽게/JAVA
[JAVA] - MyBatis란?, 마이바티스란?(예제코드) 간단하고 쉽게 이해하기
꼼코더                           2023. 3. 20. 15:44

□ 간단 정리

1. MyBatis를 사용하면  DB를 쉽게 다룰 수 있다.
- 예시) preparedstatement처럼 쿼리문을 복잡하게 입력하지 않고 실제 쿼리문과 유사하게 작성할 수 있다.
- preparedstatement : "UPDATE users SET name =?, email =? WHERE id =?"
- MyBatis : UPDATE users SET name = #{name}, email = #{email} WHERE id = #{id}
2. MyBatis의 또 하나의 장점은 동적 쿼리 작성이 가능하다.
3. MyBatis 사용 방법순서 : 의존성 설정 -> DB 설정 -> MyBatis 설정 -> Mapper 인터페이스 작성 -> XML 작성 -> MyBatis 사용

아래글을 보고나면 이해가 훨씬 더 잘 될 것이다!
  
□ MyBatis란?
- MyBatis는 자바 개발자들이 데이터베이스를 쉽게 다룰 수 있도록 도와주는 오픈 소스 ORM(Object-Relational Mapping) 프레임워크이다.
 
□ MyBatis의 사용 목적
- MyBatis는 데이터베이스 쿼리 <-> 프로그래밍 언어 코드를 분리하여 유지보수성과 생산성을 높이는 것.

□ MyBatis의 주요 장점
1. 유연성: SQL 쿼리를 직접 작성할 수 있으므로 매우 유연하다. 또한, MyBatis는 동적 쿼리를 작성할 수 있다.
2. 간결성: MyBatis는 SQL 쿼리와 프로그래밍 언어 코드를 분리하기 때문에 코드가 간결해져 유지보수에 용이
3. 성능: MyBatis는 캐시 기능을 제공하여 데이터베이스 연산 속도를 높일 수 있다.
4. 다양한 데이터베이스 지원: MyBatis는 다양한 데이터베이스에 대한 지원을 제공합니다.
 
□ 대표적인 장점 유연성(동적쿼리)
- 동적 쿼리란, 실행 시점에 조건에 따라 SQL 쿼리를 동적으로 생성하는 것.
- 이는 데이터베이스의 검색 조건이나 결괏값 등이 동적으로 변화할 때 유용하게 사용된다.
 
- MyBatis에서는 동적 쿼리를 작성하기 위해
 <if>, <choose>, <when>, <otherwise>, <foreach> 등의 태그를 사용할 수 있다.
  
- 아래는 MyBatis에서 동적 쿼리를 작성하는 예제이다.
- getUserList() 메서드 호출 시 name과 email 파라미터가 null이 아니면 해당 조건을 포함하는 SQL 쿼리를 동적으로 생성하여 조회한다.

// xml 파일

<select id="getUserList" resultType="User">
  SELECT * FROM users
  <where>
    <if test="name != null"> // 동적 쿼리 
      AND name = #{name}
    </if>
    <if test="email != null"> // 동적 쿼리 
      AND email = #{email}
    </if>
  </where>
</select>
 

□ MyBatis 사용순서와 예제

1. 스프링 프로젝트 생성 후 필요한 의존성 추가
- 필요한 의존성
spring-core
spring-jdbc
mybatis
mybatis-spring
 
2.  데이터베이스(DB) 설정
- MyBatis는 JDBC로 DB 연결을 하기에 DB 연결 정보를 설정해야 한다.
- 스프링 설정(XML, properties 등)에 DB 연결 정보(DataSource) 등록 

<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
   <property name="driverClassName" value="com.mysql.jdbc.Driver"/> // mysql 드라이버
   <property name="url" value="jdbc:mysql://localhost:3306/mydatabase"/> // mysql 사용
   <property name="username" value="username"/> // 아이디 
   <property name="password" value="password"/> // 비밀번호 
</bean>
 
3. MyBatis 설정 
- MyBatis XML 설정파일 생성 후 필요한 설정 추가.

<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
   <property name="dataSource" ref="dataSource"/>
   <property name="configLocation" value="classpath:mybatis-config.xml"/>
</bean>

<bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
   <constructor-arg ref="sqlSessionFactory"/>
</bean>
 
4. MyBatis 매퍼 작성 후 등록
MyBatis Mapper는 DB 쿼리와 <-> 자바 메서드()를 매핑하는 역할
데이터베이스에 접근하기 위한 SQL 쿼리를 작성하고, 이를 실행하는 자바 메서드를 정의한다.
 
쉽게 말해 "XML에 SQL 쿼리들을 작성할 건데 그 SQL이 연결될 메서드들을 정의할 파일을 만들자!"
 
예시) "CRUD 쿼리문을 XML에 작성할 예정 이거든? 음.. Insertitems(), Getitems(), modifyitems(), Deleteitems() 메서드가 있는 인터페이스를 만들자 그리고 그 클래스를 Mapper라는 명칭으로 부르자! 어때 쉽지?"

@Mapper // 등록 
// 작성
public interface UserMapper {
   User getUserById(int id);
   void insertUser(User user);
   void updateUser(User user);
   void deleteUser(int id);
}
 
5. Mapper 인터페이스와 연결될 XML 작성
- Mapper 속 메서드( ) 별로 SQL쿼리문 작성

  <!-- user_mapper.xml -->

<mapper namespace="com.example.mapper.UserMapper">
  <select id="getUserById" parameterType="int" resultType="com.example.model.User">
    SELECT * FROM users WHERE id = #{id}
  </select>

  <insert id="insertUser" parameterType="com.example.model.User">
    INSERT INTO users (name, email) VALUES (#{name}, #{email})
  </insert>

  <!-- 다른 메서드들에 대한 쿼리도 추가할 수 있다 -->
</mapper>
 
6.  Mapper 사용
- Mapper 인터페이스를 스프링 Bean으로 등록하고 주입받아 사용

@Service
public class UserService {
   private final UserMapper userMapper;

   public UserService(UserMapper userMapper) {
       this.userMapper = userMapper;
   }

   // 유저 조회
   public User getUserById(int id) {
       return userMapper.getUserById(id);
   }

   // 유저 등록
   public void insertUser(User user) {
       userMapper.insertUser(user);
   }

   // ... 다른 메서드들
}
 

======================================================================================================
[개념 콕] 스프링 JPA란? <ORM, Hibernate, JPA>
내일배움캠프 수료생이 개발에 꼭 필요한 핵심 개념만 콕 집어 드립니다.
Jun 03, 2024
[개념 콕] 스프링 JPA란? <ORM, Hibernate, JPA> 
✍🏼
개발을 시작하시는 여러분, 정보가 너무 많고 배워야 할 것도 산더미라 어디서부터 시작해야 할지 막막하신가요? 내일배움캠프 수료생들이 4개월 동안 배운 엄선된 핵심 개념을 직접 정리해서 알려 드립니다. 공부하다 막히거나 헷갈리는 개념이 있다면 개념 콕으로 정리해보세요. 
 
현대의 자바 애플리케이션에서 데이터 지속성(persistence)은 중요합니다. 데이터 지속성이란 애플리케이션에서 생성되고 조작되는 데이터를 영구적으로 저장하고 관리하는 것을 의미합니다. 이를 통해 애플리케이션은 데이터의 무결성을 유지하고, 장기적으로 데이터를 보관하며, 필요할 때마다 데이터를 검색하고 활용할 수 있습니다.
전통적으로 자바 애플리케이션에서는 JDBC(Java Database Connectivity)를 사용하여 데이터베이스와 상호작용해 왔습니다. 하지만 JDBC를 직접 사용하는 것은 몇 가지 한계와 문제점을 가지고 있습니다. 반복적이고 boilerplate한 코드 작성, 객체 지향 프로그래밍과 관계형 데이터베이스 간의 불일치, 그리고 데이터베이스에 종속적인 코드 등이 대표적인 문제점입니다.
이러한 문제를 해결하기 위해 JPA(Java Persistence API)가 등장했습니다. JPA는 자바 애플리케이션에서 관계형 데이터베이스를 사용하는 방식을 표준화한 API입니다. JPA를 사용하면 개발자는 객체 지향적인 방식으로 데이터를 다룰 수 있으며, 데이터베이스에 대한 종속성을 줄일 수 있습니다.
JPA는 ORM(Object-Relational Mapping) 기술을 기반으로 합니다. ORM은 객체와 관계형 데이터베이스 간의 매핑을 자동화하여 개발자의 생산성을 높이고, 유지보수성을 향상시킵니다. JPA는 ORM의 장점을 활용하면서도, 표준 API를 제공하여 다양한 구현체를 사용할 수 있는 유연성을 제공합니다. 따라서 이번 아티클에서는 ORM과 대표적인 JPA 구현체인 Hibernate부터 JPA까지 모두 알아봅시다. 
 
 
ORM(Object-Relational Mapping)
ORM이란? 
객체 지향 프로그래밍 언어에서 사용되는 객체와 관계형 데이터베이스의 데이터 간의 매핑을 자동화하는 기법입니다. 개발자는 객체 지향 프로그래밍의 장점을 유지하면서 데이터베이스와의 상호작용을 쉽게 처리할 수 있습니다. 
ORM은 데이터베이스 테이블의 행을 객체로, 열을 객체의 속성으로 매핑하여 객체 지향 방식으로 데이터베이스를 조작할 수 있게 해줍니다.
 
ORM 핵심 개념 
매핑 
객체와 데이터베이스 테이블 간의 대응 관계를 설정합니다.
자바 클래스의 필드는 데이터베이스 테이블의 열에 매핑됩니다.
엔티티
데이터베이스 테이블에 대응하는 객체입니다.
각 엔티티 인스턴스는 데이터베이스 테이블의 한 행을 나타냅니다.
속성
엔티티 클래스의 필드는 데이터베이스 테이블의 열에 매핑됩니다.
클래스의 name 속성은 테이블의 name 열에 매핑됩니다.
연관 관계
객체 간의 관계를 정의하고 이를 데이터베이스 테이블 간의 외래 키 관계로 매핑합니다.
일대일, 일대다, 다대일, 다대다 관계가 있습니다.
 
ORM의 장점
객체 지향 프로그래밍의 일관성 유지
데이터베이스 접근 로직을 객체 지향 방식으로 작성할 수 있어 코드의 일관성을 유지할 수 있습니다.
생산성 향상
CRUD 코드를 자동화하여 개발 생산성을 높입니다.
복잡한 SQL 쿼리를 직접 작성하지 않아도 되므로 개발 속도가 빨라집니다.
유지보수 용이성
데이터베이스 스키마가 변경될 경우, 엔티티 클래스를 수정하여 쉽게 대응할 수 있습니다.
비즈니스 로직과 데이터베이스 접근 로직의 분리로 유지보수가 용이해집니다.
 
Hibernate
Hibernate란? 
Hibernate는 자바 프로그래밍 언어용 ORM 프레임워크로, 관계형 데이터베이스와 객체 지향 프로그래밍을 연결해줍니다.
Hibernate는 JPA(Java Persistence API)의 표준 구현체 중 하나로, 자바 객체와 데이터베이스 간의 매핑을 자동으로 처리하여 개발자가 데이터베이스와 상호작용할 때 복잡한 SQL 쿼리를 작성하지 않아도 되게 해줍니다.
 
Hibernate 핵심 개념 
객체-관계 매핑(ORM)
자바 클래스와 데이터베이스 테이블 간의 매핑을 설정합니다.
데이터베이스의 테이블을 자바 객체로, 테이블의 컬럼을 객체의 필드로 매핑합니다.
데이터베이스 독립성
데이터베이스에 종속되지 않으며, 다양한 데이터베이스 시스템을 지원합니다.
데이터베이스 변경 시 코드 수정이 최소화됩니다.
투명한 지속성
데이터베이스에 접근하는 코드를 작성하지 않고도 객체의 상태를 데이터베이스에 자동으로 동기화합니다.
엔티티 객체의 생명주기를 관리합니다.
HQL (Hibernate Query Language)
객체 지향 쿼리 언어로, SQL과 유사하지만 테이블이 아닌 엔티티 객체를 대상으로 쿼리를 수행합니다.
복잡한 조회, 집계 등을 객체 지향적으로 표현할 수 있습니다.
캐싱
1차 캐시와 2차 캐시를 지원하여 성능을 최적화합니다.
자주 조회되는 데이터를 메모리에 저장하여 데이터베이스 접근을 줄입니다.
 
Hibernate의 장점과 단점 
장점
생산성 
복잡한 SQL 쿼리를 자동으로 생성하여 데이터베이스 접근 코드를 단순화합니다.
유지보수성 
객체 모델을 기반으로 데이터베이스 스키마를 자동으로 생성 및 업데이트할 수 있어 유지보수가 용이합니다.
이식성 
다양한 데이터베이스 시스템을 지원하여 데이터베이스 변경 시 코드 수정이 최소화됩니다.
단점
학습 곡선 
Hibernate의 다양한 기능과 설정을 이해하는 데 시간이 필요할 수 있습니다.
성능 오버헤드 
자동화된 작업으로 인해 일부 성능 오버헤드가 발생할 수 있습니다. 이는 캐싱 및 튜닝을 통해 최적화할 수 있습니다.
 
엔티티 클래스 작성
Hibernate에서 객체와 테이블을 매핑하는 방법을 보여드리겠습니다. 
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;

    // getters and setters
}
@Entity 어노테이션
클래스 레벨에 적용되며, 해당 클래스가 JPA 엔티티임을 나타냅니다.
@Entity가 붙은 클래스는 데이터베이스 테이블과 매핑되며, Hibernate가 관리합니다.
@Id 어노테이션
엔티티 클래스의 필드 중 기본 키(Primary Key)로 사용될 필드에 적용됩니다.
기본 키는 각 엔티티 인스턴스를 고유하게 식별하는 역할을 합니다.
예시에서는 id 필드가 기본 키로 설정되어 있습니다.
@GeneratedValue 어노테이션
기본 키 값의 생성 전략을 지정하는 데 사용됩니다.
필드와 컬럼 매핑
기본적으로 Hibernate는 필드 이름과 동일한 이름의 데이터베이스 컬럼과 매핑합니다.
따라서 name 필드는 "name" 컬럼과 매핑되고, email 필드는 "email" 컬럼과 매핑됩니다.
 
Hibernate 설정 파일 (hibernate.cfg.xml)
Hibernate 설정 파일인 hibernate.cfg.xml의 내용은 아래와 같습니다. 이 파일은 Hibernate의 동작을 구성하고 데이터베이스 연결 설정을 정의하는 데 사용됩니다.
<!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"
        "http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
        <property name="hibernate.connection.driver_class">com.mysql.cj.jdbc.Driver</property>
        <property name="hibernate.connection.url">jdbc:mysql://localhost:3306/mydatabase</property>
        <property name="hibernate.connection.username">myuser</property>
        <property name="hibernate.connection.password">mypassword</property>
        <property name="hibernate.hbm2ddl.auto">update</property>
        <property name="hibernate.show_sql">true</property>
        <property name="hibernate.format_sql">true</property>

        <!-- List of annotated classes -->
        <mapping class="com.example.User"/>
    </session-factory>
</hibernate-configuration>

데이터베이스 연동 코드
아래 예시는 Hibernate를 사용하여 데이터베이스와 연동하는 기본적인 흐름, 즉 Hibernate가 객체와 관계형 데이터베이스 간의 매핑을 처리하는 코드입니다. SessionFactory를 생성하고, Session을 열어 트랜잭션을 시작한 후, 엔티티 객체를 생성 및 저장하고, 트랜잭션을 커밋한 후에 Session을 종료하는 과정을 나타냈습니다. 
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

public class Main {
    public static void main(String[] args) {
        // Hibernate 설정 파일로부터 SessionFactory 생성
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();

        // Session을 사용하여 데이터베이스 작업 수행
        Session session = sessionFactory.openSession();
        session.beginTransaction();

        User user = new User();
        user.setName("John Doe");
        user.setEmail("john.doe@example.com");

        session.save(user);

        session.getTransaction().commit();
        session.close();
    }
}

 
 
JPA(Java Persistence API)
JPA(Java Persistence API)는 자바 애플리케이션에서 객체 관계 매핑(ORM)을 사용하여 관계형 데이터베이스를 쉽게 다룰 수 있도록 해주는 자바 API입니다. JPA를 사용하면 자바 객체와 데이터베이스 테이블 간의 매핑을 정의하고, 데이터베이스의 데이터를 객체 형태로 다룰 수 있게 됩니다. 이를 통해 데이터베이스에 접근하는 코드를 단순화하고, 객체 지향적인 접근 방식을 유지할 수 있습니다.
 
JPA의 주요 구성 요소
Entity
데이터베이스 테이블에 매핑되는 자바 클래스입니다. 각 엔티티 클래스는 @Entity 어노테이션으로 표시되며, 클래스의 필드는 테이블의 컬럼에 매핑됩니다.
Entity Manager
엔티티를 생성, 수정, 삭제, 조회할 수 있는 인터페이스입니다. EntityManager는 JPA 컨텍스트에서 엔티티 객체를 관리합니다.
Persistence Unit
 JPA 설정 정보가 포함된 단위입니다. persistence.xml 파일에 정의되며, 데이터베이스 연결 정보와 엔티티 클래스를 설정합니다.
 
JPA는 구현체를 제공하지 않는 표준 명세로, 대표적인 구현체로는 Hibernate, EclipseLink, OpenJPA 등이 있습니다. 이러한 구현체는 JPA 인터페이스를 구현하여 실제 데이터베이스 연동 작업을 수행합니다.
 
JPA의 주요 메서드
persist(Object entity) 새로운 엔티티를 데이터베이스에 저장합니다.
find(Class<T> entityClass, Object primaryKey) 
주어진 기본 키로 데이터베이스에서 엔티티를 조회합니다.
merge(Object entity) 데이터베이스에 이미 존재하는 엔티티를 업데이트합니다.
remove(Object entity) 엔티티를 데이터베이스에서 삭제합니다.
createQuery(String qlString) JPQL 쿼리를 실행하기 위해 Query 객체를 생성합니다.
createNamedQuery(String name) 
미리 정의된 네임드 쿼리를 실행하기 위해 Query 객체를 생성합니다.
getTransaction() 현재 트랜잭션을 반환합니다.
getReference(Class<T> entityClass, Object primaryKey)
프록시 객체를 사용하여 지연 로딩 방식으로 엔티티를 조회합니다.
flush() 현재 영속성 컨텍스트의 변경 사항을 데이터베이스에 반영합니다.
clear() 영속성 컨텍스트를 초기화합니다.
close(): 엔티티 매니저를 닫습니다.
 
JPA로 엔티티 생성, 조회, 업데이트, 삭제하기
아래는 JPA를 사용하여 데이터베이스와 연동하는 방법입니다. User 엔티티를 정의하고, EntityManager를 사용하여 엔티티를 생성, 조회, 업데이트, 삭제하는 작업을 수행합니다.
 
User 엔티티 클래스
javaCopy code
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;

@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
User 엔티티 클래스는 @Entity 어노테이션을 사용하여 JPA 엔티티로 표시됩니다. @Id 어노테이션은 엔티티의 기본 키를 나타내며, @GeneratedValue를 사용하여 기본 키 생성 전략을 지정합니다.
JPA 연동 코드
javaCopy code
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class Main {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("my-persistence-unit");
        EntityManager em = emf.createEntityManager();

        // 엔티티 생성 및 저장
        em.getTransaction().begin();
        User user = new User();
        user.setName("John Doe");
        user.setEmail("john.doe@example.com");
        em.persist(user);
        em.getTransaction().commit();

        // 엔티티 조회
        User foundUser = em.find(User.class, user.getId());
        System.out.println("Found User: " + foundUser.getName());

        // 엔티티 업데이트
        em.getTransaction().begin();
        foundUser.setEmail("john.newemail@example.com");
        em.merge(foundUser);
        em.getTransaction().commit();

        // 엔티티 삭제
        em.getTransaction().begin();
        em.remove(foundUser);
        em.getTransaction().commit();

        // 엔티티 매니저 및 팩토리 종료
        em.close();
        emf.close();
    }
}
EntityManagerFactory는 JPA의 핵심 클래스 중 하나로, 데이터베이스 연결 및 엔티티 매니저 생성을 관리합니다. EntityManager는 데이터베이스와의 상호작용을 담당하는 주요 인터페이스입니다.
 
위 예제에서는 다음과 같은 작업을 수행합니다:
persist(Object entity): 새로운 User 엔티티를 데이터베이스에 저장합니다.
find(Class<T> entityClass, Object primaryKey): 데이터베이스에서 User 엔티티를 기본 키를 통해 조회합니다.
merge(Object entity): 기존 User 엔티티를 수정하고 데이터베이스에 반영합니다.
remove(Object entity): 데이터베이스에서 User 엔티티를 삭제합니다.
각 작업은 EntityManager의 트랜잭션을 통해 수행되며, 트랜잭션은 반드시 begin()과 commit()을 호출하여 관리합니다.
 
 
Spring Data JPA
Spring에서 사용할 때에는 SimpleJpaRepository 등 Spring Data JPA에서 사용하는 Repository 구현체를 사용합니다. 
import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<User, Long> {
}
 
아래와 같이 정의하면 자연스럽게 구현체가 생겨서 Service Layer에서 쓸 수 있습니다. 
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
public class UserService {
    @Autowired
    private UserRepository userRepository;

    public User saveUser(User user) {
        return userRepository.save(user);
    }

    public Optional<User> getUserById(Long id) {
        return userRepository.findById(id);
    }

    public List<User> getAllUsers() {
        return userRepository.findAll();
    }

    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
 


[기타 참고]
https://ittrue.tistory.com/253

프레임워크(Framework)/JPA
JPA란 무엇인가? - JPA 동작, 사용하는 이유 - Java Persistence API
잇트루            2022. 11. 26. 23:33

본 내용은 온라인 강의 사이트 인프런의 김영한 님의 강의 내용이 포함되어 있습니다.'자바 ORM 표준 JPA 프로그래밍 - 기본편'
 
□ JPA란? (Java Persistence API)
- JPA는 자바에서 사용하는 ORM(Object-Relational Mapping) 기술 표준이다.
- JPA는 자바 애플리케이션과 JDBC 사이에서 동작하며, 자바 인터페이스로 정의되어 있다.
 
▷ ORM: Object-Relational Mapping(객체 관계 매핑)
- 객체와 관계형 데이터베이스의 데이터를 매핑하는 기술
- ORM 프레임워크가 객체와 데이터베이스 중간에서 매핑
- 객체와 테이블을 매핑하여 패러다임 불일치 문제를 해결
 
□ JPA의 동작
JPA는 애플리케이션과 JDBC 사이에서 동작한다.

- JPA는 JDBC API를 사용하여 데이터베이스와 데이터를 주고받게 된다.

▷ 저장
- MemberDAO 클래스를 통해 persist()를 실행하면, JPA가 Entity 객체를 분석하여 SQL문을 생성한다.
- JDBC API를 사용하여 DB에 생성된 INSERT SQL을 보내게 된다.
- 이 과정에서 JPA는 객체와 데이터베이스 테이블의 패러다임 불일치를 해결한다.

▷ 조회
- MemberDAO 클래스를 통해 find(id)를 실행하면, JPA는 SELECT SQL을 생성한다.
- JDBC API를 사용하여 생성된 SELECT SQL을 보낸다.
- DB에서 반환된 정보를 ResultSet 매핑을 통해 객체로 변환해 준다.
- 이 과정에서도 패러다임 불일치 문제를 해결해 준다.

□ JPA를 사용하는 이유
- 기존의 개발 방식은 SQL 중심적인 개발이었다.
- JPA를 사용하면 객체 중심으로 애플리케이션 개발이 가능하다.
 
▷ 생산성(CRUD)
- JPA를 사용하면 기본적으로 생산성이 높아진다. JDBC 방식의 경우 SQL 쿼리문을 직접 작성해야 데이터베이스에 접근할 수 있다.
- 하지만, JPA는 쿼리문을 별도로 작성할 필요가 없다.
- 다음과 같이 간단한 메서드를 통해 CRUD가 가능하다.
  저장 : jpa.persist(member)
  조회 : Member member = jpa.find(memberId)
  수정 : member.setName(”변경할 이름”)
  삭제 : jpa.remove(member)
 
▷ 유지보수
- 기존에는 엔티티 클래스의 필드가 변경되면 모든 SQL을 수정해야 했다.
- JPA에서는 쿼리를 직접 작성하지 않기 때문에 필드가 변경되더라도 매핑 정보만 잘 연결하면 SQL문은 자동으로 작성된다.
 
▷ 패러다임의 불일치 문제 해결
: 상속, 연관관계, 객체 그래프 탐색, 비교 등의 설계 차이로 인해 발생하는 패러다임 불일치 문제를 해결한다.

- 객체는 상속 구조를 만들 수 있으며, 다형성 구현이 가능하지만, 관계형 데이터베이스의 테이블은 상속이라는 개념이 존재하지 않는다.
- 객체는 참조를 통해 관계를 표현하며 방향을 가지고 있으나, 관계형 데이터베이스는 외래 키를 통해 관계를 표현하며, 방향이 존재하지 않는다. 
   또한, 다대다 관계 문제를 해결하기 위해 조인을 사용한다.
- 이 외에도 다양한 패러다임 불일치 문제가 존재

 
이와 같이 객체와 데이터베이스는 서로 다른 목적을 가지고 설계되었기 때문에 매핑하는 데 있어 여러 문제가 발생한다. 
하지만 JPA를 사용하면 이러한 문제를 모두 해결할 수 있다.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------

출처: https://ittrue.tistory.com/254 [IT is True:티스토리]

프레임워크(Framework)/JPA
[JPA] 영속성 컨텍스트(Persistence Context)란? - 개넘 정리 및 사용법
          
잇트루            2022. 11. 27. 00:46

본 내용은 온라인 강의 사이트 인프런의 김영한 님의 강의 내용이 포함되어 있습니다.'자바 ORM 표준 JPA 프로그래밍 - 기본편'

□ 영속성 컨텍스트란?
- ORM은 객체와 데이터베이스 테이블의 매핑을 통해 엔티티 클래스 객체 안에 포함된 정보를 테이블에 저장하는 기술이다.
- JPA에서는 테이블과 매핑되는 엔티티 객체 정보를 영속성 컨텍스트를 통해 애플리케이션 내에서 오래 지속되도록 보관한다.
 
▷ 영속성 컨텍스트는 JPA를 이해하는데 가장 중요한 용어이다.
- 영속성 컨텍스트는 논리적인 개념
- 눈에 보이지 않음
- 엔티티 매니저를 통해 영속성 컨텍스트에 접근
 
엔티티의 생명주기










- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
- 영속(managed) : 영속성 컨텍스트에 관리되는 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(remove) : 삭제된 상태
 
비영속
객체를 생성한 상태
Member member = new Member();
member.setId("member1");
member.setUsername("홍길동");
 
영속
EntityManager em = EntityManagerFactory.createEntityManager();
em.getTransaction().begin();

Member member = new Member();
member.setId("member1");
member.setUsername("홍길동");

// 객체를 영속성 컨텍스트에 저장(영속)
em.persist(member);
 
준영속
// member 엔티티를 영속성 컨텍스트에서 분리(준영속)
em.detach(member);
 
삭제
// 객체를 삭제한 상태(삭제)
em.remove(member);
 
▷ 영속성 상태의 장점
- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지
- 지연 로딩

 
영속성 컨텍스트(Persistence Context)를 그림으로 표현하면 다음과 같이 나타낼 수 있다.
   영속성 컨텍스트 (Persistence Context)
       1차 캐시                쓰기 지연 SQL 저장소
        엔티티1
        엔티티2                         ?
           ...
 
영속성 컨텍스트에는 1차 캐시 영역과 쓰기 지연 SQL 저장소 영역이 있다.
JPA API 중에서 엔티티 정보를 영속성 컨텍스트에 저장하는 API를 사용하면, 영속성 컨텍스트의 1차 캐시에 엔티티 정보가 저장된다.

// 엔티티를 생성한 상태(비영속)
Member member = new Member();
member.setId("member1");
member.setUsername("홍길동");

// 객체를 영속성 컨텍스트에 저장(영속)
em.persist(member);
 
영속성 컨텍스트의 조회 - find()
영속성 컨텍스트에 저장된 데이터나 데이터베이스에 저장된 데이터를 조회하기 위해서는 EntityManager의 find() 메서드를 통해 조회할 수 있다.
 
1차 캐시에서 조회하는 경우
Member member = new Member();
member.setId("member1");
member.setUsername("홍길동");

em.persist(member);

Member findMember = em.find(Member.class, "member1");

- 객체를 생성한 후, em.persist(member)를 통해 1차 캐시에 저장한다.
- 1차 캐시에 저장된 상태에서 find() 메서드를 통해 조회할 경우 1차 캐시에 저장된 데이터를 그대로 조회한다.

 
데이터베이스에서 조회하는 경우
Member findMember2 = em.find(Member.class, "member2");

- find() 메서드는 먼저 영속성 컨텍스트의 1차 캐시에 조회할 엔티티가 존재하는지 먼저 탐색한다.
- 만약, 1차 캐시에 존재하지 않을 경우 데이터베이스에서 조회한 뒤, 1차 캐시에 저장한다.
- 이후 조회 데이터를 반환한다.

 
같은 데이터를 2번 조회할 경우
Member findMember1 = em.find(Member.class, "member1");
Member findMember2 = em.find(Member.class, "member1");

System.out.println(findMember1 == findMember2);

- 먼저, member1을 찾기 위해 1차 캐시를 찾는다.
- 1차 캐시에 존재하지 않아 데이터베이스에서 조회한다.
- 이후 1차 캐시에 저장한 뒤 member1을 반환한다.
- findMember2가 실행될 때 1차 캐시에서 데이터를 조회한다.
- findMember1에 의해 1차 캐시에 저장된 member1을 반환한다.
- 즉, 같은 데이터를 2번 조회할 경우 조회 쿼리는 1회만 실행된다.
 
또한, findMember1과 findMember2를 비교하면, true로 같은 데이터임을 나타낸다.
이는 영속 엔티티의 동일성을 보장한다는 뜻이다.

// 출력
true
 
엔티티 등록 - 쓰기 지연
엔티티 매니저는 데이터 변경 시 반드시 트랜잭션을 시작해야 한다.
EntityManager em = EntityManagerFactory.createEntityManager();
EntityTransaction tx = em.getTransaction(); // 트랜잭션

// 트랜잭션 시작
tx.begin();

// 비영속
Member member = new Member();
member.setId("member1");
member.setUsername("홍길동");

// 영속
em.persist(member);

// 엔티티 등록
tx.commit();

em.persist(member); : member 엔티티를 영속 컨텍스트에 저장하지만, 데이터베이스에는 반영되지 않는다.
tx.commit(); : 트랜잭션을 커밋하는 순간 데이터베이스에 INSERT SQL을 보내 저장하게 된다.
persist()를 실행할 때, 영속 컨텍스트의 1차 캐시에는 member 엔티티가 저장되고, 쓰기 지연 SQL 저장소에는 member 엔티티의 INSERT SQL 쿼리문이 저장된다.
txcommit()을 실행하는 순간 쓰기 지연 SQL 저장소에 저장된 INSERT SQL 쿼리를 보내 데이터베이스에 저장하는 것이다.

 
따라서, 여러 개의 엔티티를 생성하고 persist를 하더라도, commit()을 하기 전에는 데이터베이스에 저장되지 않는다. 이를 쓰기 지연이라 하며, 영속 컨텍스트의 장점이다.
 
엔티티 수정 - 변경 감지
EntityManager em = EntityManagerFactory.createEntityManager();
EntityTransaction tx = em.getTransaction(); // 트랜잭션

// 트랜잭션 시작
tx.begin();

// member 조회
Member member = em.find(Member.class, "member");
member.setUsername("hello");
member.setAge("20");

// 엔티티 등록
tx.commit();

엔티티의 수정은 set메서드를 통해서 변경한 뒤, 별다른 로직 없이 트랜잭션 커밋을 하는 순간에 업데이트된다.
이것이 가능한 이유는 바로 변경 감지(Dirty Checking) 기능을 제공하기 때문이다.
영속 컨텍스트의 1차 캐시에는 member의 초기 데이터가 저장되어 있을 것이다.
이후 set 메서드를 통해 데이터를 변경한다.
트랜잭션 커밋 시 flush()가 발생하면서 1차 캐시에서 엔티티와 스냅샷을 비교하여 변경에 대한 감지를 한다.
이후 SQL UPDATE 쿼리를 생성하여 쓰기 지연 SQL 저장소에서 쿼리를 보낸다.
이로써 DB에 저장된 데이터를 수정하게 된다.

 
엔티티 삭제
Member member = em.find(Member.class, "member");

em.remove(member); // 엔티티 삭제

엔티티 삭제는 remove() 메서드를 통해 데이터를 삭제할 수 있다.
영속성 컨텍스트와 데이터베이스에서 모두 제거된다.

 
플러시 - flush()
트랜잭션 커밋을 실행하면 변경 내용을 데이터베이스에 반영하게 된다.
트랜잭션 커밋이 일어날 때 플러시도 함께 발생하여 데이터베이스에 반영할 수 있는 것이다.
즉, 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것이다.
 
플러시 발생 시

변경 감지(dirty checking)
수정된 엔티티 쓰기 지연 SQL 저장소에 등록
쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

 
 
영속성 컨텍스트를 플러시 하는 방법

em.flush() - 직접 호출(테스트에 사용)
tx.commit() - 트랜잭션 커밋을 통한 자동 호출
JPQL 쿼리 실행 - 플러시 자동 호출

 
 
직접 호출 예시
Member member = new Member(200L, "member200");
em.persist(member);

em.flush(); // 강제 호출
System.out.println("------------");

tx.commit();

flsuh()는 변경을 감지하여 데이터베이스에 반영하는 역할을 한다.
따라서 이후에 commit()이 발생해도 쿼리를 다시 실행하지는 않는다.
또한, flush()를 한다고 해서 1차 캐시의 내용이 사라지지 않는다.

 
JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

//중간에 JPQL 실행
query = em.createQuery("select m from Member m", Member.class);
List<Member> members= query.getResultList();
위 코드와 같이 persist()를 실행한 뒤, JPQL로 쿼리를 보내면 members에는 데이터베이스로부터 결과를 얻을 수 없을 것이다.
쿼리 발생 이전에 데이터베이스에 반영하는 flush()가 호출되어야 하기 때문이다.
직접 플러시를 호출하거나, 쿼리 이전에 commit()을 해야 한다.
이러한 문제점을 방지하기 위해 중간에 JPQL이 실행하게 되면 자동으로 플러시를 호출하여 JPQL 쿼리를 반영할 수 있도록 하는 것이다.
 
 
플러시 모드 옵션

FlushModeType.AUTO : (기본 값) 커밋이나 쿼리를 실행할 때 플러시
FlushModeType.COMMIT : 커밋할 때만 플러시

em.setFlushMode(FlushModeType.COMMIT)
커밋이나 JPQL 쿼리 등을 실행할 때 자동으로 플러시 되는 것을 방지하기 위해 플러시 모드를 설정할 수 있다.
변경된 것과는 아무런 관련이 없는 데이터베이스 테이블에 쿼리를 보내고자 할 때 종종 사용된다.
 
플러시에 대한 오해

플러시는 영속성 컨텍스트를 비우지 않는다.
영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 역할이다.
플러시의 개념은 트랜잭션이라는 작업 단위에 중요 → 커밋 직전에만 동기화하면 된다.

 
준영속 상태
em.persist() 또는 em.find()를 실행하면 해당 데이터는 영속 컨텍스트에 저장되어 영속 상태가 된다.
준영속 상태는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태를 말한다.
준영속 상태에서는 영속성 컨텍스트가 제공하는 기능을 사용하지 못하게 된다.
준영속 상태로 만드는 방법

em.detach(entity) : 특정 엔티티만 준영속 상태로 변환
em.clear() : 영속성 컨텍스트를 완전히 초기화
em.close() : 영속성 컨텍스트를 종료


-------------------------------------------------------------------------------------------------------------------------------------
출처: https://ittrue.tistory.com/255 [IT is True:티스토리]

프레임워크(Framework)/JPA
[JPA] 객체와 테이블 간의 매핑 - 엔티티 매핑(Entity Mapping) - 1
잇트루            2022. 11. 28. 21:35

본 내용은 온라인 강의 사이트 인프런의 김영한 님의 강의 내용이 포함되어 있습니다.'자바 ORM 표준 JPA 프로그래밍 - 기본편'

Intro
엔티티 매핑과 연관관계 매핑
JPA를 이용해 데이터베이스의 테이블과 상호 작용(데이터 저장, 수정, 조회, 삭제 등) 하기 위해 먼저 해야 하는 작업은 데이터베이스 테이블과 엔티티 클래스 간의 매핑 작업이다.
 
엔티티 매핑 작업은 객체와 테이블 간의 매핑, 기본키 매핑, 필드와 컬럼 간의 매핑, 엔티티 간의 연관 관계 매핑 등으로 나눌 수 있다.
 
특히 엔티티 간의 연관 관계 매핑은 JPA에서 가장 어려우면서도 중요하다.
 
엔티티 매핑

객체와 테이블 간의 매핑 : @Entity, @Table
필드와 컬럼 간의 매핑 : @Column
기본 키 매핑 : @Id
연관관계 매핑 : @ManyToOne, @JoinColumn, @OneToMany, @ManyToMany

 
엔티티와 테이블 간의 매핑 - @Entity, @Table
@Entity
@Entity 매핑 어노테이션을 통해 엔티티 클래스와 테이블을 매핑할 수 있다.
@Entity가 붙은 클래스는 JPA가 관리하게 되며, 엔티티라 부른다.
@Entity
public class Member {
}

@Entity(name = "Member2")
public class Member {
}
속성

name

엔티티 이름을 설정할 수 있다.
기본 값으로 클래스의 이름을 그대로 사용한다.
같은 클래스 이름이 없으면 가급적 기본값을 사용한다.



 
 
주의할 점

기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
final 클래스, enum, interface, inner 클래스에 사용 X
저장할 필드에 final 사용 X

 
@Table
@Table은 엔티티와 매핑할 테이블을 지정한다.
@Entity
@Table
public class Member {
    @Id
    private Long memberId;
}
속성

name

테이블 이름을 설정할 수 있다. 기본 값으로 클래스의 이름을 테이블로 사용한다.
주로 테이블 이름이 클래스 이름과 달라야 할 경우에 사용


catalog

데이터베이스 catalog와 매핑한다.


schema

데이터베이스 schema와 매핑한다.


uniqueConstraints(DDL)

DDL 생성 시에 유니크 제약 조건을 생성한다.



 
 
주의할 점

@Table 어노테이션은 필수가 아니지만, @Eintity 어노테이션과 @Id 어노테이션은 필수이다.
@Eintity와 @Id는 함께 사용해야 한다. @Id 어노테이션이 없으면 AnnotationException 예외가 발생한다.
파라미터가 없는 기본 생성자는 필수로 추가해야 한다.

Spring Data JPA의 기술을 적용할 때, 기본 생성자가 없는 경우 에러가 발생할 수 있기 때문



-------------------------------------------------------------------------------------------------------------------------------------
출처: https://ittrue.tistory.com/256 [IT is True:티스토리]
프레임워크(Framework)/JPA
          [JPA] 기본 키 매핑 - 엔티티 매핑(Entity Mapping) - 2
          
            잇트루
            2022. 11. 29. 20:25
          
        
      
    

    
    
      




     (adsbygoogle = window.adsbygoogle || []).push({});


    if(window.observeAdsenseUnfilledState !== undefined){ observeAdsenseUnfilledState(); }



                    
        
  
    반응형
    
    
    (adsbygoogle = window.adsbygoogle || []).push({});
  

        

            본 내용은 온라인 강의 사이트 인프런의 김영한 님의 강의 내용이 포함되어 있습니다.'자바 ORM 표준 JPA 프로그래밍 - 기본편'

 

자바 ORM 표준 JPA 프로그래밍 - 기본편 - 인프런 | 강의
JPA를 처음 접하거나, 실무에서 JPA를 사용하지만 기본 이론이 부족하신 분들이 JPA의 기본 이론을 탄탄하게 학습해서 초보자도 실무에서 자신있게 JPA를 사용할 수 있습니다., - 강의 소개 | 인프런
www.inflearn.com


 
Intro
엔티티 매핑과 연관관계 매핑
JPA를 이용해 데이터베이스의 테이블과 상호 작용(데이터 저장, 수정, 조회, 삭제 등) 하기 위해 먼저 해야 하는 작업은 데이터베이스 테이블과 엔티티 클래스 간의 매핑 작업이다.
 
엔티티 매핑 작업은 객체와 테이블 간의 매핑, 기본키 매핑, 필드와 컬럼 간의 매핑, 엔티티 간의 연관 관계 매핑 등으로 나눌 수 있다.
 
특히 엔티티 간의 연관 관계 매핑은 JPA에서 가장 어려우면서도 중요하다.
 
엔티티 매핑

객체와 테이블 간의 매핑 : @Entity, @Table
필드와 컬럼 간의 매핑 : @Column
기본 키 매핑 : @Id
연관관계 매핑 : @ManyToOne, @JoinColumn, @OneToMany, @ManyToMany

 
기본키 매핑 - @Id
데이터베이스의 테이블에 기본키 설정은 필수이다.
JPA에서는 기본적으로 @Id 어노테이션을 추가한 필드가 기본 키 컬럼이 된다.
 
JPA 기본키 생성 전략

기본키 직접 할당 : 애플리케이션 코드 상에서 기본키를 직접 할당해 주는 방식이다.
기본키 자동 생성

IDENTITY

기본키 생성을 데이터베이스에 위임하는 전략이다.
데이터베이스에서 기본키를 생성해주는 대표적이 방식은 MySQL의 AUTO_INCREMENT 기능을 통해 자동 증가 숫자를 기본키로 사용하는 방식이 있다.


SEQUENCE

데이터베이스에서 제공하는 시퀀스를 사용해서 기본키를 생성하는 전략이다.


TABLE

별도의 키 생성 테이블을 사용하는 전략이다.





 
기본 키 직접 할당
기본 키를 직접 할당하는 경우 @Id만 사용한다.
@NoArgsConstructor
@Getter
@Setter
public class Member {
    @Id // 기본키 직접 할당
    private Long memberId;

    public Member(Long memberId) {
        this.memberId = memberId;
    }
}
엔티티 클래스의 기본키를 지정할 필드에 @Id 어노테이션을 붙이는 것으로 기본키를 직접 할당할 수 있다.
 
@Configuration
public class JpaIdDirectMappingConfig {
    private EntityManager em;
    private EntityTransaction tx;

    @Bean
    public CommandLineRunner testJpaSingleMappingRunner(EntityManagerFactory emFactory){
        this.em = emFactory.createEntityManager();
        this.tx = em.getTransaction();

        return args -> {
            tx.begin();
            em.persist(new Member(1L));  // 데이터 저장
            tx.commit();
            Member member = em.find(Member.class, 1L);

            System.out.println("# memberId: " + member.getMemberId());
        };
    }
}
기본키 직접 할당 이후 데이터를 저장할 수 있다.
 
IDENTITY 전략
IDENTITY는 기본 키 생성하는 것을 데이터베이스에 위임하는 전략이다.
MySQL 데이터베이스에 사용하는 방식으로 AUTO_INCREMENT와 동일하다.
@NoArgsConstructor
@Getter
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // IDENTITY
    private Long memberId;

    public Member(Long memberId) {
        this.memberId = memberId;
    }
}
IDENTITY 기본키 생성 전략을 설정하기 위해 @GeneratedValue 어노테이션의 strategy 속성을 GenerationType.IDENTITY로 지정해야 한다.
 
이후 데이터베이스에서 기본키를 대신 생성하게 된다.
@Configuration
public class JpaIdIdentityMappingConfig {
    private EntityManager em;
    private EntityTransaction tx;

    @Bean
    public CommandLineRunner testJpaSingleMappingRunner(EntityManagerFactory emFactory){
        this.em = emFactory.createEntityManager();
        this.tx = em.getTransaction();

        return args -> {
            tx.begin();
            em.persist(new Member()); // 기본키를 따로 지정하지 않고 저장
            tx.commit();
            Member member = em.find(Member.class, 1L); // memberId로 조회

            System.out.println("# memberId: " + member.getMemberId());
        };
    }
}
해당 데이터를 저장할 때, 별도의 기본키 값을 할당하지 않아도 데이터베이스에서 자동으로 기본키를 할당하고 저장해 준다.
 
참고 사항
IDENTITY 전략은 기본 키 생성을 데이터베이스에 위임하기 때문에 데이터베이스에 저장이 되어야만 기본 키가 생성된다.
하지만, JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL을 실행하게 된다.

AUTO_INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있다.

 
이러한 문제를 해결하기 위해 IDENTITY 전략에서는 persist()가 실행하는 시점에 즉시 INSERT SQL을 실행하고 DB에서 식별자를 조회하도록 하고 있다.
Member member = new Member();
member.setUsername("Hello");

System.out.println("member.getId() = " + member.getId());
em.persist(member);
System.out.println("member.getId() = " + member.getId());

tx.commit(); // 보통은 커밋 시에 INSERT SQL 실행
// 쿼리 실행 시점 출력
...
member.getId() = null
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (id, name) 
        values
            (default, ?)
member.getId() = 1
...
 
SEQUENCE 전략
SEQUENCE는 데이터베이스 시퀀스 오브젝트를 사용하여 기본 키를 자동으로 생성하는 전략이다.
Oracle 데이터베이스에서 사용하는 방식이다.
@NoArgsConstructor
@Getter
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)  // (1)
    private Long memberId;

    public Member(Long memberId) {
        this.memberId = memberId;
    }
}
SEQUENCE 전략을 사용하기 위해서는 @GeneratedValue 어노테이션의 strategy 속성을 GenerationType.SEQUENCE로 지정해야 한다.
 
이는 데이터베이스 시퀀스를 사용하여 기본키를 생성하게 된다.
@Configuration
public class JpaIdIdSequenceMappingConfig {
    private EntityManager em;
    private EntityTransaction tx;

    @Bean
    public CommandLineRunner testJpaSingleMappingRunner(EntityManagerFactory emFactory){
        this.em = emFactory.createEntityManager();
        this.tx = em.getTransaction();

        return args -> {
            tx.begin();
            em.persist(new Member());  // 기본키를 따로 지정하지 않고 저장
            Member member = em.find(Member.class, 1L); // memberId로 조회
            System.out.println("# memberId: " + member.getMemberId());
            tx.commit();

        };
    }
}
IDENTITY 전략과 유사하게 기본키를 지정하지 않고도 Member 객체를 생성하면서 memberId를 통해 조회할 수 있다.
하지만 SEQUENCE 전략은 엔티티가 영속성 컨텍스트에 저장되기 전에 데이터베이스 시퀀스에서 기본키에 해당하는 값을 제공하게 된다.
 
@SequenceGenerator
@SequenceGenerator를 통해 테이블마다 다른 시퀀스로 관리할 수 있다.
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ", //매핑할 데이터베이스 시퀀스 이름
        initialValue = 1, allocationSize = 1)
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "MEMBER_SEQ_GENERATOR")
    private Long memberId;

    public Member(Long memberId) {
        this.memberId = memberId;
}

name : 식별자 생성기 이름을 지정하는 것으로 필수로 작성해야 한다.
sequenceName : 데이터베이스에 등록되어 있는 시퀀스 이름을 지정한다. 지정하지 않을 시 기본 값으로 hinernate_sequence라는 이름을 가지게 된다.
initialValue : DDL 생성 시에만 사용되는 속성으로, 시퀀스 DDL을 생성할 때 처음 시작하는 수를 지정한다.
allocationSize : 시퀀스 한 번 호출에 증가하는 수를 지정하는 속성으로 기본값은 50을 가진다. 데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다.
catalog, schema : 데이터베이스 catalog와 schema의 이름을 지정한다.

 
참고사항
SEQUENCE 전략은 데이터베이스의 시퀀스 오브젝트를 사용하기 때문에 데이터베이스로부터 시퀀스 값을 가져와야 한다.
 
따라서 SEQUENCE 전략은 persist() 실행 시 데이터베이스로부터 증가된 시퀀스 값을 가져올 수 있도록 쿼리문이 실행된다. 그 이후 commit이 실행되는 시점에 쿼리문을 보낸다.
member.setUsername("Hello");

System.out.println("member.getId() = " + member.getId());
em.persist(member); // 시퀀스 할당 시점
System.out.println("member.getId() = " + member.getId());

tx.commit(); // SQL 실행 시점
// 쿼리 생성 시점 출력
member.getId() = null
Hibernate: 
    call next value for MEMBER_SEQ // 시퀀스 증가 쿼리
member.getId() = 1
Hibernate: 
    /* insert hellojpa.Member
        */ insert 
        into
            Member
            (name, id) 
        values
            (?, ?)
11월 16, 2022 9:31:10 오후 org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl$PoolState stop
INFO: HHH10001008: Cleaning up connection pool [jdbc:h2:tcp://localhost/~/test]

Process finished with exit code 0
persist()를 실행할 때마다 데이터베이스에 시퀀스 값을 증가시킬 경우 성능이 느려질 것이다.
이러한 문제를 해결하기 위한 속성이 allocationSize이다.
 
allocationSize는 데이터베이스의 시퀀스 사이즈를 미리 확보하여 메모리에 적재한다.
이후에는 persist()가 여러 번 호출되어도 데이터베이스에 쿼리문을 실행하는 것이 아닌, 메모리에서 시퀀스 값을 증가시키면서 가져올 수 있다.
allocationSize는 성능 최적화를 위해 사용하는 속성이다.
 
TABLE 전략
테이블 전략은 키 생성 전용 테이블을 따로 만들어서 데이터베이스 시퀀스를 흉내 내는 전략이다.
모든 데이터베이스에 적용 가능하다는 장점이 있으나, 성능이 좋지 못하다.
@Entity
@TableGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        table = "MY_SEQUENCES",
        pkColumnValue = "MEMBER_SEQ", allocationSize = 1)
public class Member {
            
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "MEMBER_SEQ_GENERATOR")
    private Long id;

    public Member(Long memberId) {
        this.memberId = memberId;
}
@TableGenerator 속성

name : 식별자 생성기의 이름 (필수 속성)
table : 키 생성 테이블의 이름 (기본값 : hibernate_sequences)
pkColumnName : 시퀀스 컬럼의 이름 (기본값 : sequence_name)
valueColumnNa : 시퀀스 값 컬럼명 (기본값: next_val)
pkColumnValue : 키로 사용할 값 이름 (기본값: 엔티티 이름)
initialValue : 초기 값, 마지막으로 생성된 값이 기준이다. (기본값 : 0)
allocationSize : 시퀀스 한 번 호출에 증가하는 수 (기본값 : 50)
catalog, schema : 데이터베이스 catalog와 schema 이름
uniqueConstraints : 유니크 제약 조건 지정

 
AUTO 전략
AUTO 전략은 @Id 필드에 @GeneratedValue(strategy = GenerationType.AUTO)를 지정하면서 JPA가 데이터베이스의 Dialect에 따라서 적절한 전략을 자동으로 선택하게 하는 방법이다.
 
참고
Dialect는 표준 SQL이 아닌 특정 데이터베이스에 특화된 고유한 기능을 의미한다.
만약, JPA가 지원하지 않는 데이터베이스의 기능을 사용할 경우 Dialect가 처리해준다.
 
권장하는 식별자 전략
기본 키 제약 조건
기본 키는 null 값을 가질 수 없어야 하며 유일한(유니크) 데이터이고 변하면 안 된다.
 
기본 키는 null 값을 가질 수 없으면서 유니크 값으로 제약하는 것은 쉬우나 먼 미래까지 변하지 않고 유지하는 것은 어렵다.
하지만, 이 조건을 모두 만족하는 자연 키는 찾기 어렵다. 따라서 대리 키(대체키)를 사용해야 한다.
 
기본 키 제약 조건을 만족하기 위한 권장하는 방법은 기본키를 Long형 + 대체키 + 키 생성 전략을 사용하는 것이다.


-------------------------------------------------------------------------------------------------------------------------------------



출처: https://ittrue.tistory.com/257 [IT is True:티스토리]

프레임워크(Framework)/JPA
[JPA] 필드와 컬럼 간의 매핑 - 엔티티 매핑(Entity Mapping) - 3
잇트루            2022. 12. 1. 01:10
    
본 내용은 온라인 강의 사이트 인프런의 김영한 님의 강의 내용이 포함되어 있습니다.'자바 ORM 표준 JPA 프로그래밍 - 기본편'

Intro
엔티티 매핑과 연관관계 매핑
JPA를 이용해 데이터베이스의 테이블과 상호 작용(데이터 저장, 수정, 조회, 삭제 등) 하기 위해 먼저 해야 하는 작업은 데이터베이스 테이블과 엔티티 클래스 간의 매핑 작업이다.
 
엔티티 매핑 작업은 객체와 테이블 간의 매핑, 기본키 매핑, 필드와 컬럼 간의 매핑, 엔티티 간의 연관 관계 매핑 등으로 나눌 수 있다.
 
특히 엔티티 간의 연관 관계 매핑은 JPA에서 가장 어려우면서도 중요하다.
 
엔티티 매핑

객체와 테이블 간의 매핑 : @Entity, @Table
필드와 컬럼 간의 매핑 : @Column
기본 키 매핑 : @Id
연관관계 매핑 : @ManyToOne, @JoinColumn, @OneToMany, @ManyToMany

 
 
필드와 컬럼 간의 매핑 - @Column, @Temporal, @Enumerated, @Lob, @Transient
필드와 컬럼 간의 매핑 어노테이션의 종류
@Column : 컬럼 매핑
@Temporal : 날짜 타입 매핑
@Enumerated : enum 타입 매핑
@Lob : BLOB, CLOB 매핑
@transient : 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)
@Entity
@Table
public class Member {

    @Id
    private Long id;

    @Column(name = "name") // 데이터베이스 컬럼 명은 name
    private String username; // 객체는 username

    private Integer age;

    @Enumerated(EnumType.STRING)
    private RoleType roleType;

    @Temporal(TemporalType.TIMESTAMP)
    private Date createdDate;

    @Temporal(TemporalType.TIMESTAMP)
    private Date lastModifiedDate;

    @Lob
    private String description;

    @Transient // 데이터베이스 컬럼에 매핑되지 않음
    private int temp;

    public Member() {
    }

    // Getter
    // ...
    // Setter
    // ...
    }
}
 
@Column
@Column 어노테이션을 통해 필드와 컬럼을 매핑할 수 있다.
만약, @Column 어노테이션이 없고 필드만 정의되어 있다면, JPA는 기본적으로 해당 필드가 테이블의 컬럼과 매핑되는 필드라고 간주하게 된다.
또한, @Column 어노테이션에서 사용되는 속성들을 모두 기본 값으로 적용된다.
@Column(name = "name") // 데이터베이스 컬럼 명은 name
private String username; // 객체는 username
속성

name

필드와 매핑할 테이블의 컬럼 이름을 지정한다.
기본 값은 객체 필드 이름을 그대로 사용한다.


nullable

컬럼에 null 값을 허용할지 여부를 지정한다.
기본 값은 true로 null 값을 허용한다.(false시 not null)
회원의 이메일, 전화번호 등은 필수적으로 입력해야 한다면, 많아 false로 지정하여 사용할 수 있다.


updatable, insertable

컬럼 데이터를 수정 및 변경을 할 수 있는지의 여부를 지정한다.
기본 값은 true로 수정을 허용한다.


unique

하나의 컬럼에 unique 제약 조건을 설정한다.
기본 값은 false로 고유하지 않아도 되는 것을 의미한다.
email, 전화번호 등을 고유하도록 설정해야 한다면, unique 값을 true로 지정하여 사용할 수 있다.


columnDefinition

데이터베이스 컬럼 정보를 직접 줄 수 있다.
ex) varchar(100) default ‘EMPTY’


length

문자 길이 제약조건을 설정할 수 있다.
기본 값은 255이다.
단, String 타입에만 사용한다.


precision, scale

BigDecima 타입에서 사용하는 아주 큰 숫자나 정밀한 소수를 다룰 때 사용한다.
precision : 소수점을 포함한 전체 자릿수(기본값 = 19)
scale : 소수의 자릿수(기본값 = 2)
BigInteger에서도 사용이 가능하다.



 
 
@Column 어노테이션을 사용하지 않거나, 기본값을 사용할 경우 주의 사항
@Column은 기본적으로 nullable=true 이다.
만약, 필드의 데이터 타입이 int, long과 같은 자바의 원시 타입이라면, null 값을 허용하지 않는 속성이 있다.
따라서, nullable이 true여도 null이 저장되지 않는다.
 
 
@Enumerated
자바의 enum 타입을 매핑할 때 사용하는 어노테이션이다.
@Enumerated(EnumType.STRING)
private RoleType roleType;
속성

value

EnumType.ORDINAL : enum 순서를 데이터베이스에 저장(0, 1, 2, …)
EnumType.STRING : enum 이름을 데이터베이스에 저장(ONE, TWO, THREE, …)
기본 값은 EnumType.ORDINAL이다.



 
 
주의 사항
기본 값은 EnumType.ORDINAL이지만 사용하면 안 된다.
다음과 같이 enum 타입이 존재한다고 가정한다.
public enum RoleType {
    USER, ADMIN
}
만약 EnumType.ORDINAL일 경우, USER는 0, ADMIN은 1이라는 Integer 타입의 값이 데이터베이스에 저장될 것이다.
 
이후 요구 사항이 변경되어 GUEST라는 Enum타입이 추가되어 코드를 다음과 같이 수정한다.
public enum RoleType {
    GUEST, USER, ADMIN
}
이 경우, ORDINAL은 순서를 저장하기 때문에, GUEST는 0, USER는 1, ADMIN은 2라는 값으로 저장되게 된다.
하지만, enum 클래스가 수정되기 이전에 USER, ADMIN에는 0, 1이라고 저장되어 있던 값이 변경되지 않는다.
이는 데이터에 치명적인 문제가 생기게 된다.
 
enum 타입을 매핑할 경우 EnumType.String을 사용해야 한다
 
 
@Temporal
날짜 타입(java.util.Date, java.util.Calender)을 매핑할 때 사용하는 어노테이션이다.
@Temporal(TemporalType.TIMESTAMP)
private Date createdDate;

@Temporal(TemporalType.TIMESTAMP)
private Date lastModifiedDate;

속성

value

TemporalType.DATE : 날짜, 데이터베이스 date 타입과 매핑(2022-11-16)
TemporalType.TIME : 시간, 데이터베이스 time 타입과 매핑(12:30:57)
TemporalType.TIMESTAMP : 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(2022-11-16 12:30:57)



 
 
참고로 LocalDate, LocalDateTime을 사용할 경우 생략이 가능하다.
따라서, 최근에는 많이 사용하지 않는 어노테이션이다.
private LocalDate localDate;
private LocalDateTime localDateTime;
 
 
@Lob
데이터베이스의 BLOB, CLOB 타입과 매핑할 때 사용한다.
매핑하는 필드 타입이 문자면 CLOB, 나머지는 BLOB을 매핑한다.

CLOB : String, char[], java.sql.CLOB
BLOB: Byte[], java.sql.BLOB

@Lob
private String description;
@Lob은 별도로 지정할 수 있는 속성이 없다.
 
 
@Transient
@Transient 어노테이션을 지정한 필드는 데이터베이스의 컬럼에 매핑되지 않는다.
따라서, 데이터베이스에 저장이 되지 않는다.
주로 메모리상에서만 사용하거나 보관할 때 사용한다.
@Transient // 데이터베이스 컬럼에 매핑되지 않음
private int temp;
                    
     

        
-------------------------------------------------------------------------------------------------------------------------------------

📂 STUDY/Spring
2024. 4. 20.
[JPA] JPA와 하이버네이트(Hibernate)

Contents
JPA(Java Persistent API)
JPA 사용 예시
JPA의 장점
JPA의 동작 원리
하이버네이트(Hibernate)
Hibernate 주요 특징
Hibernate 사용 방법
  1. 엔티티 클래스 정의
  2. EntityManager 생성
  3. CRUD 작업 수행
참고 : Spring Data JPA


□ JPA(Java Persistent API)

JPA(Java Persistence API) : ORM 기술의 표준 인터페이스

  ORM은 객체와 관계형 데이터베이스를 매핑해 주는 기술이며, JPA는 이를 표준화한 것이다.

그러니까, 자바 애플리케이션에서 관계형 데이터베이스를 사용할 때 이를 객체와 매핑해 주며 사용하기 위한 인터페이스라는 것이다.
따라서 사용하기 위해서는 구현체가 필요하고,  JPA를 구현한 대표적인 프레임워크로는 Hibernate, EclipseLink, DataNucleus 등이 있으며, 
이 중 Hibernate가 가장 널리 사용된다.
 
객체지향 프로그래밍은 다형성, 상속 등의 특성을 활용해 유연하고 확장 가능한 코드를 작성할 수 있게 해 준다. 
하지만 이러한 객체들을 관계형 데이터베이스에 저장하려고 하면, 객체들의 관계를 테이블에 맞춰 저장하고 관리해줘야 하기 때문에 복잡하고 어려워진다. 
JPA를 사용하면, 객체와 데이터베이스 테이블 간의 매핑 설정만으로도 객체의 상태를 데이터베이스에 맞춰 저장하고 관리할 수 있다. 
이로 인해 개발자는 객체 지향적인 코드 작성에 집중할 수 있으며, 데이터베이스와의 패러다임 불일치 문제를 걱정하지 않아도 된다.

JPA 사용 예시
사용자 정보를 데이터베이스에 저장하고 조회하는 간단한 작업을 수행한다고 가정해 보자. JPA 를 사용하지 않고 이를 수행하기 위해서는 아래처럼 작성해야 한다.

java
public class UserDao {
  private DataSource dataSource;
 
  public UserDao(DataSource dataSource) {
      this.dataSource = dataSource;
  }
 
  public void addUser(User user) throws SQLException {
      String sql = "INSERT INTO users (username, email) VALUES (?, ?)";
      try (Connection conn = dataSource.getConnection();
           PreparedStatement pstmt = conn.prepareStatement(sql)) {
          pstmt.setString(1, user.getUsername());
          pstmt.setString(2, user.getEmail());
          pstmt.executeUpdate();
      }
  }
 
  public User getUser(String username) throws SQLException {
      String sql = "SELECT * FROM users WHERE username = ?";
      try (Connection conn = dataSource.getConnection();
           PreparedStatement pstmt = conn.prepareStatement(sql)) {
          pstmt.setString(1, username);
          ResultSet rs = pstmt.executeQuery();
          if (rs.next()) {
              return new User(rs.getString("username"), rs.getString("email"));
          }
          return null;
      }
  }
}

위의 코드에서 볼 수 있듯이, 각각의 데이터베이스 연산을 위해 SQL 쿼리를 직접 작성해야 한다. 이는 시간이 많이 걸릴 뿐 아니라 오류가 발생하기도 쉽다.
이때 JPA를 사용해 엔티티 클래스를 정의하면(위에서 서술한 대로 JPA를 사용했다는 것은 구현했다는 뜻이니, 정확히 말하면 Hibernate를 사용한 것이다.)

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
 
    @Column(name = "username")
    private String username;
 
    @Column(name = "email")
    private String email;
 
    // Constructor, Getter, Setter 생략
    
    public class UserDao {
    @PersistenceContext
    private EntityManager em;
 
    public void addUser(User user) {
        em.persist(user);
    }
 
    public User getUser(String username) {
        return em.createQuery("SELECT u FROM User u WHERE u.username = :username", User.class)
                .setParameter("username", username)
                .getSingleResult();
    }
}

SQL 쿼리를 직접 작성하는 대신 객체와 데이터베이스 테이블 간의 매핑을 정의하고, 간단한 메서드 호출로 데이터베이스 작업을 수행할 수 있다. 
이는 편리할 뿐만 아니라, 코드의 가독성과 유지보수성도 높일 수 있다.

JPA의 장점
위 예시를 토대로 장점을 정리해 보면,

1. 객체와 데이터베이스 간 패러다임 불일치 해결
 - 테이블 간의 매핑을 설정하는 것만으로 JPA가 객체의 상태를 데이터베이스에 맞춰 저장하고 관리해 준다.

2. 생산성 향상
- CRUD 작업을 위한 기본적인 SQL 쿼리를 자동으로 생성 -> 복잡한 SQL 쿼리를 직접 작성할 필요 X
- 간단하게 메서드를 호출하는 것만으로 데이터베이스 작업을 수행할 수 있다.
- 👉 개발 시간 단축, 생산성 향상

3. 유지보수성 향상
- SQL 쿼리가 여러 곳에 흩어져 있다면 데이터베이스 구조가 변경될 때마다 모든 관련 SQL 쿼리를 찾아 수정해야 한다.
- 반면에 JPA는 데이터베이스 구조가 변경되어도 대부분의 경우 알아서 처리 -> 관련 코드를 일일이 수정할 필요 X 
- 객체 중심의 코드 -> 가독성이 좋고 이해하기 쉽다.
- 👉 유지보수성 향상

4. 데이터베이스 독립성
- 데이터베이스를 변경하려고 할 때, 기존에 작성된 SQL 쿼리가 새로운 데이터베이스에서 작동하지 않을 수 있어 수정이 필요한 경우도 있다.
- 반면에 JPA는 데이터베이스에 독립적이므로 데이터베이스 변경 시 코드 수정이 최소화된다.

5. 성능 향상
- 개발자가 직접 작성한 SQL 쿼리는 최적화되지 않을 수 있음 -> 애플리케이션 성능 저하 가능성 ▲
- JPA는 지연 로딩, 쓰기 지연, 1차 캐시 등 다양한 성능 최적화 기능을 제공
- 👉 불필요한 데이터베이스 접근▼, 성능▲
- 지연 로딩(Lazy Loading)
 필요할 때까지 관련된 엔티티를 로딩하지 않음
 ex) 사용자 정보 조회 시 - 해당 사용자의 모든 게시물을 바로 로딩하지 않고, 실제로 게시물 정보가 필요할 때만 데이터베이스에서 조회 가능. 
 초기 로딩 시간을 줄이고 리소스 사용을 최적화
- 1차 캐시(First-Level Cache)
  영속성 컨텍스트 내에 1차 캐시를 유지
-> 한 트랜잭션 내에서 같은 엔티티에 대한 반복적인 조회 요청이 있을 때 데이터베이스에 여러 번 접근하는 것을 방지
-> 데이터베이스 부하▼, 성능▲
쓰기 지연(Write Behind)
트랜잭션이 커밋되기 전까지 변경된 엔티티를 메모리에 보관
커밋 시점에 변경 사항을 데이터베이스에 반영
-> 데이터베이스와의 불필요한 연결과 데이터 전송 최소화
배치 처리(Batch Processing)
여러 개의 삽입, 업데이트, 삭제 등의 쿼리를 하나의 배치 작업으로 묶어 처리 가능
네트워크 비용 감소, 데이터베이스 처리 성능 향상
쿼리 캐시(Query Cache)
자주 사용되는 쿼리의 결과를 캐시에 저장 -> 동일한 쿼리 요청이 있을 때 캐시에서 결과를 바로 가져옴(데이터베이스 접근 X)
JPA의 동작 원리
애플리케이션과 JDBC 사이에서 동작 : JDBC API를 사용해 데이터베이스와 통신
Entity 객체 분석 및 SQL 생성
애플리케이션에서 JPA의 persist() 메서드 호출
JPA : Entity 객체 분석 -> 적절한 SQL 생성
생성된 SQL -> JDBC API를 통해 데이터베이스에 전송되어 실행
객체-관계 매핑
 
[Java] JDBC(Java Database Connectivity)

JDBC란? JDBC(Java Database Connectivity) : 애플리케이션에서 데이터베이스에 데이터를 저장하거나 업데이트, 접근할 수 있도록 도와주는 자바 API 데이터베이스 연결, SQL문 실행, 쿼리 결과 처리 등을 위

chaeyami.tistory.com
하이버네이트(Hibernate)
하이버네이트는 Java 언어를 위한 ORM 프레임워크이며, JPA 인터페이스를 구현한 구현체이다.

따라서 이도 JDBC API를 내부적으로 사용하고, JPA의 특징, 장점을 그대로 가지고 우리가 직접 사용할 수 있게 해 준다.

Hibernate 주요 특징
JPA의 구현체이기 때문에 당연히 JPA 특징과 같겠지만, 다시 정리해 보면 다음과 같다.

ORM 기능 : 객체와 관계형 데이터베이스 간의 매핑
JDBC 추상화
JPQL(Java Persistence Query Language), 네이티브 SQL, Querydsl 등 다양한 쿼리 언어 지원
캐싱 기능
데이터베이스 독립성
Hibernate 사용 방법
위 JPA에서 간단하게 알아본 사용 방법을 좀 더 자세히 알아보자.

1. 엔티티 클래스 정의
JPA 어노테이션을 사용해 데이터베이스 테이블과 매핑되는 엔티티 클래스를 정의한다. 대표적인 어노테이션으로는 @Entity, @Table, @Id, @Column 등이 있다.

java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name")
    private String name;
    
    @Column(name = "email")
    private String email;
    
    // Getter, Setter, Constructor 
}
Copy
2. EntityManager 생성
EntityManagerFactory를 통해 EntityManager를 생성한다. 데이터베이스 연결, 트랜잭션 관리를 수행한다.

java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("myPersistenceUnit");
EntityManager em = emf.createEntityManager();
Copy
3. CRUD 작업 수행
EntityManager를 구현한 메서드(예시에선 em)를 사용하여 엔티티에 대한 CRUD 작업을 수행하면 된다.

위에서 만든 user 테이블에 대한 CRUD를 구현한다고 하면,

java
// Create
em.getTransaction().begin();
User user = new User("Chaeyami", "chaeyami@example.com");
em.persist(user);
em.getTransaction().commit();
 
// Read
User foundUser = em.find(User.class, user.getId());
 
// Update
em.getTransaction().begin();
foundUser.setEmail("chaeyami02@example.com");
em.merge(foundUser);
em.getTransaction().commit();
 
// Delete
em.getTransaction().begin();
em.remove(foundUser);
em.getTransaction().commit();
Copy
4. 쿼리 작성

위에서 말한 대로 JPQL, 네이티브 SQL, Querydsl 등을 사용할 수 있다.  만약 JPQL이나 네이티브 SQL을 사용해 user 테이블에 있는 모든 컬럼을 가져오고 싶다면,

java
// JPQL
List<User> users = em.createQuery("SELECT u FROM User u", User.class).getResultList();
 
// Native SQL
List<User> users = em.createNativeQuery("SELECT * FROM users", User.class).getResultList();
Copy
이렇게 작성해서 실행할 수 있다.

