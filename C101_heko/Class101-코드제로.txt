✅ 왜 Spring Boot 백엔드를 배워야 할까요?
지금도 수많은 기업과 서비스들이 Spring Boot 기반의 백엔드 시스템 위에서 돌아가고 있습니다. REST API, 데이터베이스 연동, 인증과 보안, 트랜잭션 처리 등… 모든 백엔드의 핵심은 ‘실제로 작동하는 구조’를 이해하고 구현하는 것입니다. 하지만 이런 구조를 이론만으로는 절대 익히기 어렵습니다. 직접 만들고, 테스트하고, 고쳐보고, 개선해봐야 비로소 실무에서 요구하는 백엔드 개발자의 역량을 갖추게 됩니다.

이 클래스는 초보자가 실무 수준으로 올라갈 수 있도록 설계됐어요. 도서 대여 관리 시스템을 프로젝트로 삼아, REST API부터 JPA, 트랜잭션까지 핵심 기술을 배워봅니다. 코드 작성과 테스트를 각 챕터에 함께 넣어, "만들고 바로 확인"하며 실습 중심으로 진행해요. 매일 1시간씩 일주일간 총 7시간으로 부담 없이 완성할 수 있습니다.

🚩 강의 개요
총 시간: 약 7시간

프로젝트: 도서 대여 관리 시스템 백엔드 (예: /books/, /rentals/ API).

특징:
Annotation(@RestController, @Entity)과 JPA 관계 설정 체계적 학습.

Service 중심 테스트, Controller 응답 검증 포함.

🚩 이 커리큘럼의 강점
테스트 통합: 코드 작성 후 즉시 테스트로 검증.
실무 준비: 비즈니스 로직 중심으로 실용성 강화.
부담 없는 속도: 매일 1시간 7일완성

🚩 이런 분께 추천해요
Spring Boot를 배우고 싶은 백엔드 입문자
책, 강의만 보고 실제 프로젝트는 막막한 분
실무에서 쓰는 방식으로 프로젝트를 완성해보고 싶은 분
테스트, 예외 처리, 보안까지 한 번에 배우고 싶은 분

Spring Boot를 처음 접하는 당신도 이 커리큘럼으로 백엔드 개발의 핵심을 잡을 수 있어요. 코드와 테스트를 함께 쓰며 "내가 만든 게 잘 돼요!"를 느끼는 여정을 시작해 보세요!

스프링부트 백엔드 기초과정
2025년 5월 16일 수강 시작
총 6시간 42분


커리큘럼

클래스 소개
1. 클래스 소개 - 클래스 기획 의도 및 목표 안내

Spring Boot
RESTful API 기초
Spring Core와 계층 구조
JPA와 H2 데이터베이스
예외 처리와 유효성 검사
JPA 연관관계 기초와 실전 활용: 도서 대여 예제로 배우기
트랜잭션과 도서반납
H2에서 MariaDB로 전환
REST API 고급
성능 최적화
운영
보안(스프링 시큐리티)

크리에이터
코드제로

코드제로
안녕하세요! 저는 비전공자로 개발 세계에 뛰어들어, 10년의 우여곡절 끝에 Spring Boot로 백엔드 개발의 매력을 알게 된 크리에이터입니다. 제 여정은 조금 독특해요. 
대학에서 전공은 없었지만, 일본에서 첫 직장 생활을 시작하며 JSP로 웹 개발의 문을 열었죠. 그 후 게임 회사에서 PHP와 Node.js를 다루며 서버 개발의 재미를 느끼기 시작했습니다.

그러다 만난 Spring으로 서비스를 개발하면서 백엔드의 진짜 힘을 깨달았어요. 복잡한 설정 없이 비즈니스 로직에 집중할 수 있는 Spring Boot의 유연함과 강력함에 푹 빠졌죠. 
다양한 언어와 프로젝트를 거친 경험 덕분에, 초보자가 어디서 막히고 무엇을 어려워하는지 누구보다 잘 이해할 수 있어요.

이 강의에서는 제가 비전공자로 시작해 쌓아온 실무 노하우를 아낌없이 풀어냅니다. "도서 대여 관리 시스템"을 함께 만들며, Spring Boot의 핵심부터 실무 적용까지 마스터할 수 있도록 이끌어줄게요. 
저와 함께라면, 당신도 백엔드 개발의 첫걸음을 떼고 자신감을 얻을 수 있을 거예요!

===========================================================================================================================

Spring Boot 시작하기

Spring Boot 시작하기 - Spring Boot와 Annotation 기초

1. Spring Boot란?
Spring Boot는 Spring Framework를 기반으로 한 경량화된 프레임워크로, 복잡한 설정 없이 빠르게 애플리케이션을 개발할 수 있도록 도와줍니다.

📌 Spring Boot의 주요 특징
자동 설정(Auto Configuration): 복잡한 설정 없이 기본값으로 자동 설정됨
독립 실행 가능(Standalone Application): 내장 웹 서버(Tomcat, Jetty 등) 포함 가능
Spring과의 강력한 통합: 기존 Spring 생태계를 간편하게 사용 가능
Gradle 및 Maven 빌드 지원: 본 강의에서는 Gradle을 사용하여 프로젝트를 설정합니다.
2. Spring Boot 프로젝트 구조
Spring Boot 프로젝트는 일반적으로 다음과 같은 구조로 구성됩니다.

my-springboot-app/
 ├── src/main/java/ (애플리케이션 코드)
 ├── src/main/resources/ (설정 파일, 정적 리소스)
 ├── build.gradle (Gradle 설정 파일)
 ├── application.properties (환경 설정 파일)
3. Spring Boot의 주요 Annotation
Spring Boot는 다양한 애노테이션을 제공하여 설정 및 제어를 간편하게 합니다.

✅ 필수 애노테이션
애노테이션설명@SpringBootApplicationSpring Boot 애플리케이션의 시작점@RestControllerRESTful 웹 서비스를 만들 때 사용@RequestMapping특정 URL과 컨트롤러 메서드를 매핑@GetMappingHTTP GET 요청을 처리@PostMappingHTTP POST 요청을 처리@PutMappingHTTP PUT 요청을 처리@DeleteMappingHTTP DELETE 요청을 처리@ResponseBody컨트롤러의 메서드 반환 값을 HTTP 응답 본문으로 변환

🛠 예제 코드
@RestController
@RequestMapping("/hello")
public class HelloController {
    @GetMapping
    public String sayHello() {
        return "Hello, Spring Boot!";
    }
}
위 코드에서 @RestController는 컨트롤러 클래스임을 나타내며, @GetMapping은 GET 요청을 처리하는 엔드포인트를 정의합니다.

@ResponseBody는 @RestController 내부에서는 자동 적용되지만, 일반적인 @Controller 클래스에서 사용하면 메서드 반환값을 JSON 형식으로 변환하는 역할을 합니다.

4. 요약
Spring Boot는 Spring Framework를 보다 쉽게 사용할 수 있도록 제공된 프레임워크이다.
@SpringBootApplication, @RestController, @RequestMapping 등의 주요 애노테이션을 이해하고 활용할 수 있다.
Gradle을 이용해 Spring Boot 프로젝트를 설정하고 실행하는 방법을 익힌다

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Boot 시작하기 - 개발 환경 설정
1. 개발 환경 선택
Spring Boot 개발을 시작하기 위해 필요한 도구를 선택합니다.

📌 필수 도구
IntelliJ IDEA (Community Edition)
JDK 17 이상 (권장: OpenJDK)
Gradle (별도 설치 없이 IntelliJ에서 자동 지원)
Spring Initializr (https://start.spring.io/)
2. Spring Initializr를 이용한 프로젝트 생성
IntelliJ에서 직접 프로젝트를 생성하는 대신 Spring Initializr를 활용하여 프로젝트를 시작합니다.

3. 프로젝트 실행
IntelliJ에서 프로젝트를 연 후, MyApplication.java 파일을 실행하면 기본 서버가 실행됩니다.

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Spring Boot 시작하기 - 첫 API & Git init

1. 개발 환경 선택
Spring Boot 개발을 시작하기 위해 필요한 도구를 선택합니다.

📌 필수 도구
IntelliJ IDEA (Community Edition)
JDK 17 이상 (권장: OpenJDK)
Gradle (별도 설치 없이 IntelliJ에서 자동 지원)
Spring Initializr (https://start.spring.io/)
2. Spring Initializr를 이용한 프로젝트 생성
IntelliJ에서 직접 프로젝트를 생성하는 대신 Spring Initializr를 활용하여 프로젝트를 시작합니다.

3. 프로젝트 실행
IntelliJ에서 프로젝트를 연 후, MyApplication.java 파일을 실행하면 기본 서버가 실행됩니다.

@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
RESTful API
RESTful API 기초

1. RESTful API 기초 - RESTfull API 개념과 설계
학습 목표:
RESTful API의 개념과 설계 원칙 이해.
Spring Boot로 REST API 시작 준비.

1. REST란?정의: 자원을 URI로 표현하고 HTTP 메서드로 조작하는 설계 스타일.

핵심 원칙:
자원 중심: /books처럼 명사 사용.
HTTP 메서드: GET(조회), POST(생성).
상태 비저장: 요청 독립성 유지.
비유: "도서관에서 책을 URI로 찾고, 메서드로 빌리기."

2. RESTful API 설계 예시도서 관리:
GET /books: 모든 책 조회.
POST /books: 새 책 생성.
GET /books/1: ID 1번 책 조회.
설계 팁:
URI 간결: /books/{id} (O), /getBooks (X).
상태 코드: 200(성공), 201(생성).

3. Spring Boot 환경 설정도구: IntelliJ IDEA
설정:
IntelliJ: Spring Initializr로 spring-boot-starter-web 추가.
pom.xml
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-web</artifactId>
</dependency>

4. 첫 REST API 구현코드:

@RestController
public class HelloController {
@GetMapping("/hello")
public String sayHello() {
return "Hello, REST!";
}
}

실행: http://localhost:8080/hello → "Hello, REST!".
설명: @RestController로 JSON 응답 처리.

5. 실습 과제/hello API 만들고 Postman으로 테스트.

질문: "GET과 POST의 역할 차이는?"

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
2. RESTful API 기초 - 도서 수정과 삭제 API

수업 노트
학습 목표: PUT과 DELETE로 도서 API 구현, IntelliJ로 실행 및 테스트, 실무에서의 활용 이해.

1. 도서 수정 API 설계 (3분)설계: PUT /books/{id}로 특정 책 수정.

실무 팁: 부분 수정 시 PATCH 고려 가능.
2. 도서 수정 API 구현 (3분)코드:

@PutMapping("/{id}")

public ResponseEntity<Book> updateBook(@PathVariable Long id, @RequestBody Book updatedBook) {

for (Book book : books) {

if (book.getId().equals(id)) {

book.setTitle(updatedBook.getTitle());

return ResponseEntity.ok(book);

}

}

return ResponseEntity.status(HttpStatus.NOT_FOUND).build();

}

실행: IntelliJ Run 버튼으로 서버 실행.

테스트: Postman으로 PUT /books/1 요청 ({"title": "Updated Book"}).

3. 도서 삭제 API 설계와 구현 (3분)설계: DELETE /books/{id}로 특정 책 삭제.



@DeleteMapping("/{id}")

public ResponseEntity<Void> deleteBook(@PathVariable Long id) {

for (Iterator<Book> iterator = books.iterator(); iterator.hasNext();) {

Book book = iterator.next();

if (book.getId().equals(id)) {

iterator.remove();

return ResponseEntity.noContent().build();

}

}

return ResponseEntity.status(HttpStatus.NOT_FOUND).build();

}

설명: 성공 시 204 No Content, 실패 시 404 Not Found.
테스트: Postman으로 DELETE /books/1 요청.
4. 실무에서 주의할 점 (2분)실무 예: 삭제 전 확인 로직 추가 (예: 배송 중 주문 삭제 방지).

팁: DELETE는 되돌리기 어려우므로 신중히 설계.
6. 테스트와 실습 과제 (3분)테스트: Postman으로 PUT과 DELETE 확인.

실습: 책 2권 추가 후 1권 수정, 1권 삭제 테스트.
질문: "PUT과 PATCH의 차이는?"
과제: 삭제 API에서 사용한 Iterator와 수정 API에서 사용한 향상된 반복문(for (Book book : books))의 차이를 다음 시간까지 조사.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

RESTful API 기초 - /books/ API 테스트
12:14
0
수업 노트
학습 목표: JUnit으로 REST API 테스트 코드 작성, 비즈니스 로직 검증, 실무에서의 테스트 중요성 이해.
구성: 6개 섹션으로 15분 맞춤.
1. 테스트 코드의 필요성
테스트 목적: API 동작 검증, 버그 방지.
배포 전 테스트로 오류 감지.
목표: GET /books와 POST /books 테스트.
2. JUnit으로 도서 조회 API 테스트
@SpringBootTest
@AutoConfigureMockMvc
public class BookControllerTest {
    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testGetBooks() throws Exception {
        mockMvc.perform(get("/books"))
               .andExpect(status().isOk())
               .andExpect(content().json("[]"));
    }
}
실행: IntelliJ에서 테스트 실행 (우클릭 → Run Test).
설명: MockMvc로 HTTP 요청 시뮬레이션, 상태 코드와 응답 확인.
3. 도서 생성 API 테스트 (3분)
@Test
public void testCreateBook() throws Exception {
    String bookJson = "{"title": "Test Book"}";
    mockMvc.perform(post("/books")
            .contentType(MediaType.APPLICATION_JSON)
            .content(bookJson))
           .andExpect(status().isCreated())
           .andExpect(jsonPath("$.title").value("Test Book"));
}
실행: IntelliJ에서 테스트 실행.
설명: POST /books 요청 테스트, 201 Created와 응답 데이터 확인.
4. 테스트와 실습 과제
테스트: IntelliJ에서 테스트 실행 확인.
실습: PUT API 테스트 코드 작성 (제목 수정 후 200 OK 확인).




---
Spring Core
Spring Core와 계층 구조

1. Spring Core와 계층 구조 - IoC와 DI 이해

1. IoC (Inversion of Control)란?
IoC는 객체의 생성과 관리를 개발자가 직접 하는 것이 아니라, 프레임워크나 컨테이너가 대신 수행하도록 하는 개념입니다.

IoC의 주요 개념
제어의 역전: 객체의 생성과 생명 주기를 직접 관리하는 것이 아니라 컨테이너(Spring)가 담당합니다.
Spring IoC 컨테이너: ApplicationContext를 활용하여 빈(Bean) 객체를 관리합니다.
의존성 관리: 애플리케이션에서 객체 간의 의존성을 컨테이너가 자동으로 관리하여 결합도를 낮춥니다.
2. DI (Dependency Injection)란?
DI는 객체 간의 의존성을 주입하는 방식입니다. 즉, 객체가 필요한 의존성을 직접 생성하는 것이 아니라 외부에서 주입받습니다.

DI의 주요 개념
의존성 제거: 객체 간의 강한 결합을 줄여 코드의 유연성을 증가시킵니다.
테스트 용이성: 모의 객체(Mock)를 활용하여 단위 테스트가 쉽습니다.
유지보수성 증가: 코드 변경 시 영향도를 줄여 유지보수가 편리합니다.
DI 방식
생성자 주입: 생성자를 통해 의존성을 주입하는 방식 (권장)
세터 주입: Setter 메서드를 통해 의존성을 주입하는 방식
필드 주입: 필드에 직접 주입하는 방식 (테스트 및 유지보수 어려움으로 비추천)
3. IoC와 DI를 활용하는 이유
객체 관리의 자동화: 개발자가 객체를 직접 관리하지 않아도 됨
유지보수성 향상: 코드 수정 시 다른 부분에 미치는 영향을 최소화
테스트 가능성 증가: 의존성 주입을 활용하여 독립적인 단위 테스트 수행 가능
다음 강의 내용
서비스 계층 설계에서 IoC와 DI를 실제 코드에서 어떻게 적용하는지 살펴볼 예정입니다.


--
2. Spring Core와 계층 구조 - 서비스 계층
1. 서비스 계층이란?
서비스 계층(Service Layer)은 비즈니스 로직을 처리하는 핵심 계층으로, 컨트롤러와 데이터 접근 계층 사이에서 역할을 합니다.

2. 서비스 계층이 필요한 이유
비즈니스 로직의 분리: 컨트롤러가 지나치게 많은 로직을 가지지 않도록 방지
재사용성 증가: 여러 컨트롤러에서 같은 로직을 재사용 가능
유지보수성 향상: 로직이 한 곳에 집중되어 있어 변경이 용이함
테스트 용이: 서비스 계층을 단위 테스트하기 쉬움
3. 서비스 계층의 역할
(1) 비즈니스 로직 처리
핵심적인 업무 규칙을 구현
여러 데이터 조작 로직을 하나의 트랜잭션으로 묶음
(2) 데이터 접근 계층과 분리
데이터 저장을 List를 활용하여 관리
데이터를 조회, 추가, 수정, 삭제하는 기능 수행
4. 서비스 계층 설계 예제
(1) 컨트롤러가 서비스 계층 없이 직접 데이터를 관리하는 경우 (문제점)
@RestController
@RequestMapping("/books")
public class BookController {
    private final List<Book> books = new ArrayList<>();

    @PostMapping
    public Book createBook(@RequestBody Book book) {
        book.setId((long) (books.size() + 1));
        books.add(book);
        return book;
    }
}
(2) 서비스 계층을 도입한 경우 (권장되는 방식)
@Service
public class BookService {
    private final List<Book> books = new ArrayList<>();

    public Book createBook(Book book) {
        book.setId((long) (books.size() + 1));
        books.add(book);
        return book;
    }

    public Book updateBook(Long id, Book updateBook) {
        for (Book book : books) {
            if (book.getId().equals(id)) {
                book.setTitle(updateBook.getTitle());
                return book;
            }
        }
        return null;
    }
}
@RestController
@RequestMapping("/books")
public class BookController {
    private final BookService bookService;

    public BookController(BookService bookService) {
        this.bookService = bookService;
    }

    @PostMapping
    public Book createBook(@RequestBody Book book) {
        return bookService.createBook(book);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Book> updateBook(@PathVariable Long id, @RequestBody Book updateBook) {
        Book updated = bookService.updateBook(id, updateBook);
        if (updated != null) {
            return ResponseEntity.ok(updated);
        }
        return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
    }
}
6. 정리
서비스 계층은 컨트롤러와 데이터 접근 계층을 분리하는 역할을 한다.
비즈니스 로직을 서비스 계층에서 처리하면 코드의 유지보수성과 재사용성이 향상된다.
서비스 계층을 단위 테스트하면 안정적인 애플리케이션 개발이 가능하다.


--
Spring Core와 계층 구조 - 서비스 계층 테스트
13:05
0

(선택) - 프로젝트 이름 변경
05:03
0
JPA
JPA와 H2 데이터베이스
